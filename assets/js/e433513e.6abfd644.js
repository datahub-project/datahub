"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[41776],{15680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>y});var a=n(96540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),g=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=g(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=g(n),d=r,y=p["".concat(s,".").concat(d)]||p[d]||c[d]||i;return n?a.createElement(y,o(o({ref:t},u),{},{components:n})):a.createElement(y,o({ref:t},u))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var g=2;g<i;g++)o[g]=n[g];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},33049:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>y,frontMatter:()=>l,metadata:()=>g,toc:()=>p});n(96540);var a=n(15680);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}const l={title:"Search and Graph Reindexing",slug:"/how/restore-indices",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/how/restore-indices.md"},s="Search and Graph Reindexing",g={unversionedId:"docs/how/restore-indices",id:"docs/how/restore-indices",title:"Search and Graph Reindexing",description:"If your search infrastructure (Elasticsearch/OpenSearch) or graph services (Elasticsearch/OpenSearch/Neo4j) become inconsistent or out-of-sync with your primary metadata store, you can rebuild them from the source of truth: the metadataaspectv2 table in your relational database (MySQL/Postgres).",source:"@site/genDocs/docs/how/restore-indices.md",sourceDirName:"docs/how",slug:"/how/restore-indices",permalink:"/docs/how/restore-indices",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/how/restore-indices.md",tags:[],version:"current",frontMatter:{title:"Search and Graph Reindexing",slug:"/how/restore-indices",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/how/restore-indices.md"},sidebar:"overviewSidebar",previous:{title:"Backup & Restore",permalink:"/docs/how/backup-datahub"},next:{title:"Load Indices: High-Performance Bulk Index Loading",permalink:"/docs/how/load-indices"}},u={},p=[{value:"How it Works",id:"how-it-works",level:2},{value:"Reindexing Configuration Options",id:"reindexing-configuration-options",level:2},{value:"\ud83d\udd04 Pagination &amp; Performance",id:"-pagination--performance",level:3},{value:"\ud83d\udcc5 Time Filtering",id:"-time-filtering",level:3},{value:"\ud83d\udd0d Content Filtering",id:"-content-filtering",level:3},{value:"\ud83e\uddf1 Other Options",id:"-other-options",level:3},{value:"Running the Restore Job",id:"running-the-restore-job",level:2},{value:"\ud83e\uddea Quickstart CLI",id:"-quickstart-cli",level:3},{value:"\ud83d\udc33 Docker Compose",id:"-docker-compose",level:3},{value:"\u2638\ufe0f Kubernetes (Helm)",id:"\ufe0f-kubernetes-helm",level:3},{value:"Through APIs",id:"through-apis",level:3},{value:"OpenAPI",id:"openapi",level:4},{value:"Rest.li",id:"restli",level:4},{value:"CLI",id:"cli",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"K8 Job vs. API",id:"k8-job-vs-api",level:3},{value:"When to Use Kubernetes Jobs",id:"when-to-use-kubernetes-jobs",level:4},{value:"When to Use APIs",id:"when-to-use-apis",level:4},{value:"Targeted Restoration Strategies",id:"targeted-restoration-strategies",level:3},{value:"Entity Type Filtering",id:"entity-type-filtering",level:4},{value:"Single Entity",id:"single-entity",level:4},{value:"Time-Based",id:"time-based",level:4},{value:"Parallel Processing Strategies",id:"parallel-processing-strategies",level:3},{value:"Multiple Parallel Jobs",id:"multiple-parallel-jobs",level:4},{value:"Temporary Workload Reduction",id:"temporary-workload-reduction",level:3},{value:"Infrastructure Tuning",id:"infrastructure-tuning",level:3},{value:"Elasticsearch/Opensearch Optimization",id:"elasticsearchopensearch-optimization",level:4},{value:"Refresh Interval Adjustment:",id:"refresh-interval-adjustment",level:5},{value:"Bulk Processing Improvements:",id:"bulk-processing-improvements",level:5},{value:"Shard Management:",id:"shard-management",level:5},{value:"SQL/Primary Storage",id:"sqlprimary-storage",level:4},{value:"Kafka &amp; Consumers",id:"kafka--consumers",level:4},{value:"Partition Strategy:",id:"partition-strategy",level:5},{value:"Consumer Scaling:",id:"consumer-scaling",level:5},{value:"Monitoring:",id:"monitoring",level:5}],c={toc:p},d="wrapper";function y(e){var{components:t}=e,n=o(e,["components"]);return(0,a.yg)(d,i(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){r(e,t,n[t])}))}return e}({},c,n),{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"search-and-graph-reindexing"},"Search and Graph Reindexing"),(0,a.yg)("p",null,"If your search infrastructure (Elasticsearch/OpenSearch) or graph services (Elasticsearch/OpenSearch/Neo4j) become inconsistent or out-of-sync with your primary metadata store, you can ",(0,a.yg)("strong",{parentName:"p"},"rebuild them from the source of truth"),": the ",(0,a.yg)("inlineCode",{parentName:"p"},"metadata_aspect_v2")," table in your relational database (MySQL/Postgres)."),(0,a.yg)("p",null,"This process works by fetching the latest version of each aspect from the database and replaying them as Metadata Change Log (MCL) events. These events will regenerate your search and graph indexes, effectively restoring a consistent view."),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"\u26a0\ufe0f ",(0,a.yg)("strong",{parentName:"p"},"Note"),": By default, this process does ",(0,a.yg)("strong",{parentName:"p"},"not remove")," stale documents from the index that no longer exist in the database. To ensure full consistency, we recommend reindexing into a clean instance, or using the ",(0,a.yg)("inlineCode",{parentName:"p"},"-a clean")," option to wipe existing index contents before replay.")),(0,a.yg)("hr",null),(0,a.yg)("h2",{id:"how-it-works"},"How it Works"),(0,a.yg)("p",null,"Reindexing is powered by the ",(0,a.yg)("inlineCode",{parentName:"p"},"datahub-upgrade")," utility (packaged as the ",(0,a.yg)("inlineCode",{parentName:"p"},"datahub-upgrade")," container in Docker/Kubernetes). It supports a special upgrade task called ",(0,a.yg)("inlineCode",{parentName:"p"},"RestoreIndices"),", which replays aspects from the database back into search and graph stores."),(0,a.yg)("p",null,"You can run this utility in three main environments:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Quickstart (via CLI)"),(0,a.yg)("li",{parentName:"ul"},"Docker Compose (via shell script)"),(0,a.yg)("li",{parentName:"ul"},"Kubernetes (via Helm + CronJob)")),(0,a.yg)("hr",null),(0,a.yg)("h2",{id:"reindexing-configuration-options"},"Reindexing Configuration Options"),(0,a.yg)("p",null,"When running the ",(0,a.yg)("inlineCode",{parentName:"p"},"RestoreIndices")," job, you can pass additional arguments to customize the behavior:"),(0,a.yg)("h3",{id:"-pagination--performance"},"\ud83d\udd04 Pagination & Performance"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Argument"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"urnBasedPagination")),(0,a.yg)("td",{parentName:"tr",align:null},"Use URN-based pagination instead of offset. Recommended for large datasets.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"startingOffset")),(0,a.yg)("td",{parentName:"tr",align:null},"Starting offset for offset-based pagination.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"lastUrn")),(0,a.yg)("td",{parentName:"tr",align:null},"Resume from this URN (used with URN pagination).")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"lastAspect")),(0,a.yg)("td",{parentName:"tr",align:null},"Resume from this aspect name (used with ",(0,a.yg)("inlineCode",{parentName:"td"},"lastUrn"),").")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"numThreads")),(0,a.yg)("td",{parentName:"tr",align:null},"Number of concurrent threads for reindexing.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"batchSize")),(0,a.yg)("td",{parentName:"tr",align:null},"Number of records per batch.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"batchDelayMs")),(0,a.yg)("td",{parentName:"tr",align:null},"Delay in milliseconds between each batch (throttling).")))),(0,a.yg)("h3",{id:"-time-filtering"},"\ud83d\udcc5 Time Filtering"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Argument"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"gePitEpochMs")),(0,a.yg)("td",{parentName:"tr",align:null},"Only restore aspects created ",(0,a.yg)("strong",{parentName:"td"},"after")," this timestamp (in ms).")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"lePitEpochMs")),(0,a.yg)("td",{parentName:"tr",align:null},"Only restore aspects created ",(0,a.yg)("strong",{parentName:"td"},"before")," this timestamp (in ms).")))),(0,a.yg)("h3",{id:"-content-filtering"},"\ud83d\udd0d Content Filtering"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Argument"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"aspectNames")),(0,a.yg)("td",{parentName:"tr",align:null},"Comma-separated list of aspects to restore (e.g., ",(0,a.yg)("inlineCode",{parentName:"td"},"ownership,status"),").")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"urnLike")),(0,a.yg)("td",{parentName:"tr",align:null},"SQL LIKE pattern to filter URNs (e.g., ",(0,a.yg)("inlineCode",{parentName:"td"},"urn:li:dataset%"),").")))),(0,a.yg)("h3",{id:"-other-options"},"\ud83e\uddf1 Other Options"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Argument"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"createDefaultAspects")),(0,a.yg)("td",{parentName:"tr",align:null},"Whether to create default aspects in SQL & index if missing. ",(0,a.yg)("strong",{parentName:"td"},"Disable")," this if using a read-only replica.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"clean")),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("strong",{parentName:"td"},"Deletes existing index documents before restoring.")," Use with caution. Note, it will clean the entire index before running the reindex step, thus ignoring any filters based on urn and aspect for reindex.")))),(0,a.yg)("hr",null),(0,a.yg)("h2",{id:"running-the-restore-job"},"Running the Restore Job"),(0,a.yg)("h3",{id:"-quickstart-cli"},"\ud83e\uddea Quickstart CLI"),(0,a.yg)("p",null,"If you're using DataHub's quickstart image, you can restore indices using a single CLI command:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"datahub docker quickstart --restore-indices\n")),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"This command automatically clears the search and graph indices before restoring them.")),(0,a.yg)("p",null,"More details in the ",(0,a.yg)("a",{parentName:"p",href:"/docs/quickstart#restore-datahub"},"Quickstart Docs"),"."),(0,a.yg)("hr",null),(0,a.yg)("h3",{id:"-docker-compose"},"\ud83d\udc33 Docker Compose"),(0,a.yg)("p",null,"If you're using Docker Compose and have cloned the ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/datahub-project/datahub"},"DataHub source repo"),", run:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"./docker/datahub-upgrade/datahub-upgrade.sh -u RestoreIndices\n")),(0,a.yg)("p",null,"To clear existing index contents before restore (recommended if you suspect inconsistencies), add ",(0,a.yg)("inlineCode",{parentName:"p"},"-a clean"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"./docker/datahub-upgrade/datahub-upgrade.sh -u RestoreIndices -a clean\n")),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"Without the ",(0,a.yg)("inlineCode",{parentName:"p"},"-a clean")," flag, old documents may remain in your search/graph index, even if they no longer exist in your SQL database.")),(0,a.yg)("p",null,"Refer to the ",(0,a.yg)("a",{parentName:"p",href:"/docs/docker/datahub-upgrade#environment-variables"},"Upgrade Script Docs")," for more info on environment configuration."),(0,a.yg)("hr",null),(0,a.yg)("h3",{id:"\ufe0f-kubernetes-helm"},"\u2638\ufe0f Kubernetes (Helm)"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Check if the Job Template Exists"))),(0,a.yg)("p",null,"Run:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"kubectl get cronjobs\n")),(0,a.yg)("p",null,"You should see a result like:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"datahub-datahub-restore-indices-job-template\n")),(0,a.yg)("p",null,"If not, make sure you're using the latest Helm chart version that includes the restore job."),(0,a.yg)("ol",{start:2},(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Trigger the Restore Job"))),(0,a.yg)("p",null,"Run:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"kubectl create job --from=cronjob/datahub-datahub-restore-indices-job-template datahub-restore-indices-adhoc\n")),(0,a.yg)("p",null,"This will create and run a one-off job to restore indices from your SQL database."),(0,a.yg)("ol",{start:3},(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"To Enable Clean Reindexing"))),(0,a.yg)("p",null,"Edit your ",(0,a.yg)("inlineCode",{parentName:"p"},"values.yaml")," to include the ",(0,a.yg)("inlineCode",{parentName:"p"},"-a clean")," argument:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-yaml"},'datahubUpgrade:\n  restoreIndices:\n    image:\n      args:\n        - "-u"\n        - "RestoreIndices"\n        - "-a"\n        - "batchSize=1000"\n        - "-a"\n        - "batchDelayMs=100"\n        - "-a"\n        - "clean"\n')),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"The default job does ",(0,a.yg)("strong",{parentName:"p"},"not")," delete existing documents before restoring. Add ",(0,a.yg)("inlineCode",{parentName:"p"},"-a clean")," to ensure full sync.")),(0,a.yg)("h3",{id:"through-apis"},"Through APIs"),(0,a.yg)("p",null,"See also the ",(0,a.yg)("a",{parentName:"p",href:"#best-practices"},"Best Practices")," section below, however note that the APIs are able to handle a few thousand\naspects. In this mode one of the GMS instances will perform the required actions, however it is subject to timeout. Use one of the\napproaches above for longer running restoreIndices."),(0,a.yg)("h4",{id:"openapi"},"OpenAPI"),(0,a.yg)("p",null,"There are two primary APIs, one which exposes the common parameters for restoreIndices and another one designed\nto accept a list of URNs where all aspects are to be restored."),(0,a.yg)("p",null,"Full configuration:"),(0,a.yg)("p",{align:"center"},(0,a.yg)("img",{width:"80%",src:"https://github.com/datahub-project/static-assets/blob/main/imgs/how/restore-indices/openapi-restore-indices.png?raw=true"})),(0,a.yg)("p",null,"All Aspects:"),(0,a.yg)("p",{align:"center"},(0,a.yg)("img",{width:"80%",src:"https://github.com/datahub-project/static-assets/blob/main/imgs/how/restore-indices/openapi-restore-indices-urns.png?raw=true"})),(0,a.yg)("h4",{id:"restli"},"Rest.li"),(0,a.yg)("p",null,"For Rest.li, see ",(0,a.yg)("a",{parentName:"p",href:"/docs/api/restli/restore-indices"},"Restore Indices API"),"."),(0,a.yg)("h3",{id:"cli"},"CLI"),(0,a.yg)("p",null,"The ",(0,a.yg)("a",{parentName:"p",href:"/docs/cli"},"datahub CLI")," also supports a utility command for restoring indices."),(0,a.yg)("h2",{id:"best-practices"},"Best Practices"),(0,a.yg)("p",null,"In general, this process is not required to run unless there has been a disruption of storage services or infrastructure,\nsuch as Elasticsearch/Opensearch cluster failures, data corruption events, or significant version upgrade inconsistencies\nthat have caused the search and graph indices to become out of sync with the local database."),(0,a.yg)("p",null,"Some pointers to keep in mind when running this process:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Always test reindexing in a ",(0,a.yg)("strong",{parentName:"li"},"staging environment")," first."),(0,a.yg)("li",{parentName:"ul"},"Consider taking a backup of your Elasticsearch/OpenSearch index before a ",(0,a.yg)("inlineCode",{parentName:"li"},"clean")," restore."),(0,a.yg)("li",{parentName:"ul"},"For very large deployments, use ",(0,a.yg)("inlineCode",{parentName:"li"},"urnBasedPagination")," and limit ",(0,a.yg)("inlineCode",{parentName:"li"},"batchSize")," to avoid overloading your backend."),(0,a.yg)("li",{parentName:"ul"},"Monitor Elasticsearch/OpenSearch logs during the restore for throttling or memory issues.")),(0,a.yg)("h3",{id:"k8-job-vs-api"},"K8 Job vs. API"),(0,a.yg)("h4",{id:"when-to-use-kubernetes-jobs"},"When to Use Kubernetes Jobs"),(0,a.yg)("p",null,"For operations affecting 2,000 or more aspects, it's strongly recommended to use the Kubernetes job approach. This job is\ndesigned for long-running processes and provide several advantages:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Won't time out like API calls"),(0,a.yg)("li",{parentName:"ul"},"Can be monitored through Kubernetes logging"),(0,a.yg)("li",{parentName:"ul"},"Won't consume resources from your primary GMS instances"),(0,a.yg)("li",{parentName:"ul"},"Can be scheduled during off-peak hours to minimize system impact")),(0,a.yg)("h4",{id:"when-to-use-apis"},"When to Use APIs"),(0,a.yg)("p",null,"The RestoreIndices APIs (available through both Rest.li and OpenAPI) is best suited for:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Targeted restores affecting fewer than 2,000 aspects"),(0,a.yg)("li",{parentName:"ul"},"Emergencies where you need to quickly restore critical metadata"),(0,a.yg)("li",{parentName:"ul"},"Testing or validating the restore process before running a full-scale job"),(0,a.yg)("li",{parentName:"ul"},"Scenarios where you don't have direct access to the Kubernetes cluster")),(0,a.yg)("p",null,"Remember that API-based restoration runs within one of your GMS instances and is subject to timeouts, which could lead to\nincomplete restorations for larger installations."),(0,a.yg)("h3",{id:"targeted-restoration-strategies"},"Targeted Restoration Strategies"),(0,a.yg)("p",null,"Being selective about what you restore is crucial for efficiency. Combining these filtering strategies can dramatically\nreduce the restoration scope, saving resources and time."),(0,a.yg)("h4",{id:"entity-type-filtering"},"Entity Type Filtering"),(0,a.yg)("p",null,"Entity Type Filtering: Use the ",(0,a.yg)("inlineCode",{parentName:"p"},"urnLike")," parameter to target specific entity types:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"For datasets: ",(0,a.yg)("inlineCode",{parentName:"li"},"urnLike=urn:li:dataset:%")),(0,a.yg)("li",{parentName:"ul"},"For users: ",(0,a.yg)("inlineCode",{parentName:"li"},"urnLike=urn:li:corpuser:%")),(0,a.yg)("li",{parentName:"ul"},"For dashboards: ",(0,a.yg)("inlineCode",{parentName:"li"},"urnLike=urn:li:dashboard:%"))),(0,a.yg)("h4",{id:"single-entity"},"Single Entity"),(0,a.yg)("p",null,"Single Entity Restoration: When only one entity is affected, provide the specific URN to minimize processing overhead.\nAspect-Based Filtering: Use aspectNames to target only the specific aspects that need restoration:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"For ownership inconsistencies: ",(0,a.yg)("inlineCode",{parentName:"li"},"aspectNames=ownership")),(0,a.yg)("li",{parentName:"ul"},"For tag issues: ",(0,a.yg)("inlineCode",{parentName:"li"},"aspectNames=globalTags"))),(0,a.yg)("h4",{id:"time-based"},"Time-Based"),(0,a.yg)("p",null,"Time-Based Recovery: If you know when the inconsistency began, use time-based filtering:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"gePitEpochMs={timestamp} to process only records created after the incident"),(0,a.yg)("li",{parentName:"ul"},"lePitEpochMs={timestamp} to limit processing to records before a certain time")),(0,a.yg)("h3",{id:"parallel-processing-strategies"},"Parallel Processing Strategies"),(0,a.yg)("p",null,"To optimize restoration speed while managing system load:"),(0,a.yg)("h4",{id:"multiple-parallel-jobs"},"Multiple Parallel Jobs"),(0,a.yg)("p",null,"Run several restoreIndices processes simultaneously by:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Work on non-overlapping sets of aspects or entities",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Dividing work by entity type (one job for datasets, another for users, etc.)"),(0,a.yg)("li",{parentName:"ul"},"Splitting aspects among different jobs (one for ownership aspects, another for lineage, etc.)"),(0,a.yg)("li",{parentName:"ul"},"Partitioning large entity types by prefix or time range"))),(0,a.yg)("li",{parentName:"ul"},"Have staggered start times to prevent initial resource contention"),(0,a.yg)("li",{parentName:"ul"},"Monitor system metrics closely during concurrent restoration to ensure you're not overloading your infrastructure.")),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},"Avoid Conflicts: Ensure that concurrent jobs:"),(0,a.yg)("p",{parentName:"admonition"},"Never specify the --clean argument in concurrent jobs")),(0,a.yg)("h3",{id:"temporary-workload-reduction"},"Temporary Workload Reduction"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Pause scheduled ingestion jobs during restoration"),(0,a.yg)("li",{parentName:"ul"},"Temporarily disable or reduce frequency of the datahub-gc job to prevent conflicting deletes"),(0,a.yg)("li",{parentName:"ul"},"Consider pausing automated workflows or integrations that generate metadata events")),(0,a.yg)("h3",{id:"infrastructure-tuning"},"Infrastructure Tuning"),(0,a.yg)("p",null,"Implementing these expanded best practices should help ensure a smoother, more efficient restoration process while\nminimizing impact on your DataHub environment."),(0,a.yg)("p",null,"This operation can be I/O intensive from the read-side from SQL and on the Elasticsearch write side. If you're able to leverage\nprovisioned I/O or throughput, you might want to monitor your infrastructure for a possible bottleneck."),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"\ud83d\udca1 ",(0,a.yg)("strong",{parentName:"p"},"Performance Tip"),": For bulk loading scenarios during initial deployment or major data migrations, consider using ",(0,a.yg)("a",{parentName:"p",href:"/docs/how/load-indices"},"LoadIndices")," instead, which is optimized for high throughput rather than precise event replay.")),(0,a.yg)("h4",{id:"elasticsearchopensearch-optimization"},"Elasticsearch/Opensearch Optimization"),(0,a.yg)("p",null,"To improve write performance during restoration:"),(0,a.yg)("h5",{id:"refresh-interval-adjustment"},"Refresh Interval Adjustment:"),(0,a.yg)("p",null,"Temporarily increase the refresh_interval setting from the default (typically 1s) to something like 30s or 60s.\nRun the system update job with the following environment variable ",(0,a.yg)("inlineCode",{parentName:"p"},"ELASTICSEARCH_INDEX_BUILDER_REFRESH_INTERVAL_SECONDS=60")),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},"Remember to reset this after restoration completes!")),(0,a.yg)("h5",{id:"bulk-processing-improvements"},"Bulk Processing Improvements:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Adjust the Elasticsearch batching parameters to optimize bulk request size (try values between 2000-5000)",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Run your GMS or ",(0,a.yg)("inlineCode",{parentName:"li"},"mae-consumer")," with environment variables",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"ES_BULK_REQUESTS_LIMIT=3000")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"ES_BULK_FLUSH_PERIOD=60")))))),(0,a.yg)("li",{parentName:"ul"},"Configure ",(0,a.yg)("inlineCode",{parentName:"li"},"batchDelayMs")," on restoreIndices to add breathing room between batches if your cluster is struggling")),(0,a.yg)("h5",{id:"shard-management"},"Shard Management:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Ensure your indices have an appropriate number of shards for your cluster size."),(0,a.yg)("li",{parentName:"ul"},"Consider temporarily adding nodes to your search cluster during massive restorations.")),(0,a.yg)("h4",{id:"sqlprimary-storage"},"SQL/Primary Storage"),(0,a.yg)("p",null,"Consider using a read replica as the source of the job's data. If you configure a read-only replica\nyou must also provide the parameter ",(0,a.yg)("inlineCode",{parentName:"p"},"createDefaultAspects=false"),"."),(0,a.yg)("h4",{id:"kafka--consumers"},"Kafka & Consumers"),(0,a.yg)("h5",{id:"partition-strategy"},"Partition Strategy:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Verify that the Kafka Metadata Change Log (MCL) topic have enough partitions to allow for parallel processing."),(0,a.yg)("li",{parentName:"ul"},"Recommended: At least 10-20 partitions for the MCL topic in production environments.")),(0,a.yg)("h5",{id:"consumer-scaling"},"Consumer Scaling:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Temporarily increase the number of ",(0,a.yg)("inlineCode",{parentName:"li"},"mae-consumer")," pods to process the higher event volume."),(0,a.yg)("li",{parentName:"ul"},"Scale GMS instances if they're handling consumer duties.")),(0,a.yg)("h5",{id:"monitoring"},"Monitoring:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Watch consumer lag metrics closely during restoration."),(0,a.yg)("li",{parentName:"ul"},"Be prepared to adjust scaling or batch parameters if consumers fall behind.")))}y.isMDXComponent=!0}}]);