"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[20794],{27068:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>m,default:()=>h,frontMatter:()=>d,metadata:()=>p,toc:()=>c});t(96540);var a=t(15680),i=t(53720),l=t(5400);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})),e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}const d={sidebar_position:25,title:"SchemaField",slug:"/generated/metamodel/entities/schemafield",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/schemaField.md"},m="SchemaField",p={unversionedId:"docs/generated/metamodel/entities/schemaField",id:"docs/generated/metamodel/entities/schemaField",title:"SchemaField",description:"The schemaField entity represents an individual column or field within a dataset's schema. While schema information is typically ingested as part of a dataset's schemaMetadata aspect, schemaField entities exist as first-class entities to enable direct attachment of metadata like tags, glossary terms, documentation, and structured properties at the field level.",source:"@site/genDocs/docs/generated/metamodel/entities/schemaField.md",sourceDirName:"docs/generated/metamodel/entities",slug:"/generated/metamodel/entities/schemafield",permalink:"/docs/generated/metamodel/entities/schemafield",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/schemaField.md",tags:[],version:"current",sidebarPosition:25,frontMatter:{sidebar_position:25,title:"SchemaField",slug:"/generated/metamodel/entities/schemafield",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/schemaField.md"},sidebar:"overviewSidebar",previous:{title:"Test",permalink:"/docs/generated/metamodel/entities/test"},next:{title:"VersionSet",permalink:"/docs/generated/metamodel/entities/versionset"}},u={},c=[{value:"Identity",id:"identity",level:2},{value:"Examples",id:"examples",level:3},{value:"Important Capabilities",id:"important-capabilities",level:2},{value:"Field Information (schemafieldInfo)",id:"field-information-schemafieldinfo",level:3},{value:"Documentation",id:"documentation",level:3},{value:"Tags",id:"tags",level:3},{value:"Glossary Terms",id:"glossary-terms",level:3},{value:"Business Attributes",id:"business-attributes",level:3},{value:"Structured Properties",id:"structured-properties",level:3},{value:"Field Aliases (schemaFieldAliases)",id:"field-aliases-schemafieldaliases",level:3},{value:"Deprecation",id:"deprecation",level:3},{value:"Logical Parent",id:"logical-parent",level:3},{value:"Forms",id:"forms",level:3},{value:"Status",id:"status",level:3},{value:"Test Results",id:"test-results",level:3},{value:"SubTypes",id:"subtypes",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Querying a Schema Field via REST API",id:"querying-a-schema-field-via-rest-api",level:3},{value:"Working with Fine-Grained Lineage",id:"working-with-fine-grained-lineage",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"Relationship with Datasets",id:"relationship-with-datasets",level:3},{value:"Fine-Grained Lineage",id:"fine-grained-lineage",level:3},{value:"GraphQL API",id:"graphql-api",level:3},{value:"Search and Discovery",id:"search-and-discovery",level:3},{value:"Notable Exceptions",id:"notable-exceptions",level:2},{value:"Dual Access Patterns",id:"dual-access-patterns",level:3},{value:"Feature Flag Dependency",id:"feature-flag-dependency",level:3},{value:"Field Path Encoding",id:"field-path-encoding",level:3},{value:"V1 vs V2 Field Paths",id:"v1-vs-v2-field-paths",level:3},{value:"Technical Reference Guide",id:"technical-reference-guide",level:2},{value:"Reading the Field Tables",id:"reading-the-field-tables",level:3},{value:"Aspects",id:"aspects",level:3},{value:"schemaFieldKey",id:"schemafieldkey",level:4},{value:"schemafieldInfo",id:"schemafieldinfo",level:4},{value:"structuredProperties",id:"structuredproperties",level:4},{value:"forms",id:"forms-1",level:4},{value:"businessAttributes",id:"businessattributes",level:4},{value:"status",id:"status-1",level:4},{value:"schemaFieldAliases",id:"schemafieldaliases",level:4},{value:"documentation",id:"documentation-1",level:4},{value:"testResults",id:"testresults",level:4},{value:"deprecation",id:"deprecation-1",level:4},{value:"subTypes",id:"subtypes-1",level:4},{value:"logicalParent",id:"logicalparent",level:4},{value:"globalTags",id:"globaltags",level:4},{value:"glossaryTerms",id:"glossaryterms",level:4},{value:"Common Types",id:"common-types",level:3},{value:"AuditStamp",id:"auditstamp",level:4},{value:"Edge",id:"edge",level:4},{value:"FormAssociation",id:"formassociation",level:4},{value:"TestResult",id:"testresult",level:4},{value:"Relationships",id:"relationships",level:3},{value:"Self",id:"self",level:4},{value:"Outgoing",id:"outgoing",level:4},{value:"Incoming",id:"incoming",level:4},{value:"Global Metadata Model",id:"global-metadata-model",level:3}],g={toc:c},y="wrapper";function h(e){var{components:n}=e,t=o(e,["components"]);return(0,a.yg)(y,s(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},a=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})))),a.forEach((function(n){r(e,n,t[n])}))}return e}({},g,t),{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"schemafield"},"SchemaField"),(0,a.yg)("p",null,"The schemaField entity represents an individual column or field within a dataset's schema. While schema information is typically ingested as part of a dataset's ",(0,a.yg)("inlineCode",{parentName:"p"},"schemaMetadata")," aspect, schemaField entities exist as first-class entities to enable direct attachment of metadata like tags, glossary terms, documentation, and structured properties at the field level."),(0,a.yg)("p",null,"SchemaField entities are automatically created by DataHub when datasets with schemas are ingested. They serve as the link between dataset-level metadata and column-level metadata, enabling fine-grained data governance and lineage tracking at the field level."),(0,a.yg)("h2",{id:"identity"},"Identity"),(0,a.yg)("p",null,"SchemaField entities are uniquely identified by two components:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Parent URN"),": The URN of the dataset that contains this field"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Field Path"),": The path identifying the field within the schema (e.g., ",(0,a.yg)("inlineCode",{parentName:"li"},"user_id"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"address.zipcode")," for nested fields)")),(0,a.yg)("p",null,"The URN structure for a schemaField follows this pattern:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"urn:li:schemaField:(<parent_dataset_urn>,<encoded_field_path>)\n")),(0,a.yg)("h3",{id:"examples"},"Examples"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Simple field:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,public.users,PROD),user_id)\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Nested field:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:bigquery,project.dataset.table,PROD),address.zipcode)\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Field with special characters (URL encoded):")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:snowflake,db.schema.table,PROD),first%20name)\n")),(0,a.yg)("p",null,"Note that the field path component may be URL-encoded if it contains special characters. The v1 field path uses ",(0,a.yg)("inlineCode",{parentName:"p"},".")," notation for nested structures, while v2 field paths include type information (e.g., ",(0,a.yg)("inlineCode",{parentName:"p"},"[version=2.0].[type=struct].address.[type=string].zipcode"),")."),(0,a.yg)("h2",{id:"important-capabilities"},"Important Capabilities"),(0,a.yg)("h3",{id:"field-information-schemafieldinfo"},"Field Information (schemafieldInfo)"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"schemafieldInfo")," aspect contains basic identifying information about the schema field:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"name"),": The display name of the field"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"schemaFieldAliases"),": Alternative URNs for this field, used to store field path variations")),(0,a.yg)("p",null,"This aspect is primarily used internally by DataHub to support field path variations and search functionality."),(0,a.yg)("h3",{id:"documentation"},"Documentation"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"documentation")," aspect stores field-level documentation from multiple sources. Unlike the dataset-level description pattern which uses separate aspects (",(0,a.yg)("inlineCode",{parentName:"p"},"datasetProperties")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"editableDatasetProperties"),"), field-level documentation uses a single unified aspect that can contain multiple documentation entries from different sources."),(0,a.yg)("p",null,"Each documentation entry includes:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"The documentation text/description"),(0,a.yg)("li",{parentName:"ul"},"The source system or attribution information")),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add or update documentation for a schema field"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/schemafield_add_documentation.py\nimport time\n\nimport datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\ngms_endpoint = "http://localhost:8080"\nemitter = DatahubRestEmitter(gms_server=gms_endpoint, extra_headers={})\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = builder.make_dataset_urn(\n    platform="bigquery", name="project.dataset.transactions", env="PROD"\n)\n\nfield_urn = builder.make_schema_field_urn(\n    parent_urn=dataset_urn, field_path="transaction_amount"\n)\n\ncurrent_docs = graph.get_aspect(\n    entity_urn=field_urn, aspect_type=models.DocumentationClass\n)\n\ndocumentation_text = (\n    "The monetary value of the transaction in USD. "\n    "This field is calculated from the base currency amount "\n    "using the exchange rate at transaction time."\n)\n\nattribution = models.MetadataAttributionClass(\n    time=int(time.time() * 1000),\n    actor=builder.make_user_urn("data_steward"),\n    source=builder.make_data_platform_urn("manual"),\n)\n\nnew_doc = models.DocumentationAssociationClass(\n    documentation=documentation_text,\n    attribution=attribution,\n)\n\nif current_docs and current_docs.documentations:\n    source_exists = False\n    for i, doc in enumerate(current_docs.documentations):\n        if doc.attribution and doc.attribution.source == attribution.source:\n            current_docs.documentations[i] = new_doc\n            source_exists = True\n            break\n    if not source_exists:\n        current_docs.documentations.append(new_doc)\nelse:\n    current_docs = models.DocumentationClass(documentations=[new_doc])\n\nemitter.emit(\n    MetadataChangeProposalWrapper(\n        entityUrn=field_urn,\n        aspect=current_docs,\n    )\n)\n\n'))),(0,a.yg)("h3",{id:"tags"},"Tags"),(0,a.yg)("p",null,"Tags can be added directly to schema fields using the ",(0,a.yg)("inlineCode",{parentName:"p"},"globalTags")," aspect. This is separate from tags added at the dataset level, allowing for fine-grained classification of individual columns."),(0,a.yg)("p",null,"Tags on fields are commonly used to:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Mark sensitive data (PII, PHI, confidential)"),(0,a.yg)("li",{parentName:"ul"},"Indicate data quality issues"),(0,a.yg)("li",{parentName:"ul"},"Flag deprecated fields"),(0,a.yg)("li",{parentName:"ul"},"Classify data by security level or compliance requirements")),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add a tag to a schema field"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/schemafield_add_tag.py\nimport datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\ngms_endpoint = "http://localhost:8080"\nemitter = DatahubRestEmitter(gms_server=gms_endpoint, extra_headers={})\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = builder.make_dataset_urn(\n    platform="postgres", name="public.users", env="PROD"\n)\n\nfield_urn = builder.make_schema_field_urn(\n    parent_urn=dataset_urn, field_path="email_address"\n)\n\ncurrent_tags = graph.get_aspect(\n    entity_urn=field_urn, aspect_type=models.GlobalTagsClass\n)\n\ntag_to_add = builder.make_tag_urn("PII")\ntag_association = models.TagAssociationClass(tag=tag_to_add)\n\nif current_tags and current_tags.tags:\n    if tag_to_add not in [tag.tag for tag in current_tags.tags]:\n        current_tags.tags.append(tag_association)\nelse:\n    current_tags = models.GlobalTagsClass(tags=[tag_association])\n\nemitter.emit(\n    MetadataChangeProposalWrapper(\n        entityUrn=field_urn,\n        aspect=current_tags,\n    )\n)\n\n'))),(0,a.yg)("h3",{id:"glossary-terms"},"Glossary Terms"),(0,a.yg)("p",null,"Glossary terms can be attached to schema fields via the ",(0,a.yg)("inlineCode",{parentName:"p"},"glossaryTerms")," aspect, enabling semantic annotation at the column level. This helps users understand the business meaning of individual fields."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add a glossary term to a schema field"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/schemafield_add_term.py\nimport datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\ngms_endpoint = "http://localhost:8080"\nemitter = DatahubRestEmitter(gms_server=gms_endpoint, extra_headers={})\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = builder.make_dataset_urn(\n    platform="snowflake", name="analytics.public.orders", env="PROD"\n)\n\nfield_urn = builder.make_schema_field_urn(\n    parent_urn=dataset_urn, field_path="customer_id"\n)\n\ncurrent_terms = graph.get_aspect(\n    entity_urn=field_urn, aspect_type=models.GlossaryTermsClass\n)\n\nterm_to_add = builder.make_term_urn("CustomerIdentifier")\nterm_association = models.GlossaryTermAssociationClass(urn=term_to_add)\n\nif current_terms and current_terms.terms:\n    if term_to_add not in [term.urn for term in current_terms.terms]:\n        current_terms.terms.append(term_association)\nelse:\n    current_terms = models.GlossaryTermsClass(\n        terms=[term_association],\n        auditStamp=models.AuditStampClass(time=0, actor="urn:li:corpuser:datahub"),\n    )\n\nemitter.emit(\n    MetadataChangeProposalWrapper(\n        entityUrn=field_urn,\n        aspect=current_terms,\n    )\n)\n\n'))),(0,a.yg)("h3",{id:"business-attributes"},"Business Attributes"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"businessAttributes")," aspect allows association of business attribute definitions with schema fields. Business attributes provide a way to attach enterprise-specific metadata dimensions (like data classification, retention policies, or business rules) directly to fields."),(0,a.yg)("p",null,"This is particularly useful for organizations that need to track custom governance metadata at the field level that isn't covered by standard aspects."),(0,a.yg)("h3",{id:"structured-properties"},"Structured Properties"),(0,a.yg)("p",null,"Schema fields support structured properties via the ",(0,a.yg)("inlineCode",{parentName:"p"},"structuredProperties")," aspect, allowing organizations to extend the metadata model with custom typed properties. This is useful for tracking field-level metadata like:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Data quality scores"),(0,a.yg)("li",{parentName:"ul"},"Business criticality ratings"),(0,a.yg)("li",{parentName:"ul"},"Custom classification schemes"),(0,a.yg)("li",{parentName:"ul"},"Regulatory compliance markers")),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add structured properties to a schema field"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/schemafield_add_structured_properties.py\nimport time\n\nimport datahub.emitter.mce_builder as builder\nimport datahub.metadata.schema_classes as models\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\ngms_endpoint = "http://localhost:8080"\nemitter = DatahubRestEmitter(gms_server=gms_endpoint, extra_headers={})\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = builder.make_dataset_urn(\n    platform="hive", name="logging.events.clickstream", env="PROD"\n)\n\nfield_urn = builder.make_schema_field_urn(parent_urn=dataset_urn, field_path="user_id")\n\ncurrent_properties = graph.get_aspect(\n    entity_urn=field_urn, aspect_type=models.StructuredPropertiesClass\n)\n\nproperty_urn = "urn:li:structuredProperty:io.acryl.dataQuality.score"\nproperty_value = "0.95"\n\nnew_assignment = models.StructuredPropertyValueAssignmentClass(\n    propertyUrn=property_urn,\n    values=[property_value],\n    created=models.AuditStampClass(\n        time=int(time.time() * 1000), actor=builder.make_user_urn("datahub")\n    ),\n)\n\nif current_properties and current_properties.properties:\n    property_exists = False\n    for i, prop in enumerate(current_properties.properties):\n        if prop.propertyUrn == property_urn:\n            current_properties.properties[i] = new_assignment\n            property_exists = True\n            break\n    if not property_exists:\n        current_properties.properties.append(new_assignment)\nelse:\n    current_properties = models.StructuredPropertiesClass(properties=[new_assignment])\n\nemitter.emit(\n    MetadataChangeProposalWrapper(\n        entityUrn=field_urn,\n        aspect=current_properties,\n    )\n)\n\n'))),(0,a.yg)("h3",{id:"field-aliases-schemafieldaliases"},"Field Aliases (schemaFieldAliases)"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"schemaFieldAliases")," aspect stores alternative URNs for a schema field. This is useful when:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Field paths change due to schema evolution"),(0,a.yg)("li",{parentName:"ul"},"Multiple field path formats are used (v1 vs v2)"),(0,a.yg)("li",{parentName:"ul"},"Cross-platform field references need to be maintained")),(0,a.yg)("h3",{id:"deprecation"},"Deprecation"),(0,a.yg)("p",null,"Fields can be marked as deprecated using the ",(0,a.yg)("inlineCode",{parentName:"p"},"deprecation")," aspect, indicating they should not be used in new applications or analyses. The deprecation aspect includes:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Deprecation timestamp"),(0,a.yg)("li",{parentName:"ul"},"Optional note explaining the deprecation"),(0,a.yg)("li",{parentName:"ul"},"Optional actor who deprecated the field")),(0,a.yg)("h3",{id:"logical-parent"},"Logical Parent"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"logicalParent")," aspect can associate a schema field with a logical parent entity (like a container or domain), enabling organizational hierarchies that differ from the physical dataset structure."),(0,a.yg)("h3",{id:"forms"},"Forms"),(0,a.yg)("p",null,"Forms can be attached to schema fields via the ",(0,a.yg)("inlineCode",{parentName:"p"},"forms")," aspect, enabling structured data collection and validation at the field level. This is useful for capturing field-level certifications, approvals, or additional metadata."),(0,a.yg)("h3",{id:"status"},"Status"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"status")," aspect indicates whether a schema field is active or has been soft-deleted."),(0,a.yg)("h3",{id:"test-results"},"Test Results"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"testResults")," aspect can store results of data quality tests run on specific fields, linking test outcomes directly to the columns they validate."),(0,a.yg)("h3",{id:"subtypes"},"SubTypes"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"subTypes")," aspect allows categorization of schema fields beyond their data type, enabling custom classification schemes."),(0,a.yg)("h2",{id:"code-examples"},"Code Examples"),(0,a.yg)("h3",{id:"querying-a-schema-field-via-rest-api"},"Querying a Schema Field via REST API"),(0,a.yg)("p",null,"The standard GET API can be used to retrieve schema field entities and their aspects:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Fetch a schemaField entity"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/schemafield_query_entity.py\nfrom typing import Any, cast\n\nimport datahub.emitter.mce_builder as builder\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\ngms_endpoint = "http://localhost:8080"\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = builder.make_dataset_urn(\n    platform="postgres", name="public.customers", env="PROD"\n)\n\nfield_urn = builder.make_schema_field_urn(\n    parent_urn=dataset_urn, field_path="email_address"\n)\n\nentity = graph.get_entity_semityped(entity_urn=field_urn)\n\nif entity:\n    print(f"Schema Field URN: {field_urn}")\n    print(f"Entity Type: {entity.get(\'entityType\')}")\n\n    aspects = cast(dict[str, Any], entity.get("aspects", {}))\n\n    if "globalTags" in aspects:\n        tags = aspects["globalTags"]["tags"]\n        print(f"Tags: {[tag[\'tag\'] for tag in tags]}")\n\n    if "glossaryTerms" in aspects:\n        terms = aspects["glossaryTerms"]["terms"]\n        print(f"Glossary Terms: {[term[\'urn\'] for term in terms]}")\n\n    if "documentation" in aspects:\n        docs = aspects["documentation"]["documentations"]\n        for doc in docs:\n            print(f"Documentation: {doc[\'documentation\'][:100]}...")\n\n    if "structuredProperties" in aspects:\n        props = aspects["structuredProperties"]["properties"]\n        for prop in props:\n            print(f"Property {prop[\'propertyUrn\']}: {prop[\'values\']}")\nelse:\n    print(f"Schema field {field_urn} not found")\n\n')),(0,a.yg)("p",null,"Example API call:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"curl 'http://localhost:8080/entities/urn%3Ali%3AschemaField%3A(urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Apostgres%2Cpublic.users%2CPROD)%2Cuser_id)'\n")),(0,a.yg)("p",null,"This returns all aspects associated with the schema field, including tags, terms, documentation, and structured properties.")),(0,a.yg)("h3",{id:"working-with-fine-grained-lineage"},"Working with Fine-Grained Lineage"),(0,a.yg)("p",null,"Schema fields are central to fine-grained (column-level) lineage. When defining lineage between datasets, you can specify which fields flow from upstream to downstream:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Example lineage query showing field-level relationships"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"# Find upstream fields of a specific schema field\ncurl 'http://localhost:8080/relationships?direction=OUTGOING&urn=urn%3Ali%3AschemaField%3A(urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Apostgres%2Cpublic.orders%2CPROD)%2Cuser_id)&types=DownstreamOf'\n")),(0,a.yg)("p",null,"This shows which upstream fields contribute to this field's values, enabling impact analysis at the column level.")),(0,a.yg)("h2",{id:"integration-points"},"Integration Points"),(0,a.yg)("h3",{id:"relationship-with-datasets"},"Relationship with Datasets"),(0,a.yg)("p",null,"Schema fields have a parent-child relationship with datasets. The dataset's ",(0,a.yg)("inlineCode",{parentName:"p"},"schemaMetadata")," aspect defines the structure and metadata of fields, while individual schemaField entities allow direct metadata attachment at the field level."),(0,a.yg)("p",null,"Key integration points:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Fields are referenced in ",(0,a.yg)("inlineCode",{parentName:"li"},"schemaMetadata")," and ",(0,a.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata")," aspects of datasets"),(0,a.yg)("li",{parentName:"ul"},"Field-level tags and terms can be set via dataset aspects (",(0,a.yg)("inlineCode",{parentName:"li"},"schemaMetadata"),") or directly on schemaField entities"),(0,a.yg)("li",{parentName:"ul"},"The UI typically modifies ",(0,a.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata")," on the dataset, while ingestion connectors set ",(0,a.yg)("inlineCode",{parentName:"li"},"schemaMetadata"))),(0,a.yg)("h3",{id:"fine-grained-lineage"},"Fine-Grained Lineage"),(0,a.yg)("p",null,"Schema fields are essential for column-level lineage:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"DataJob entities"),": The ",(0,a.yg)("inlineCode",{parentName:"li"},"dataJobInputOutput")," aspect can specify ",(0,a.yg)("inlineCode",{parentName:"li"},"inputDatasetFields")," and ",(0,a.yg)("inlineCode",{parentName:"li"},"outputDatasetFields")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Dataset lineage"),": The ",(0,a.yg)("inlineCode",{parentName:"li"},"upstreamLineage")," aspect on datasets can include ",(0,a.yg)("inlineCode",{parentName:"li"},"fineGrainedLineages")," that map specific fields"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Lineage queries"),": Field-level lineage appears as relationships between schemaField entities")),(0,a.yg)("h3",{id:"graphql-api"},"GraphQL API"),(0,a.yg)("p",null,"The GraphQL API exposes schema field entities as first-class entities with the ",(0,a.yg)("inlineCode",{parentName:"p"},"SchemaFieldEntity")," type. Key resolvers include:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Fetching field metadata (tags, terms, documentation)"),(0,a.yg)("li",{parentName:"ul"},"Querying field lineage relationships"),(0,a.yg)("li",{parentName:"ul"},"Searching for fields across datasets")),(0,a.yg)("p",null,"Note: Field fetching via GraphQL is controlled by the ",(0,a.yg)("inlineCode",{parentName:"p"},"schemaFieldEntityFetchEnabled")," feature flag. When disabled, schema field metadata is accessed only through the parent dataset's schema aspects."),(0,a.yg)("h3",{id:"search-and-discovery"},"Search and Discovery"),(0,a.yg)("p",null,"Schema fields are indexed for search, enabling users to:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Find datasets by column names"),(0,a.yg)("li",{parentName:"ul"},"Search for fields with specific tags or terms"),(0,a.yg)("li",{parentName:"ul"},"Discover fields by description content"),(0,a.yg)("li",{parentName:"ul"},"Filter by field-level classifications")),(0,a.yg)("h2",{id:"notable-exceptions"},"Notable Exceptions"),(0,a.yg)("h3",{id:"dual-access-patterns"},"Dual Access Patterns"),(0,a.yg)("p",null,"Schema field metadata can be accessed and modified in two ways:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Via the parent dataset"),": Using ",(0,a.yg)("inlineCode",{parentName:"li"},"schemaMetadata")," or ",(0,a.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata")," aspects on the dataset"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Directly on schemaField entities"),": Using aspects like ",(0,a.yg)("inlineCode",{parentName:"li"},"globalTags"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"glossaryTerms"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"documentation")," on the schemaField URN")),(0,a.yg)("p",null,"Best practices:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Ingestion connectors should use dataset-level aspects (",(0,a.yg)("inlineCode",{parentName:"li"},"schemaMetadata"),")"),(0,a.yg)("li",{parentName:"ul"},"UI edits typically use dataset-level aspects (",(0,a.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata"),")"),(0,a.yg)("li",{parentName:"ul"},"Direct schemaField entity updates are useful for programmatic bulk operations or when working with field-level lineage")),(0,a.yg)("h3",{id:"feature-flag-dependency"},"Feature Flag Dependency"),(0,a.yg)("p",null,"The ability to fetch schemaField entities via GraphQL depends on the ",(0,a.yg)("inlineCode",{parentName:"p"},"schemaFieldEntityFetchEnabled")," feature flag. When disabled:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Schema field entities are not directly queryable"),(0,a.yg)("li",{parentName:"ul"},"Field metadata must be accessed through parent datasets"),(0,a.yg)("li",{parentName:"ul"},"Field-level operations may have limited functionality")),(0,a.yg)("p",null,"This flag exists for performance reasons, as materializing individual field entities can be expensive for datasets with hundreds of columns."),(0,a.yg)("h3",{id:"field-path-encoding"},"Field Path Encoding"),(0,a.yg)("p",null,"Field paths in schemaField URNs must be URL-encoded if they contain special characters (spaces, special symbols, etc.). Always use the ",(0,a.yg)("inlineCode",{parentName:"p"},"make_schema_field_urn")," utility function from ",(0,a.yg)("inlineCode",{parentName:"p"},"datahub.emitter.mce_builder")," to construct URNs correctly:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'from datahub.emitter.mce_builder import make_schema_field_urn\n\n# Automatically handles encoding\nfield_urn = make_schema_field_urn(\n    parent_urn="urn:li:dataset:(urn:li:dataPlatform:snowflake,db.schema.table,PROD)",\n    field_path="first name"  # Will be encoded as "first%20name"\n)\n')),(0,a.yg)("h3",{id:"v1-vs-v2-field-paths"},"V1 vs V2 Field Paths"),(0,a.yg)("p",null,"DataHub supports two field path formats:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"V1"),": Simple dot notation (e.g., ",(0,a.yg)("inlineCode",{parentName:"li"},"address.zipcode"),")"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"V2"),": Type-aware notation (e.g., ",(0,a.yg)("inlineCode",{parentName:"li"},"[version=2.0].[type=struct].address.[type=string].zipcode"),")")),(0,a.yg)("p",null,"V2 field paths are required for:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Union types where field names alone are ambiguous"),(0,a.yg)("li",{parentName:"ul"},"Complex nested structures with type information"),(0,a.yg)("li",{parentName:"ul"},"Precise field path disambiguation")),(0,a.yg)("p",null,"Most simple schemas can use v1 field paths. Use v2 when dealing with complex types or when ingestion connectors generate them."),(0,a.yg)("h2",{id:"technical-reference-guide"},"Technical Reference Guide"),(0,a.yg)("p",null,"The sections above provide an overview of how to use this entity. The following sections provide detailed technical information about how metadata is stored and represented in DataHub."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Aspects")," are the individual pieces of metadata that can be attached to an entity. Each aspect contains specific information (like ownership, tags, or properties) and is stored as a separate record, allowing for flexible and incremental metadata updates."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Relationships")," show how this entity connects to other entities in the metadata graph. These connections are derived from the fields within each aspect and form the foundation of DataHub's knowledge graph."),(0,a.yg)("h3",{id:"reading-the-field-tables"},"Reading the Field Tables"),(0,a.yg)("p",null,"Each aspect's field table includes an ",(0,a.yg)("strong",{parentName:"p"},"Annotations")," column that provides additional metadata about how fields are used:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"\u26a0\ufe0f Deprecated"),": This field is deprecated and may be removed in a future version. Check the description for the recommended alternative"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Searchable"),": This field is indexed and can be searched in DataHub's search interface"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Searchable (fieldname)"),": When the field name in parentheses is shown, it indicates the field is indexed under a different name in the search index. For example, ",(0,a.yg)("inlineCode",{parentName:"li"},"dashboardTool")," is indexed as ",(0,a.yg)("inlineCode",{parentName:"li"},"tool")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"\u2192 RelationshipName"),": This field creates a relationship to another entity. The arrow indicates this field contains a reference (URN) to another entity, and the name indicates the type of relationship (e.g., ",(0,a.yg)("inlineCode",{parentName:"li"},"\u2192 Contains"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"\u2192 OwnedBy"),")")),(0,a.yg)("p",null,"Fields with complex types (like ",(0,a.yg)("inlineCode",{parentName:"p"},"Edge"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"AuditStamp"),") link to their definitions in the ",(0,a.yg)("a",{parentName:"p",href:"#common-types"},"Common Types")," section below."),(0,a.yg)("h3",{id:"aspects"},"Aspects"),(0,a.yg)("h4",{id:"schemafieldkey"},"schemaFieldKey"),(0,a.yg)("p",null,"Key for a SchemaField"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"parent"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Parent associated with the schema field"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"fieldPath"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"fieldPath identifying the schema field"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "schemaFieldKey"\n  },\n  "name": "SchemaFieldKey",\n  "namespace": "com.linkedin.metadata.key",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "URN"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "parent",\n      "doc": "Parent associated with the schema field"\n    },\n    {\n      "Searchable": {\n        "fieldType": "KEYWORD"\n      },\n      "type": "string",\n      "name": "fieldPath",\n      "doc": "fieldPath identifying the schema field"\n    }\n  ],\n  "doc": "Key for a SchemaField"\n}\n')))),(0,a.yg)("h4",{id:"schemafieldinfo"},"schemafieldInfo"),(0,a.yg)("p",null,"None"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"name"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"schemaFieldAliases"),(0,a.yg)("td",{parentName:"tr",align:null},"string[]"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Used to store field path variations for the schemaField urn."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "schemafieldInfo"\n  },\n  "name": "SchemaFieldInfo",\n  "namespace": "com.linkedin.schemafield",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldNameAliases": [\n          "_entityName"\n        ],\n        "fieldType": "KEYWORD",\n        "searchLabel": "entityName",\n        "searchTier": 1\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "name",\n      "default": null\n    },\n    {\n      "Searchable": {\n        "/*": {\n          "fieldType": "URN",\n          "queryByDefault": true\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": "string"\n        }\n      ],\n      "name": "schemaFieldAliases",\n      "default": null,\n      "doc": "Used to store field path variations for the schemaField urn."\n    }\n  ]\n}\n')))),(0,a.yg)("h4",{id:"structuredproperties"},"structuredProperties"),(0,a.yg)("p",null,"Properties about an entity governed by StructuredPropertyDefinition"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"properties"),(0,a.yg)("td",{parentName:"tr",align:null},"StructuredPropertyValueAssignment[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Custom property bag."),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "structuredProperties"\n  },\n  "name": "StructuredProperties",\n  "namespace": "com.linkedin.structured",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "StructuredPropertyValueAssignment",\n          "namespace": "com.linkedin.structured",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "propertyUrn",\n              "doc": "The property that is being assigned a value."\n            },\n            {\n              "type": {\n                "type": "array",\n                "items": [\n                  "string",\n                  "double"\n                ]\n              },\n              "name": "values",\n              "doc": "The value assigned to the property."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "AuditStamp",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "impersonator",\n                      "default": null,\n                      "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "message",\n                      "default": null,\n                      "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                    }\n                  ],\n                  "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n                }\n              ],\n              "name": "created",\n              "default": null,\n              "doc": "Audit stamp containing who created this relationship edge and when"\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "lastModified",\n              "default": null,\n              "doc": "Audit stamp containing who last modified this relationship edge and when"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "structuredPropertyAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "structuredPropertyAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "structuredPropertyAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ]\n        }\n      },\n      "name": "properties",\n      "doc": "Custom property bag."\n    }\n  ],\n  "doc": "Properties about an entity governed by StructuredPropertyDefinition"\n}\n')))),(0,a.yg)("h4",{id:"forms-1"},"forms"),(0,a.yg)("p",null,"Forms that are assigned to this entity to be filled out"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"incompleteForms"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#formassociation"},"FormAssociation"),"[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"All incomplete forms assigned to the entity."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"completedForms"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#formassociation"},"FormAssociation"),"[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"All complete forms assigned to the entity."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"verifications"),(0,a.yg)("td",{parentName:"tr",align:null},"FormVerificationAssociation[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Verifications that have been applied to the entity via completed forms."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "forms"\n  },\n  "name": "Forms",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "/*/completedPrompts/*/id": {\n          "fieldName": "incompleteFormsCompletedPromptIds",\n          "fieldType": "KEYWORD",\n          "queryByDefault": false\n        },\n        "/*/completedPrompts/*/lastModified/time": {\n          "fieldName": "incompleteFormsCompletedPromptResponseTimes",\n          "fieldType": "DATETIME",\n          "queryByDefault": false\n        },\n        "/*/incompletePrompts/*/id": {\n          "fieldName": "incompleteFormsIncompletePromptIds",\n          "fieldType": "KEYWORD",\n          "queryByDefault": false\n        },\n        "/*/urn": {\n          "fieldName": "incompleteForms",\n          "fieldType": "URN",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "FormAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "urn",\n              "doc": "Urn of the applied form"\n            },\n            {\n              "type": {\n                "type": "array",\n                "items": {\n                  "type": "record",\n                  "name": "FormPromptAssociation",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "string",\n                      "name": "id",\n                      "doc": "The id for the prompt. This must be GLOBALLY UNIQUE."\n                    },\n                    {\n                      "type": {\n                        "type": "record",\n                        "name": "AuditStamp",\n                        "namespace": "com.linkedin.common",\n                        "fields": [\n                          {\n                            "type": "long",\n                            "name": "time",\n                            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                          },\n                          {\n                            "java": {\n                              "class": "com.linkedin.common.urn.Urn"\n                            },\n                            "type": "string",\n                            "name": "actor",\n                            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                          },\n                          {\n                            "java": {\n                              "class": "com.linkedin.common.urn.Urn"\n                            },\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "impersonator",\n                            "default": null,\n                            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "message",\n                            "default": null,\n                            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                          }\n                        ],\n                        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n                      },\n                      "name": "lastModified",\n                      "doc": "The last time this prompt was touched for the entity (set, unset)"\n                    },\n                    {\n                      "type": [\n                        "null",\n                        {\n                          "type": "record",\n                          "name": "FormPromptFieldAssociations",\n                          "namespace": "com.linkedin.common",\n                          "fields": [\n                            {\n                              "type": [\n                                "null",\n                                {\n                                  "type": "array",\n                                  "items": {\n                                    "type": "record",\n                                    "name": "FieldFormPromptAssociation",\n                                    "namespace": "com.linkedin.common",\n                                    "fields": [\n                                      {\n                                        "type": "string",\n                                        "name": "fieldPath",\n                                        "doc": "The field path on a schema field."\n                                      },\n                                      {\n                                        "type": "com.linkedin.common.AuditStamp",\n                                        "name": "lastModified",\n                                        "doc": "The last time this prompt was touched for the field on the entity (set, unset)"\n                                      }\n                                    ],\n                                    "doc": "Information about the status of a particular prompt for a specific schema field\\non an entity."\n                                  }\n                                }\n                              ],\n                              "name": "completedFieldPrompts",\n                              "default": null,\n                              "doc": "A list of field-level prompt associations that are not yet complete for this form."\n                            },\n                            {\n                              "type": [\n                                "null",\n                                {\n                                  "type": "array",\n                                  "items": "com.linkedin.common.FieldFormPromptAssociation"\n                                }\n                              ],\n                              "name": "incompleteFieldPrompts",\n                              "default": null,\n                              "doc": "A list of field-level prompt associations that are complete for this form."\n                            }\n                          ],\n                          "doc": "Information about the field-level prompt associations on a top-level prompt association."\n                        }\n                      ],\n                      "name": "fieldAssociations",\n                      "default": null,\n                      "doc": "Optional information about the field-level prompt associations."\n                    }\n                  ],\n                  "doc": "Information about the status of a particular prompt.\\nNote that this is where we can add additional information about individual responses:\\nactor, timestamp, and the response itself."\n                }\n              },\n              "name": "incompletePrompts",\n              "default": [],\n              "doc": "A list of prompts that are not yet complete for this form."\n            },\n            {\n              "type": {\n                "type": "array",\n                "items": "com.linkedin.common.FormPromptAssociation"\n              },\n              "name": "completedPrompts",\n              "default": [],\n              "doc": "A list of prompts that have been completed for this form."\n            }\n          ],\n          "doc": "Properties of an applied form."\n        }\n      },\n      "name": "incompleteForms",\n      "doc": "All incomplete forms assigned to the entity."\n    },\n    {\n      "Searchable": {\n        "/*/completedPrompts/*/id": {\n          "fieldName": "completedFormsCompletedPromptIds",\n          "fieldType": "KEYWORD",\n          "queryByDefault": false\n        },\n        "/*/completedPrompts/*/lastModified/time": {\n          "fieldName": "completedFormsCompletedPromptResponseTimes",\n          "fieldType": "DATETIME",\n          "queryByDefault": false\n        },\n        "/*/incompletePrompts/*/id": {\n          "fieldName": "completedFormsIncompletePromptIds",\n          "fieldType": "KEYWORD",\n          "queryByDefault": false\n        },\n        "/*/urn": {\n          "fieldName": "completedForms",\n          "fieldType": "URN",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "com.linkedin.common.FormAssociation"\n      },\n      "name": "completedForms",\n      "doc": "All complete forms assigned to the entity."\n    },\n    {\n      "Searchable": {\n        "/*/form": {\n          "fieldName": "verifiedForms",\n          "fieldType": "URN",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "FormVerificationAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "form",\n              "doc": "The urn of the form that granted this verification."\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "lastModified",\n              "default": null,\n              "doc": "An audit stamp capturing who and when verification was applied for this form."\n            }\n          ],\n          "doc": "An association between a verification and an entity that has been granted\\nvia completion of one or more forms of type \'VERIFICATION\'."\n        }\n      },\n      "name": "verifications",\n      "default": [],\n      "doc": "Verifications that have been applied to the entity via completed forms."\n    }\n  ],\n  "doc": "Forms that are assigned to this entity to be filled out"\n}\n')))),(0,a.yg)("h4",{id:"businessattributes"},"businessAttributes"),(0,a.yg)("p",null,"BusinessAttribute aspect used for applying it to an entity"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"businessAttribute"),(0,a.yg)("td",{parentName:"tr",align:null},"BusinessAttributeAssociation"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Business Attribute for this field."),(0,a.yg)("td",{parentName:"tr",align:null},"\u2192 BusinessAttributeOf"))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "businessAttributes"\n  },\n  "name": "BusinessAttributes",\n  "namespace": "com.linkedin.businessattribute",\n  "fields": [\n    {\n      "Relationship": {\n        "/businessAttributeUrn": {\n          "entityTypes": [\n            "businessAttribute"\n          ],\n          "name": "BusinessAttributeOf"\n        }\n      },\n      "SearchableRef": {\n        "/businessAttributeUrn": {\n          "boostScore": 0.5,\n          "fieldName": "businessAttributeRef",\n          "fieldType": "URN",\n          "refType": "businessAttribute"\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "BusinessAttributeAssociation",\n          "namespace": "com.linkedin.businessattribute",\n          "fields": [\n            {\n              "Searchable": {\n                "fieldName": "schemaFieldBusinessAttribute",\n                "includeSystemModifiedAt": true,\n                "queryByDefault": false,\n                "systemModifiedAtFieldName": "schemaFieldBusinessAttributeModifiedAt"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.BusinessAttributeUrn"\n              },\n              "type": "string",\n              "name": "businessAttributeUrn",\n              "doc": "Urn of the applied businessAttribute"\n            }\n          ]\n        }\n      ],\n      "name": "businessAttribute",\n      "default": null,\n      "doc": "Business Attribute for this field."\n    }\n  ],\n  "doc": "BusinessAttribute aspect used for applying it to an entity"\n}\n')))),(0,a.yg)("h4",{id:"status-1"},"status"),(0,a.yg)("p",null,"The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\nThis aspect is used to represent soft deletes conventionally."),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"removed"),(0,a.yg)("td",{parentName:"tr",align:null},"boolean"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Whether the entity has been removed (soft-deleted)."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "status"\n  },\n  "name": "Status",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN"\n      },\n      "type": "boolean",\n      "name": "removed",\n      "default": false,\n      "doc": "Whether the entity has been removed (soft-deleted)."\n    }\n  ],\n  "doc": "The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\\nThis aspect is used to represent soft deletes conventionally."\n}\n')))),(0,a.yg)("h4",{id:"schemafieldaliases"},"schemaFieldAliases"),(0,a.yg)("p",null,"None"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"aliases"),(0,a.yg)("td",{parentName:"tr",align:null},"string[]"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Used to store aliases"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "schemaFieldAliases"\n  },\n  "name": "SchemaFieldAliases",\n  "namespace": "com.linkedin.schemafield",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "fieldName": "schemaFieldAliases",\n          "fieldType": "URN",\n          "queryByDefault": false\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": "string"\n        }\n      ],\n      "name": "aliases",\n      "default": null,\n      "doc": "Used to store aliases"\n    }\n  ]\n}\n')))),(0,a.yg)("h4",{id:"documentation-1"},"documentation"),(0,a.yg)("p",null,"Aspect used for storing all applicable documentations on assets.\nThis aspect supports multiple documentations from different sources.\nThere is an implicit assumption that there is only one documentation per\nsource.\nFor example, if there are two documentations from the same source, the\nlatest one will overwrite the previous one.\nIf there are two documentations from different sources, both will be\nstored.\nFuture evolution considerations:\nThe first entity that uses this aspect is Schema Field. We will expand this\naspect to other entities eventually.\nThe values of the documentation are not currently searchable. This will be\nchanged once this aspect develops opinion on which documentation entry is\nthe authoritative one.\nEnsuring that there is only one documentation per source is a business\nrule that is not enforced by the aspect yet. This will currently be enforced by the\napplication that uses this aspect. We will eventually enforce this rule in\nthe aspect using AspectMutators."),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"documentations"),(0,a.yg)("td",{parentName:"tr",align:null},"DocumentationAssociation[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Documentations associated with this asset. We could be receiving docs from different sources"),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "documentation"\n  },\n  "name": "Documentation",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "DocumentationAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "type": "string",\n              "name": "documentation",\n              "doc": "Description of this asset"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "documentationAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "documentationAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "documentationAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ],\n          "doc": "Properties of applied documentation including the attribution of the doc"\n        }\n      },\n      "name": "documentations",\n      "doc": "Documentations associated with this asset. We could be receiving docs from different sources"\n    }\n  ],\n  "doc": "Aspect used for storing all applicable documentations on assets.\\nThis aspect supports multiple documentations from different sources.\\nThere is an implicit assumption that there is only one documentation per\\n   source.\\nFor example, if there are two documentations from the same source, the\\n   latest one will overwrite the previous one.\\nIf there are two documentations from different sources, both will be\\n   stored.\\nFuture evolution considerations:\\nThe first entity that uses this aspect is Schema Field. We will expand this\\n    aspect to other entities eventually.\\nThe values of the documentation are not currently searchable. This will be\\n    changed once this aspect develops opinion on which documentation entry is\\n    the authoritative one.\\nEnsuring that there is only one documentation per source is a business\\n    rule that is not enforced by the aspect yet. This will currently be enforced by the\\n    application that uses this aspect. We will eventually enforce this rule in\\n    the aspect using AspectMutators."\n}\n')))),(0,a.yg)("h4",{id:"testresults"},"testResults"),(0,a.yg)("p",null,"Information about a Test Result"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"failing"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#testresult"},"TestResult"),"[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Results that are failing"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable, \u2192 IsFailing")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"passing"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#testresult"},"TestResult"),"[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Results that are passing"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable, \u2192 IsPassing"))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "testResults"\n  },\n  "name": "TestResults",\n  "namespace": "com.linkedin.test",\n  "fields": [\n    {\n      "Relationship": {\n        "/*/test": {\n          "entityTypes": [\n            "test"\n          ],\n          "name": "IsFailing"\n        }\n      },\n      "Searchable": {\n        "/*/test": {\n          "fieldName": "failingTests",\n          "fieldType": "URN",\n          "hasValuesFieldName": "hasFailingTests",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "TestResult",\n          "namespace": "com.linkedin.test",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "test",\n              "doc": "The urn of the test"\n            },\n            {\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "FAILURE": " The Test Failed",\n                  "SUCCESS": " The Test Succeeded"\n                },\n                "name": "TestResultType",\n                "namespace": "com.linkedin.test",\n                "symbols": [\n                  "SUCCESS",\n                  "FAILURE"\n                ]\n              },\n              "name": "type",\n              "doc": "The type of the result"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "testDefinitionMd5",\n              "default": null,\n              "doc": "The md5 of the test definition that was used to compute this result.\\nSee TestInfo.testDefinition.md5 for more information."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "AuditStamp",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "impersonator",\n                      "default": null,\n                      "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "message",\n                      "default": null,\n                      "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                    }\n                  ],\n                  "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n                }\n              ],\n              "name": "lastComputed",\n              "default": null,\n              "doc": "The audit stamp of when the result was computed, including the actor who computed it."\n            }\n          ],\n          "doc": "Information about a Test Result"\n        }\n      },\n      "name": "failing",\n      "doc": "Results that are failing"\n    },\n    {\n      "Relationship": {\n        "/*/test": {\n          "entityTypes": [\n            "test"\n          ],\n          "name": "IsPassing"\n        }\n      },\n      "Searchable": {\n        "/*/test": {\n          "fieldName": "passingTests",\n          "fieldType": "URN",\n          "hasValuesFieldName": "hasPassingTests",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "com.linkedin.test.TestResult"\n      },\n      "name": "passing",\n      "doc": "Results that are passing"\n    }\n  ],\n  "doc": "Information about a Test Result"\n}\n')))),(0,a.yg)("h4",{id:"deprecation-1"},"deprecation"),(0,a.yg)("p",null,"Deprecation status of an entity"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"deprecated"),(0,a.yg)("td",{parentName:"tr",align:null},"boolean"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Whether the entity is deprecated."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"decommissionTime"),(0,a.yg)("td",{parentName:"tr",align:null},"long"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"The time user plan to decommission this entity."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"note"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Additional information about the entity deprecation plan, such as the wiki, doc, RB."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"actor"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"The user URN which will be credited for modifying this deprecation content."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"replacement"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "deprecation"\n  },\n  "name": "Deprecation",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldType": "BOOLEAN",\n        "filterNameOverride": "Deprecated",\n        "weightsPerFieldValue": {\n          "true": 0.5\n        }\n      },\n      "type": "boolean",\n      "name": "deprecated",\n      "doc": "Whether the entity is deprecated."\n    },\n    {\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "decommissionTime",\n      "default": null,\n      "doc": "The time user plan to decommission this entity."\n    },\n    {\n      "type": "string",\n      "name": "note",\n      "doc": "Additional information about the entity deprecation plan, such as the wiki, doc, RB."\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "actor",\n      "doc": "The user URN which will be credited for modifying this deprecation content."\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "replacement",\n      "default": null\n    }\n  ],\n  "doc": "Deprecation status of an entity"\n}\n')))),(0,a.yg)("h4",{id:"subtypes-1"},"subTypes"),(0,a.yg)("p",null,"Sub Types. Use this aspect to specialize a generic Entity\ne.g. Making a Dataset also be a View or also be a LookerExplore"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"typeNames"),(0,a.yg)("td",{parentName:"tr",align:null},"string[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"The names of the specific types."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "subTypes"\n  },\n  "name": "SubTypes",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "addToFilters": true,\n          "fieldType": "KEYWORD",\n          "filterNameOverride": "Sub Type",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "typeNames",\n      "doc": "The names of the specific types."\n    }\n  ],\n  "doc": "Sub Types. Use this aspect to specialize a generic Entity\\ne.g. Making a Dataset also be a View or also be a LookerExplore"\n}\n')))),(0,a.yg)("h4",{id:"logicalparent"},"logicalParent"),(0,a.yg)("p",null,"Relates a physical asset to a logical model."),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"parent"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#edge"},"Edge")),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable, \u2192 PhysicalInstanceOf"))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "logicalParent"\n  },\n  "name": "LogicalParent",\n  "namespace": "com.linkedin.logical",\n  "fields": [\n    {\n      "Relationship": {\n        "/destinationUrn": {\n          "createdActor": "parent/created/actor",\n          "createdOn": "parent/created/time",\n          "entityTypes": [\n            "dataset",\n            "schemaField"\n          ],\n          "name": "PhysicalInstanceOf",\n          "properties": "parent/properties",\n          "updatedActor": "parent/lastModified/actor",\n          "updatedOn": "parent/lastModified/time"\n        }\n      },\n      "Searchable": {\n        "/destinationUrn": {\n          "addToFilters": true,\n          "fieldName": "logicalParent",\n          "fieldType": "URN",\n          "filterNameOverride": "Physical Instance Of",\n          "hasValuesFieldName": "hasLogicalParent",\n          "queryByDefault": false\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "Edge",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "sourceUrn",\n              "default": null,\n              "doc": "Urn of the source of this relationship edge.\\nIf not specified, assumed to be the entity that this aspect belongs to."\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "destinationUrn",\n              "doc": "Urn of the destination of this relationship edge."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "AuditStamp",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "impersonator",\n                      "default": null,\n                      "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "message",\n                      "default": null,\n                      "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                    }\n                  ],\n                  "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n                }\n              ],\n              "name": "created",\n              "default": null,\n              "doc": "Audit stamp containing who created this relationship edge and when"\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "lastModified",\n              "default": null,\n              "doc": "Audit stamp containing who last modified this relationship edge and when"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "map",\n                  "values": "string"\n                }\n              ],\n              "name": "properties",\n              "default": null,\n              "doc": "A generic properties bag that allows us to store specific information on this graph edge."\n            }\n          ],\n          "doc": "A common structure to represent all edges to entities when used inside aspects as collections\\nThis ensures that all edges have common structure around audit-stamps and will support PATCH, time-travel automatically."\n        }\n      ],\n      "name": "parent",\n      "default": null\n    }\n  ],\n  "doc": "Relates a physical asset to a logical model."\n}\n')))),(0,a.yg)("h4",{id:"globaltags"},"globalTags"),(0,a.yg)("p",null,"Tag aspect used for applying tags to an entity"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"tags"),(0,a.yg)("td",{parentName:"tr",align:null},"TagAssociation[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Tags associated with a given entity"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable, \u2192 TaggedWith"))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "globalTags"\n  },\n  "name": "GlobalTags",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Relationship": {\n        "/*/tag": {\n          "entityTypes": [\n            "tag"\n          ],\n          "name": "TaggedWith"\n        }\n      },\n      "Searchable": {\n        "/*/tag": {\n          "addToFilters": true,\n          "boostScore": 0.5,\n          "fieldName": "tags",\n          "fieldType": "URN",\n          "filterNameOverride": "Tagged With",\n          "hasValuesFieldName": "hasTags",\n          "queryByDefault": true,\n          "searchTier": 2\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "TagAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.TagUrn"\n              },\n              "type": "string",\n              "name": "tag",\n              "doc": "Urn of the applied tag"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "context",\n              "default": null,\n              "doc": "Additional context about the association"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "tagAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "tagAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "tagAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ],\n          "doc": "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\\npropagation parameters."\n        }\n      },\n      "name": "tags",\n      "doc": "Tags associated with a given entity"\n    }\n  ],\n  "doc": "Tag aspect used for applying tags to an entity"\n}\n')))),(0,a.yg)("h4",{id:"glossaryterms"},"glossaryTerms"),(0,a.yg)("p",null,"Related business terms information"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(l.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"terms"),(0,a.yg)("td",{parentName:"tr",align:null},"GlossaryTermAssociation[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"The related business terms"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"auditStamp"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Audit stamp containing who reported the related business term"),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(l.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "glossaryTerms"\n  },\n  "name": "GlossaryTerms",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "GlossaryTermAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "glossaryTerm"\n                ],\n                "name": "TermedWith"\n              },\n              "Searchable": {\n                "addToFilters": true,\n                "fieldName": "glossaryTerms",\n                "fieldType": "URN",\n                "filterNameOverride": "Glossary Term",\n                "hasValuesFieldName": "hasGlossaryTerms",\n                "includeSystemModifiedAt": true,\n                "systemModifiedAtFieldName": "termsModifiedAt"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.GlossaryTermUrn"\n              },\n              "type": "string",\n              "name": "urn",\n              "doc": "Urn of the applied glossary term"\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "actor",\n              "default": null,\n              "doc": "The user URN which will be credited for adding associating this term to the entity"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "context",\n              "default": null,\n              "doc": "Additional context about the association"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "termAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "termAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "termAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ],\n          "doc": "Properties of an applied glossary term."\n        }\n      },\n      "name": "terms",\n      "doc": "The related business terms"\n    },\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          },\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "message",\n            "default": null,\n            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "auditStamp",\n      "doc": "Audit stamp containing who reported the related business term"\n    }\n  ],\n  "doc": "Related business terms information"\n}\n')))),(0,a.yg)("h3",{id:"common-types"},"Common Types"),(0,a.yg)("p",null,"These types are used across multiple aspects in this entity."),(0,a.yg)("h4",{id:"auditstamp"},"AuditStamp"),(0,a.yg)("p",null,"Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Fields:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"time")," (long): When did the resource/association/sub-resource move into the specific lifecyc..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"actor")," (string): The entity (e.g. a member URN) which will be credited for moving the resource..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"impersonator")," (string?): The entity (e.g. a service URN) which performs the change on behalf of the Ac..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"message")," (string?): Additional context around how DataHub was informed of the particular change. ...")),(0,a.yg)("h4",{id:"edge"},"Edge"),(0,a.yg)("p",null,"A common structure to represent all edges to entities when used inside aspects as collections\nThis ensures that all edges have common structure around audit-stamps and will support PATCH, time-travel automatically."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Fields:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"sourceUrn")," (string?): Urn of the source of this relationship edge. If not specified, assumed to be ..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"destinationUrn")," (string): Urn of the destination of this relationship edge."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"created")," (AuditStamp?): Audit stamp containing who created this relationship edge and when"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"lastModified")," (AuditStamp?): Audit stamp containing who last modified this relationship edge and when"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"properties")," (map?): A generic properties bag that allows us to store specific information on this...")),(0,a.yg)("h4",{id:"formassociation"},"FormAssociation"),(0,a.yg)("p",null,"Properties of an applied form."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Fields:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"urn")," (string): Urn of the applied form"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"incompletePrompts")," (FormPromptAssociation[]): A list of prompts that are not yet complete for this form."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"completedPrompts")," (FormPromptAssociation[]): A list of prompts that have been completed for this form.")),(0,a.yg)("h4",{id:"testresult"},"TestResult"),(0,a.yg)("p",null,"Information about a Test Result"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Fields:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"test")," (string): The urn of the test"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"type")," (TestResultType): The type of the result"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"testDefinitionMd5")," (string?): The md5 of the test definition that was used to compute this result. See Test..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"lastComputed")," (AuditStamp?): The audit stamp of when the result was computed, including the actor who comp...")),(0,a.yg)("h3",{id:"relationships"},"Relationships"),(0,a.yg)("h4",{id:"self"},"Self"),(0,a.yg)("p",null,"These are the relationships to itself, stored in this entity's aspects"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"PhysicalInstanceOf (via ",(0,a.yg)("inlineCode",{parentName:"li"},"logicalParent.parent"),")")),(0,a.yg)("h4",{id:"outgoing"},"Outgoing"),(0,a.yg)("p",null,"These are the relationships stored in this entity's aspects"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"BusinessAttributeOf"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"BusinessAttribute via ",(0,a.yg)("inlineCode",{parentName:"li"},"businessAttributes.businessAttribute")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"IsFailing"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Test via ",(0,a.yg)("inlineCode",{parentName:"li"},"testResults.failing")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"IsPassing"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Test via ",(0,a.yg)("inlineCode",{parentName:"li"},"testResults.passing")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"PhysicalInstanceOf"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"logicalParent.parent")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"TaggedWith"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Tag via ",(0,a.yg)("inlineCode",{parentName:"li"},"globalTags.tags")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"TermedWith"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"GlossaryTerm via ",(0,a.yg)("inlineCode",{parentName:"li"},"glossaryTerms.terms.urn"))))),(0,a.yg)("h4",{id:"incoming"},"Incoming"),(0,a.yg)("p",null,"These are the relationships stored in other entity's aspects"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"DownstreamOf"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"upstreamLineage.fineGrainedLineages")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"ForeignKeyTo"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"schemaMetadata.foreignKeys.foreignFields")),(0,a.yg)("li",{parentName:"ul"},"GlossaryTerm via ",(0,a.yg)("inlineCode",{parentName:"li"},"schemaMetadata.foreignKeys.foreignFields")),(0,a.yg)("li",{parentName:"ul"},"Assertion via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.schemaAssertion.schema.foreignKeys.foreignFields")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"PhysicalInstanceOf"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"logicalParent.parent")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Consumes"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"DataJob via ",(0,a.yg)("inlineCode",{parentName:"li"},"dataJobInputOutput.inputDatasetFields")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Produces"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"DataJob via ",(0,a.yg)("inlineCode",{parentName:"li"},"dataJobInputOutput.outputDatasetFields")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"consumesField"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Chart via ",(0,a.yg)("inlineCode",{parentName:"li"},"inputFields.fields.schemaFieldUrn")),(0,a.yg)("li",{parentName:"ul"},"Dashboard via ",(0,a.yg)("inlineCode",{parentName:"li"},"inputFields.fields.schemaFieldUrn")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Asserts"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Assertion via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.datasetAssertion.fields")),(0,a.yg)("li",{parentName:"ul"},"Assertion via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.customAssertion.field"))))),(0,a.yg)("h3",{id:"global-metadata-model"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png"},"Global Metadata Model")),(0,a.yg)("p",null,(0,a.yg)("img",{parentName:"p",src:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png",alt:"Global Graph"})))}h.isMDXComponent=!0}}]);