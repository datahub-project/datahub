"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[19195],{15680:(e,n,a)=>{a.d(n,{xA:()=>m,yg:()=>y});var t=a(96540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function s(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?s(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function r(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},s=Object.keys(e);for(t=0;t<s.length;t++)a=s[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(t=0;t<s.length;t++)a=s[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=t.createContext({}),d=function(e){var n=t.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},m=function(e){var n=d(e.components);return t.createElement(l.Provider,{value:n},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=d(a),u=i,y=c["".concat(l,".").concat(u)]||c[u]||p[u]||s;return a?t.createElement(y,o(o({ref:n},m),{},{components:a})):t.createElement(y,o({ref:n},m))}));function y(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var s=a.length,o=new Array(s);o[0]=u;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r[c]="string"==typeof e?e:i,o[1]=r;for(var d=2;d<s;d++)o[d]=a[d];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},92349:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>m,contentTitle:()=>l,default:()=>y,frontMatter:()=>r,metadata:()=>d,toc:()=>c});a(96540);var t=a(15680);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function s(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))})),e}function o(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},s=Object.keys(e);for(t=0;t<s.length;t++)a=s[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(t=0;t<s.length;t++)a=s[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}const r={sidebar_position:2,title:"Dataset",slug:"/generated/metamodel/entities/dataset",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/dataset.md"},l="Dataset",d={unversionedId:"docs/generated/metamodel/entities/dataset",id:"version-1.1.0/docs/generated/metamodel/entities/dataset",title:"Dataset",description:"The dataset entity is one the most important entities in the metadata model. They represent collections of data that are typically represented as Tables or Views in a database (e.g. BigQuery, Snowflake, Redshift etc.), Streams in a stream-processing environment (Kafka, Pulsar etc.), bundles of data found as Files or Folders in data lake systems (S3, ADLS, etc.).",source:"@site/versioned_docs/version-1.1.0/docs/generated/metamodel/entities/dataset.md",sourceDirName:"docs/generated/metamodel/entities",slug:"/generated/metamodel/entities/dataset",permalink:"/docs/1.1.0/generated/metamodel/entities/dataset",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/dataset.md",tags:[],version:"1.1.0",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Dataset",slug:"/generated/metamodel/entities/dataset",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/dataset.md"},sidebar:"overviewSidebar",previous:{title:"Role",permalink:"/docs/1.1.0/generated/metamodel/entities/role"},next:{title:"DataJob",permalink:"/docs/1.1.0/generated/metamodel/entities/datajob"}},m={},c=[{value:"Identity",id:"identity",level:2},{value:"Important Capabilities",id:"important-capabilities",level:2},{value:"Schemas",id:"schemas",level:3},{value:"Field Paths explained",id:"field-paths-explained",level:4},{value:"Tags and Glossary Terms",id:"tags-and-glossary-terms",level:3},{value:"Adding Tags or Glossary Terms at the top-level to a dataset",id:"adding-tags-or-glossary-terms-at-the-top-level-to-a-dataset",level:4},{value:"Adding Tags or Glossary Terms to columns / fields of a dataset",id:"adding-tags-or-glossary-terms-to-columns--fields-of-a-dataset",level:4},{value:"Ownership",id:"ownership",level:3},{value:"Adding Owners",id:"adding-owners",level:4},{value:"Fine-grained lineage",id:"fine-grained-lineage",level:3},{value:"Querying lineage information",id:"querying-lineage-information",level:4},{value:"Documentation, Links etc.",id:"documentation-links-etc",level:3},{value:"Notable Exceptions",id:"notable-exceptions",level:2},{value:"Aspects",id:"aspects",level:2},{value:"datasetKey",id:"datasetkey",level:3},{value:"datasetProperties",id:"datasetproperties",level:3},{value:"editableDatasetProperties",id:"editabledatasetproperties",level:3},{value:"datasetUpstreamLineage",id:"datasetupstreamlineage",level:3},{value:"upstreamLineage",id:"upstreamlineage",level:3},{value:"institutionalMemory",id:"institutionalmemory",level:3},{value:"ownership",id:"ownership-1",level:3},{value:"status",id:"status",level:3},{value:"schemaMetadata",id:"schemametadata",level:3},{value:"editableSchemaMetadata",id:"editableschemametadata",level:3},{value:"globalTags",id:"globaltags",level:3},{value:"glossaryTerms",id:"glossaryterms",level:3},{value:"browsePaths",id:"browsepaths",level:3},{value:"dataPlatformInstance",id:"dataplatforminstance",level:3},{value:"viewProperties",id:"viewproperties",level:3},{value:"browsePathsV2",id:"browsepathsv2",level:3},{value:"subTypes",id:"subtypes",level:3},{value:"domains",id:"domains",level:3},{value:"container",id:"container",level:3},{value:"deprecation",id:"deprecation",level:3},{value:"testResults",id:"testresults",level:3},{value:"siblings",id:"siblings",level:3},{value:"embed",id:"embed",level:3},{value:"incidentsSummary",id:"incidentssummary",level:3},{value:"access",id:"access",level:3},{value:"structuredProperties",id:"structuredproperties",level:3},{value:"forms",id:"forms",level:3},{value:"partitionsSummary",id:"partitionssummary",level:3},{value:"versionProperties",id:"versionproperties",level:3},{value:"icebergCatalogInfo",id:"icebergcataloginfo",level:3},{value:"datasetProfile (Timeseries)",id:"datasetprofile-timeseries",level:3},{value:"datasetUsageStatistics (Timeseries)",id:"datasetusagestatistics-timeseries",level:3},{value:"operation (Timeseries)",id:"operation-timeseries",level:3},{value:"datasetDeprecation (Deprecated)",id:"datasetdeprecation-deprecated",level:3},{value:"Relationships",id:"relationships",level:2},{value:"Self",id:"self",level:3},{value:"Outgoing",id:"outgoing",level:3},{value:"Global Metadata Model",id:"global-metadata-model",level:2}],p={toc:c},u="wrapper";function y(e){var{components:n}=e,a=o(e,["components"]);return(0,t.yg)(u,s(function(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{},t=Object.keys(a);"function"==typeof Object.getOwnPropertySymbols&&(t=t.concat(Object.getOwnPropertySymbols(a).filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable})))),t.forEach((function(n){i(e,n,a[n])}))}return e}({},p,a),{components:n,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"dataset"},"Dataset"),(0,t.yg)("p",null,"The dataset entity is one the most important entities in the metadata model. They represent collections of data that are typically represented as Tables or Views in a database (e.g. BigQuery, Snowflake, Redshift etc.), Streams in a stream-processing environment (Kafka, Pulsar etc.), bundles of data found as Files or Folders in data lake systems (S3, ADLS, etc.)."),(0,t.yg)("h2",{id:"identity"},"Identity"),(0,t.yg)("p",null,"Datasets are identified by three pieces of information:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"The platform that they belong to: this is the specific data technology that hosts this dataset. Examples are ",(0,t.yg)("inlineCode",{parentName:"li"},"hive"),", ",(0,t.yg)("inlineCode",{parentName:"li"},"bigquery"),", ",(0,t.yg)("inlineCode",{parentName:"li"},"redshift")," etc. See ",(0,t.yg)("a",{parentName:"li",href:"/docs/1.1.0/generated/metamodel/entities/dataplatform"},"dataplatform")," for more details."),(0,t.yg)("li",{parentName:"ul"},"The name of the dataset in the specific platform. Each platform will have a unique way of naming assets within its system. Usually, names are composed by combining the structural elements of the name and separating them by ",(0,t.yg)("inlineCode",{parentName:"li"},"."),". e.g. relational datasets are usually named as ",(0,t.yg)("inlineCode",{parentName:"li"},"<db>.<schema>.<table>"),", except for platforms like MySQL which do not have the concept of a ",(0,t.yg)("inlineCode",{parentName:"li"},"schema"),"; as a result MySQL datasets are named ",(0,t.yg)("inlineCode",{parentName:"li"},"<db>.<table>"),". In cases where the specific platform can have multiple instances (e.g. there are multiple different instances of MySQL databases that have different data assets in them), names can also include instance ids, making the general pattern for a name ",(0,t.yg)("inlineCode",{parentName:"li"},"<platform_instance>.<db>.<schema>.<table>"),"."),(0,t.yg)("li",{parentName:"ul"},"The environment or fabric in which the dataset belongs: this is an additional qualifier available on the identifier, to allow disambiguating datasets that live in Production environments from datasets that live in Non-production environments, such as Staging, QA, etc. The full list of supported environments / fabrics is available in ",(0,t.yg)("a",{parentName:"li",href:"https://raw.githubusercontent.com/datahub-project/datahub/master/li-utils/src/main/pegasus/com/linkedin/common/FabricType.pdl"},"FabricType.pdl"),".")),(0,t.yg)("p",null,"An example of a dataset identifier is ",(0,t.yg)("inlineCode",{parentName:"p"},"urn:li:dataset:(urn:li:dataPlatform:redshift,userdb.public.customer_table,PROD)"),"."),(0,t.yg)("h2",{id:"important-capabilities"},"Important Capabilities"),(0,t.yg)("h3",{id:"schemas"},"Schemas"),(0,t.yg)("p",null,"Datasets support flat and nested schemas. Metadata about schemas are contained in the ",(0,t.yg)("inlineCode",{parentName:"p"},"schemaMetadata")," aspect. Schemas are represented as an array of fields, each identified by a specific field path."),(0,t.yg)("h4",{id:"field-paths-explained"},"Field Paths explained"),(0,t.yg)("p",null,"Fields that are either top-level or expressible unambiguously using a ",(0,t.yg)("inlineCode",{parentName:"p"},".")," based notation can be identified via a v1 path name, whereas fields that are part of a union need further disambiguation using ",(0,t.yg)("inlineCode",{parentName:"p"},"[type=X]")," markers.\nTaking a simple nested schema as described below:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n    "type": "record",\n    "name": "Customer",\n    "fields":[\n        {\n        "type": "record",\n        "name": "address",\n        "fields": [\n            { "name": "zipcode", "type": string},\n            {"name": "street", "type": string}]\n        }],\n}\n')),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"v1 field path: ",(0,t.yg)("inlineCode",{parentName:"li"},"address.zipcode")),(0,t.yg)("li",{parentName:"ul"},"v2 field path: ",(0,t.yg)("inlineCode",{parentName:"li"},'[version=2.0].[type=struct].address.[type=string].zipcode"'),". More examples and a formal specification of a v2 fieldPath can be found ",(0,t.yg)("a",{parentName:"li",href:"/docs/1.1.0/advanced/field-path-spec-v2"},"here"),".")),(0,t.yg)("p",null,"Understanding field paths is important, because they are the identifiers through which tags, terms, documentation on fields are expressed. Besides the type and name of the field, schemas also contain descriptions attached to the individual fields, as well as information about primary and foreign keys."),(0,t.yg)("p",null,"The following code snippet shows you how to add a Schema containing 3 fields to a dataset."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Python SDK: Add a schema to a dataset"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/dataset_schema.py\nfrom datahub.sdk import DataHubClient, Dataset\n\nclient = DataHubClient.from_env()\n\ndataset = Dataset(\n    platform="hive",\n    name="realestate_db.sales",\n    schema=[\n        # tuples of (field name / field path, data type, description)\n        (\n            "address.zipcode",\n            "varchar(50)",\n            "This is the zipcode of the address. Specified using extended form and limited to addresses in the United States",\n        ),\n        ("address.street", "varchar(100)", "Street corresponding to the address"),\n        ("last_sold_date", "date", "Date of the last sale date for this property"),\n    ],\n)\n\nclient.entities.upsert(dataset)\n\n'))),(0,t.yg)("h3",{id:"tags-and-glossary-terms"},"Tags and Glossary Terms"),(0,t.yg)("p",null,"Datasets can have Tags or Terms attached to them. Read ",(0,t.yg)("a",{parentName:"p",href:"https://medium.com/datahub-project/tags-and-terms-two-powerful-datahub-features-used-in-two-different-scenarios-b5b4791e892e"},"this blog")," to understand the difference between tags and terms so you understand when you should use which."),(0,t.yg)("h4",{id:"adding-tags-or-glossary-terms-at-the-top-level-to-a-dataset"},"Adding Tags or Glossary Terms at the top-level to a dataset"),(0,t.yg)("p",null,"At the top-level, tags are added to datasets using the ",(0,t.yg)("inlineCode",{parentName:"p"},"globalTags")," aspect, while terms are added using the ",(0,t.yg)("inlineCode",{parentName:"p"},"glossaryTerms")," aspect."),(0,t.yg)("p",null,"Here is an example for how to add a tag to a dataset. Note that this involves reading the currently set tags on the dataset and then adding a new one if needed."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Python SDK: Add a tag to a dataset at the top-level"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/dataset_add_tag.py\nfrom datahub.sdk import DataHubClient, DatasetUrn, TagUrn\n\nclient = DataHubClient.from_env()\n\ndataset = client.entities.get(DatasetUrn(platform="hive", name="realestate_db.sales"))\ndataset.add_tag(TagUrn("purchase"))\n\nclient.entities.update(dataset)\n\n'))),(0,t.yg)("p",null,"Here is an example of adding a term to a dataset. Note that this involves reading the currently set terms on the dataset and then adding a new one if needed."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Python SDK: Add a term to a dataset at the top-level"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/dataset_add_term.py\nfrom datahub.sdk import DataHubClient, DatasetUrn, GlossaryTermUrn\n\nclient = DataHubClient.from_env()\n\ndataset = client.entities.get(\n    DatasetUrn(platform="hive", name="realestate_db.sales", env="PROD")\n)\ndataset.add_term(GlossaryTermUrn("Classification.HighlyConfidential"))\n\nclient.entities.update(dataset)\n\n'))),(0,t.yg)("h4",{id:"adding-tags-or-glossary-terms-to-columns--fields-of-a-dataset"},"Adding Tags or Glossary Terms to columns / fields of a dataset"),(0,t.yg)("p",null,"Tags and Terms can also be attached to an individual column (field) of a dataset. These attachments are done via the ",(0,t.yg)("inlineCode",{parentName:"p"},"schemaMetadata")," aspect by ingestion connectors / transformers and via the ",(0,t.yg)("inlineCode",{parentName:"p"},"editableSchemaMetadata")," aspect by the UI.\nThis separation allows the writes from the replication of metadata from the source system to be isolated from the edits made in the UI."),(0,t.yg)("p",null,"Here is an example of how you can add a tag to a field in a dataset using the low-level Python SDK."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Python SDK: Add a tag to a column (field) of a dataset"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/dataset_add_column_tag.py\nfrom datahub.sdk import DataHubClient, DatasetUrn, TagUrn\n\nclient = DataHubClient.from_env()\n\ndataset = client.entities.get(\n    DatasetUrn(platform="hive", name="fct_users_created", env="PROD")\n)\n\ndataset["user_name"].add_tag(TagUrn("deprecated"))\n\nclient.entities.update(dataset)\n\n'))),(0,t.yg)("p",null,"Similarly, here is an example of how you would add a term to a field in a dataset using the low-level Python SDK."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Python SDK: Add a term to a column (field) of a dataset"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/dataset_add_column_term.py\nfrom datahub.sdk import DataHubClient, DatasetUrn, GlossaryTermUrn\n\nclient = DataHubClient.from_env()\n\ndataset = client.entities.get(\n    DatasetUrn(platform="hive", name="realestate_db.sales", env="PROD")\n)\n\ndataset["address.zipcode"].add_term(GlossaryTermUrn("Classification.Location"))\n\nclient.entities.update(dataset)\n\n'))),(0,t.yg)("h3",{id:"ownership"},"Ownership"),(0,t.yg)("p",null,"Ownership is associated to a dataset using the ",(0,t.yg)("inlineCode",{parentName:"p"},"ownership")," aspect. Owners can be of a few different types, ",(0,t.yg)("inlineCode",{parentName:"p"},"DATAOWNER"),", ",(0,t.yg)("inlineCode",{parentName:"p"},"PRODUCER"),", ",(0,t.yg)("inlineCode",{parentName:"p"},"DEVELOPER"),", ",(0,t.yg)("inlineCode",{parentName:"p"},"CONSUMER"),", etc. See ",(0,t.yg)("a",{parentName:"p",href:"https://raw.githubusercontent.com/datahub-project/datahub/master/metadata-models/src/main/pegasus/com/linkedin/common/OwnershipType.pdl"},"OwnershipType.pdl")," for the full list of ownership types and their meanings. Ownership can be inherited from source systems, or additionally added in DataHub using the UI. Ingestion connectors for sources will automatically set owners when the source system supports it."),(0,t.yg)("h4",{id:"adding-owners"},"Adding Owners"),(0,t.yg)("p",null,"The following script shows you how to add an owner to a dataset using the low-level Python SDK."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Python SDK: Add an owner to a dataset"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/dataset_add_owner.py\nfrom datahub.sdk import CorpUserUrn, DataHubClient, DatasetUrn\n\nclient = DataHubClient.from_env()\n\ndataset = client.entities.get(DatasetUrn(platform="hive", name="realestate_db.sales"))\n\n# Add owner with the TECHNICAL_OWNER type\ndataset.add_owner(CorpUserUrn("jdoe"))\n\nclient.entities.update(dataset)\n\n'))),(0,t.yg)("h3",{id:"fine-grained-lineage"},"Fine-grained lineage"),(0,t.yg)("p",null,"Fine-grained lineage at field level can be associated to a dataset in two ways - either directly attached to the ",(0,t.yg)("inlineCode",{parentName:"p"},"upstreamLineage")," aspect of a dataset, or captured as part of the ",(0,t.yg)("inlineCode",{parentName:"p"},"dataJobInputOutput")," aspect of a dataJob."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Python SDK: Add fine-grained lineage to a dataset"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/lineage_emitter_dataset_finegrained.py\nimport datahub.emitter.mce_builder as builder\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.com.linkedin.pegasus2avro.dataset import (\n    DatasetLineageType,\n    FineGrainedLineage,\n    FineGrainedLineageDownstreamType,\n    FineGrainedLineageUpstreamType,\n    Upstream,\n    UpstreamLineage,\n)\n\n\ndef datasetUrn(tbl):\n    return builder.make_dataset_urn("postgres", tbl)\n\n\ndef fldUrn(tbl, fld):\n    return builder.make_schema_field_urn(datasetUrn(tbl), fld)\n\n\n# Lineage of fields in a dataset\n# c1      <-- unknownFunc(bar2.c1, bar4.c1)\n# c2      <-- myfunc(bar3.c2)\n# {c3,c4} <-- unknownFunc(bar2.c2, bar2.c3, bar3.c1)\n# c5      <-- unknownFunc(bar3)\n# {c6,c7} <-- unknownFunc(bar4)\n\n# note that the semantic of the "transformOperation" value is contextual.\n# In above example, it is regarded as some kind of UDF; but it could also be an expression etc.\n\nfineGrainedLineages = [\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n        upstreams=[fldUrn("bar2", "c1"), fldUrn("bar4", "c1")],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD,\n        downstreams=[fldUrn("bar", "c1")],\n    ),\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n        upstreams=[fldUrn("bar3", "c2")],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD,\n        downstreams=[fldUrn("bar", "c2")],\n        confidenceScore=0.8,\n        transformOperation="myfunc",\n    ),\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n        upstreams=[fldUrn("bar2", "c2"), fldUrn("bar2", "c3"), fldUrn("bar3", "c1")],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD_SET,\n        downstreams=[fldUrn("bar", "c3"), fldUrn("bar", "c4")],\n        confidenceScore=0.7,\n    ),\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.DATASET,\n        upstreams=[datasetUrn("bar3")],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD,\n        downstreams=[fldUrn("bar", "c5")],\n    ),\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.DATASET,\n        upstreams=[datasetUrn("bar4")],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD_SET,\n        downstreams=[fldUrn("bar", "c6"), fldUrn("bar", "c7")],\n    ),\n]\n\n\n# this is just to check if any conflicts with existing Upstream, particularly the DownstreamOf relationship\nupstream = Upstream(dataset=datasetUrn("bar2"), type=DatasetLineageType.TRANSFORMED)\n\nfieldLineages = UpstreamLineage(\n    upstreams=[upstream], fineGrainedLineages=fineGrainedLineages\n)\n\nlineageMcp = MetadataChangeProposalWrapper(\n    entityUrn=datasetUrn("bar"),\n    aspect=fieldLineages,\n)\n\n# Create an emitter to the GMS REST API.\nemitter = DatahubRestEmitter("http://localhost:8080")\n\n# Emit metadata!\nemitter.emit_mcp(lineageMcp)\n\n'))),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Python SDK: Add fine-grained lineage to a datajob"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/lineage_emitter_datajob_finegrained.py\nimport datahub.emitter.mce_builder as builder\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.com.linkedin.pegasus2avro.dataset import (\n    FineGrainedLineage,\n    FineGrainedLineageDownstreamType,\n    FineGrainedLineageUpstreamType,\n)\nfrom datahub.metadata.schema_classes import DataJobInputOutputClass\n\n\ndef datasetUrn(tbl):\n    return builder.make_dataset_urn("postgres", tbl)\n\n\ndef fldUrn(tbl, fld):\n    return builder.make_schema_field_urn(datasetUrn(tbl), fld)\n\n\n# Lineage of fields output by a job\n# bar.c1          <-- unknownFunc(bar2.c1, bar4.c1)\n# bar.c2          <-- myfunc(bar3.c2)\n# {bar.c3,bar.c4} <-- unknownFunc(bar2.c2, bar2.c3, bar3.c1)\n# bar.c5          <-- unknownFunc(bar3)\n# {bar.c6,bar.c7} <-- unknownFunc(bar4)\n# bar2.c9 has no upstream i.e. its values are somehow created independently within this job.\n\n# Note that the semantic of the "transformOperation" value is contextual.\n# In above example, it is regarded as some kind of UDF; but it could also be an expression etc.\n\nfineGrainedLineages = [\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n        upstreams=[fldUrn("bar2", "c1"), fldUrn("bar4", "c1")],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD,\n        downstreams=[fldUrn("bar", "c1")],\n    ),\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n        upstreams=[fldUrn("bar3", "c2")],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD,\n        downstreams=[fldUrn("bar", "c2")],\n        confidenceScore=0.8,\n        transformOperation="myfunc",\n    ),\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n        upstreams=[fldUrn("bar2", "c2"), fldUrn("bar2", "c3"), fldUrn("bar3", "c1")],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD_SET,\n        downstreams=[fldUrn("bar", "c3"), fldUrn("bar", "c4")],\n        confidenceScore=0.7,\n    ),\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.DATASET,\n        upstreams=[datasetUrn("bar3")],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD,\n        downstreams=[fldUrn("bar", "c5")],\n    ),\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.DATASET,\n        upstreams=[datasetUrn("bar4")],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD_SET,\n        downstreams=[fldUrn("bar", "c6"), fldUrn("bar", "c7")],\n    ),\n    FineGrainedLineage(\n        upstreamType=FineGrainedLineageUpstreamType.NONE,\n        upstreams=[],\n        downstreamType=FineGrainedLineageDownstreamType.FIELD,\n        downstreams=[fldUrn("bar2", "c9")],\n    ),\n]\n\n# The lineage of output col bar.c9 is unknown. So there is no lineage for it above.\n# Note that bar2 is an input as well as an output dataset, but some fields are inputs while other fields are outputs.\n\ndataJobInputOutput = DataJobInputOutputClass(\n    inputDatasets=[datasetUrn("bar2"), datasetUrn("bar3"), datasetUrn("bar4")],\n    outputDatasets=[datasetUrn("bar"), datasetUrn("bar2")],\n    inputDatajobs=None,\n    inputDatasetFields=[\n        fldUrn("bar2", "c1"),\n        fldUrn("bar2", "c2"),\n        fldUrn("bar2", "c3"),\n        fldUrn("bar3", "c1"),\n        fldUrn("bar3", "c2"),\n        fldUrn("bar4", "c1"),\n    ],\n    outputDatasetFields=[\n        fldUrn("bar", "c1"),\n        fldUrn("bar", "c2"),\n        fldUrn("bar", "c3"),\n        fldUrn("bar", "c4"),\n        fldUrn("bar", "c5"),\n        fldUrn("bar", "c6"),\n        fldUrn("bar", "c7"),\n        fldUrn("bar", "c9"),\n        fldUrn("bar2", "c9"),\n    ],\n    fineGrainedLineages=fineGrainedLineages,\n)\n\ndataJobLineageMcp = MetadataChangeProposalWrapper(\n    entityUrn=builder.make_data_job_urn("spark", "Flow1", "Task1"),\n    aspect=dataJobInputOutput,\n)\n\n# Create an emitter to the GMS REST API.\nemitter = DatahubRestEmitter("http://localhost:8080")\n\n# Emit metadata!\nemitter.emit_mcp(dataJobLineageMcp)\n\n'))),(0,t.yg)("h4",{id:"querying-lineage-information"},"Querying lineage information"),(0,t.yg)("p",null,"The standard ",(0,t.yg)("a",{parentName:"p",href:"/docs/metadata-service/#retrieving-entities"},"GET APIs to retrieve entities")," can be used to fetch the dataset/datajob created by the above example.\nThe response will include the fine-grained lineage information as well."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Fetch entity snapshot, including fine-grained lineages"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre"},"curl 'http://localhost:8080/entities/urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Apostgres,bar,PROD)'\n")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre"},"curl 'http://localhost:8080/entities/urn%3Ali%3AdataJob%3A(urn%3Ali%3AdataFlow%3A(spark,Flow1,prod),Task1)'\n"))),(0,t.yg)("p",null,"The below queries can be used to find the upstream/downstream datasets/fields of a dataset/datajob."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Find upstream datasets and fields of a dataset"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre"},'curl \'http://localhost:8080/relationships?direction=OUTGOING&urn=urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Apostgres,bar,PROD)&types=DownstreamOf\'\n\n{\n    "start": 0,\n    "count": 9,\n    "relationships": [\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar4,PROD)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD),c1)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c3)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c2)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD),c2)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar4,PROD),c1)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c1)"\n        }\n    ],\n    "total": 9\n}\n'))),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Find the datasets and fields consumed by a datajob i.e. inputs to a datajob"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre"},'curl \'http://localhost:8080/relationships?direction=OUTGOING&urn=urn%3Ali%3AdataJob%3A(urn%3Ali%3AdataFlow%3A(spark,Flow1,prod),Task1)&types=Consumes\'\n\n{\n    "start": 0,\n    "count": 9,\n    "relationships": [\n        {\n            "type": "Consumes",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar4,PROD)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar4,PROD),c1)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD),c2)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD),c1)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c3)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c2)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c1)"\n        }\n    ],\n    "total": 9\n}\n'))),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Find the datasets and fields produced by a datajob i.e. outputs of a datajob"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre"},'curl \'http://localhost:8080/relationships?direction=OUTGOING&urn=urn%3Ali%3AdataJob%3A(urn%3Ali%3AdataFlow%3A(spark,Flow1,prod),Task1)&types=Produces\'\n\n{\n    "start": 0,\n    "count": 11,\n    "relationships": [\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c9)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c9)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c7)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c6)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c5)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c4)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c3)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c2)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c1)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD)"\n        }\n    ],\n    "total": 11\n}\n'))),(0,t.yg)("h3",{id:"documentation-links-etc"},"Documentation, Links etc."),(0,t.yg)("p",null,"Documentation for Datasets is available via the ",(0,t.yg)("inlineCode",{parentName:"p"},"datasetProperties")," aspect (typically filled out via ingestion connectors when information is already present in the source system) and via the ",(0,t.yg)("inlineCode",{parentName:"p"},"editableDatasetProperties")," aspect (filled out via the UI typically)"),(0,t.yg)("p",null,"Links that contain more knowledge about the dataset (e.g. links to Confluence pages) can be added via the ",(0,t.yg)("inlineCode",{parentName:"p"},"institutionalMemory")," aspect."),(0,t.yg)("p",null,"Here is a simple script that shows you how to add documentation for a dataset including some links to pages using the low-level Python SDK."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Python SDK: Add documentation, links to a dataset"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/dataset_add_documentation.py\nfrom datahub.sdk import DataHubClient, DatasetUrn\n\nclient = DataHubClient.from_env()\n\ndataset = client.entities.get(DatasetUrn(platform="hive", name="realestate_db.sales"))\n\n# Add dataset documentation\ndocumentation = """## The Real Estate Sales Dataset\nThis is a really important Dataset that contains all the relevant information about sales that have happened organized by address.\n"""\ndataset.set_description(documentation)\n\n# Add link to institutional memory\ndataset.add_link(\n    (\n        "https://wikipedia.com/real_estate",\n        "This is the definition of what real estate means",  # link description\n    )\n)\n\nclient.entities.update(dataset)\n\n'))),(0,t.yg)("h2",{id:"notable-exceptions"},"Notable Exceptions"),(0,t.yg)("p",null,"The following overloaded uses of the Dataset entity exist for convenience, but will likely move to fully modeled entity types in the future."),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"OpenAPI endpoints: the GET API of OpenAPI endpoints are currently modeled as Datasets, but should really be modeled as a Service/API entity once this is created in the metadata model."),(0,t.yg)("li",{parentName:"ul"},"DataHub's Logical Entities (e.g.. Dataset, Chart, Dashboard) are represented as Datasets, with sub-type Entity. These should really be modeled as Entities in a logical ER model once this is created in the metadata model.")),(0,t.yg)("h2",{id:"aspects"},"Aspects"),(0,t.yg)("h3",{id:"datasetkey"},"datasetKey"),(0,t.yg)("p",null,"Key for a Dataset"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetKey"\n  },\n  "name": "DatasetKey",\n  "namespace": "com.linkedin.metadata.key",\n  "fields": [\n    {\n      "Searchable": {\n        "enableAutocomplete": true,\n        "fieldType": "URN"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "platform",\n      "doc": "Data platform urn associated with the dataset"\n    },\n    {\n      "Searchable": {\n        "boostScore": 10.0,\n        "enableAutocomplete": true,\n        "fieldName": "id",\n        "fieldType": "WORD_GRAM"\n      },\n      "type": "string",\n      "name": "name",\n      "doc": "Unique guid for dataset"\n    },\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldType": "TEXT_PARTIAL",\n        "filterNameOverride": "Environment",\n        "queryByDefault": false\n      },\n      "type": {\n        "type": "enum",\n        "symbolDocs": {\n          "CORP": "Designates corporation fabrics",\n          "DEV": "Designates development fabrics",\n          "EI": "Designates early-integration fabrics",\n          "NON_PROD": "Designates non-production fabrics",\n          "PRE": "Designates pre-production fabrics",\n          "PROD": "Designates production fabrics",\n          "QA": "Designates quality assurance fabrics",\n          "RVW": "Designates review fabrics",\n          "SANDBOX": "Designates sandbox fabrics",\n          "STG": "Designates staging fabrics",\n          "TEST": "Designates testing fabrics",\n          "UAT": "Designates user acceptance testing fabrics"\n        },\n        "name": "FabricType",\n        "namespace": "com.linkedin.common",\n        "symbols": [\n          "DEV",\n          "TEST",\n          "QA",\n          "UAT",\n          "EI",\n          "PRE",\n          "STG",\n          "NON_PROD",\n          "PROD",\n          "CORP",\n          "RVW",\n          "SANDBOX"\n        ],\n        "doc": "Fabric group type"\n      },\n      "name": "origin",\n      "doc": "Fabric type where dataset belongs to or where it was generated."\n    }\n  ],\n  "doc": "Key for a Dataset"\n}\n'))),(0,t.yg)("h3",{id:"datasetproperties"},"datasetProperties"),(0,t.yg)("p",null,"Properties associated with a Dataset"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetProperties"\n  },\n  "name": "DatasetProperties",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "fieldType": "TEXT",\n          "queryByDefault": true\n        }\n      },\n      "type": {\n        "type": "map",\n        "values": "string"\n      },\n      "name": "customProperties",\n      "default": {},\n      "doc": "Custom property bag."\n    },\n    {\n      "Searchable": {\n        "fieldType": "KEYWORD"\n      },\n      "java": {\n        "class": "com.linkedin.common.url.Url",\n        "coercerClass": "com.linkedin.common.url.UrlCoercer"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "externalUrl",\n      "default": null,\n      "doc": "URL where the reference exist"\n    },\n    {\n      "Searchable": {\n        "boostScore": 10.0,\n        "enableAutocomplete": true,\n        "fieldNameAliases": [\n          "_entityName"\n        ],\n        "fieldType": "WORD_GRAM"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "name",\n      "default": null,\n      "doc": "Display name of the Dataset"\n    },\n    {\n      "Searchable": {\n        "addToFilters": false,\n        "boostScore": 10.0,\n        "enableAutocomplete": true,\n        "fieldType": "WORD_GRAM"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "qualifiedName",\n      "default": null,\n      "doc": "Fully-qualified name of the Dataset"\n    },\n    {\n      "Searchable": {\n        "fieldType": "TEXT",\n        "hasValuesFieldName": "hasDescription"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "description",\n      "default": null,\n      "doc": "Documentation of the dataset"\n    },\n    {\n      "deprecated": "Use ExternalReference.externalUrl field instead.",\n      "java": {\n        "class": "java.net.URI"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "uri",\n      "default": null,\n      "doc": "The abstracted URI such as hdfs:///data/tracking/PageViewEvent, file:///dir/file_name. Uri should not include any environment specific properties. Some datasets might not have a standardized uri, which makes this field optional (i.e. kafka topic)."\n    },\n    {\n      "Searchable": {\n        "/time": {\n          "fieldName": "createdAt",\n          "fieldType": "DATETIME"\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "TimeStamp",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "type": "long",\n              "name": "time",\n              "doc": "When did the event occur"\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "actor",\n              "default": null,\n              "doc": "Optional: The actor urn involved in the event."\n            }\n          ],\n          "doc": "A standard event timestamp"\n        }\n      ],\n      "name": "created",\n      "default": null,\n      "doc": "A timestamp documenting when the asset was created in the source Data Platform (not on DataHub)"\n    },\n    {\n      "Searchable": {\n        "/time": {\n          "fieldName": "lastModifiedAt",\n          "fieldType": "DATETIME"\n        }\n      },\n      "type": [\n        "null",\n        "com.linkedin.common.TimeStamp"\n      ],\n      "name": "lastModified",\n      "default": null,\n      "doc": "A timestamp documenting when the asset was last modified in the source Data Platform (not on DataHub)"\n    },\n    {\n      "deprecated": "Use GlobalTags aspect instead.",\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "tags",\n      "default": [],\n      "doc": "[Legacy] Unstructured tags for the dataset. Structured tags can be applied via the `GlobalTags` aspect.\\nThis is now deprecated."\n    }\n  ],\n  "doc": "Properties associated with a Dataset"\n}\n'))),(0,t.yg)("h3",{id:"editabledatasetproperties"},"editableDatasetProperties"),(0,t.yg)("p",null,"EditableDatasetProperties stores editable changes made to dataset properties. This separates changes made from\ningestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "editableDatasetProperties"\n  },\n  "name": "EditableDatasetProperties",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          },\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "message",\n            "default": null,\n            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "created",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0,\n        "message": null\n      },\n      "doc": "An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": "com.linkedin.common.AuditStamp",\n      "name": "lastModified",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0,\n        "message": null\n      },\n      "doc": "An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": [\n        "null",\n        "com.linkedin.common.AuditStamp"\n      ],\n      "name": "deleted",\n      "default": null,\n      "doc": "An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."\n    },\n    {\n      "Searchable": {\n        "fieldName": "editedDescription",\n        "fieldType": "TEXT"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "description",\n      "default": null,\n      "doc": "Documentation of the dataset"\n    },\n    {\n      "Searchable": {\n        "fieldName": "editedName",\n        "fieldType": "TEXT_PARTIAL"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "name",\n      "default": null,\n      "doc": "Editable display name of the Dataset"\n    }\n  ],\n  "doc": "EditableDatasetProperties stores editable changes made to dataset properties. This separates changes made from\\ningestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"\n}\n'))),(0,t.yg)("h3",{id:"datasetupstreamlineage"},"datasetUpstreamLineage"),(0,t.yg)("p",null,"Fine Grained upstream lineage for fields in a dataset"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetUpstreamLineage"\n  },\n  "deprecated": "use UpstreamLineage.fineGrainedLineages instead",\n  "name": "DatasetUpstreamLineage",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "deprecated": "use FineGrainedLineage instead",\n          "name": "DatasetFieldMapping",\n          "namespace": "com.linkedin.dataset",\n          "fields": [\n            {\n              "type": {\n                "type": "record",\n                "name": "AuditStamp",\n                "namespace": "com.linkedin.common",\n                "fields": [\n                  {\n                    "type": "long",\n                    "name": "time",\n                    "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": "string",\n                    "name": "actor",\n                    "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "impersonator",\n                    "default": null,\n                    "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                  },\n                  {\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "message",\n                    "default": null,\n                    "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                  }\n                ],\n                "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n              },\n              "name": "created",\n              "doc": "Audit stamp containing who reported the field mapping and when"\n            },\n            {\n              "type": [\n                {\n                  "type": "enum",\n                  "symbolDocs": {\n                    "BLACKBOX": "Field transformation expressed as unknown black box function.",\n                    "IDENTITY": "Field transformation expressed as Identity function."\n                  },\n                  "name": "TransformationType",\n                  "namespace": "com.linkedin.common.fieldtransformer",\n                  "symbols": [\n                    "BLACKBOX",\n                    "IDENTITY"\n                  ],\n                  "doc": "Type of the transformation involved in generating destination fields from source fields."\n                },\n                {\n                  "type": "record",\n                  "name": "UDFTransformer",\n                  "namespace": "com.linkedin.common.fieldtransformer",\n                  "fields": [\n                    {\n                      "type": "string",\n                      "name": "udf",\n                      "doc": "A UDF mentioning how the source fields got transformed to destination field. This is the FQCN(Fully Qualified Class Name) of the udf."\n                    }\n                  ],\n                  "doc": "Field transformation expressed in UDF"\n                }\n              ],\n              "name": "transformation",\n              "doc": "Transfomration function between the fields involved"\n            },\n            {\n              "type": {\n                "type": "array",\n                "items": [\n                  "string"\n                ]\n              },\n              "name": "sourceFields",\n              "doc": "Source fields from which the fine grained lineage is derived"\n            },\n            {\n              "deprecated": "use SchemaFieldPath and represent as generic Urn instead",\n              "java": {\n                "class": "com.linkedin.common.urn.DatasetFieldUrn"\n              },\n              "type": "string",\n              "name": "destinationField",\n              "doc": "Destination field which is derived from source fields"\n            }\n          ],\n          "doc": "Representation of mapping between fields in source dataset to the field in destination dataset"\n        }\n      },\n      "name": "fieldMappings",\n      "doc": "Upstream to downstream field level lineage mappings"\n    }\n  ],\n  "doc": "Fine Grained upstream lineage for fields in a dataset"\n}\n'))),(0,t.yg)("h3",{id:"upstreamlineage"},"upstreamLineage"),(0,t.yg)("p",null,"Upstream lineage of a dataset"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "upstreamLineage"\n  },\n  "name": "UpstreamLineage",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "Upstream",\n          "namespace": "com.linkedin.dataset",\n          "fields": [\n            {\n              "type": {\n                "type": "record",\n                "name": "AuditStamp",\n                "namespace": "com.linkedin.common",\n                "fields": [\n                  {\n                    "type": "long",\n                    "name": "time",\n                    "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": "string",\n                    "name": "actor",\n                    "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "impersonator",\n                    "default": null,\n                    "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                  },\n                  {\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "message",\n                    "default": null,\n                    "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                  }\n                ],\n                "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n              },\n              "name": "auditStamp",\n              "default": {\n                "actor": "urn:li:corpuser:unknown",\n                "impersonator": null,\n                "time": 0,\n                "message": null\n              },\n              "doc": "Audit stamp containing who reported the lineage and when."\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "created",\n              "default": null,\n              "doc": "Audit stamp containing who created the lineage and when."\n            },\n            {\n              "Relationship": {\n                "createdActor": "upstreams/*/created/actor",\n                "createdOn": "upstreams/*/created/time",\n                "entityTypes": [\n                  "dataset"\n                ],\n                "isLineage": true,\n                "name": "DownstreamOf",\n                "properties": "upstreams/*/properties",\n                "updatedActor": "upstreams/*/auditStamp/actor",\n                "updatedOn": "upstreams/*/auditStamp/time",\n                "via": "upstreams/*/query"\n              },\n              "Searchable": {\n                "fieldName": "upstreams",\n                "fieldType": "URN",\n                "queryByDefault": false\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.DatasetUrn"\n              },\n              "type": "string",\n              "name": "dataset",\n              "doc": "The upstream dataset the lineage points to"\n            },\n            {\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "COPY": "Direct copy without modification",\n                  "TRANSFORMED": "Transformed data with modification (format or content change)",\n                  "VIEW": "Represents a view defined on the sources e.g. Hive view defined on underlying hive tables or a Hive table pointing to a HDFS dataset or DALI view defined on multiple sources"\n                },\n                "name": "DatasetLineageType",\n                "namespace": "com.linkedin.dataset",\n                "symbols": [\n                  "COPY",\n                  "TRANSFORMED",\n                  "VIEW"\n                ],\n                "doc": "The various types of supported dataset lineage"\n              },\n              "name": "type",\n              "doc": "The type of the lineage"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "map",\n                  "values": "string"\n                }\n              ],\n              "name": "properties",\n              "default": null,\n              "doc": "A generic properties bag that allows us to store specific information on this graph edge."\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "query",\n              "default": null,\n              "doc": "If the lineage is generated by a query, a reference to the query"\n            }\n          ],\n          "doc": "Upstream lineage information about a dataset including the source reporting the lineage"\n        }\n      },\n      "name": "upstreams",\n      "doc": "List of upstream dataset lineage information"\n    },\n    {\n      "Relationship": {\n        "/*/upstreams/*": {\n          "entityTypes": [\n            "dataset",\n            "schemaField"\n          ],\n          "name": "DownstreamOf"\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "FineGrainedLineage",\n            "namespace": "com.linkedin.dataset",\n            "fields": [\n              {\n                "type": {\n                  "type": "enum",\n                  "symbolDocs": {\n                    "DATASET": " Indicates that this lineage is originating from upstream dataset(s)",\n                    "FIELD_SET": " Indicates that this lineage is originating from upstream field(s)",\n                    "NONE": " Indicates that there is no upstream lineage i.e. the downstream field is not a derived field"\n                  },\n                  "name": "FineGrainedLineageUpstreamType",\n                  "namespace": "com.linkedin.dataset",\n                  "symbols": [\n                    "FIELD_SET",\n                    "DATASET",\n                    "NONE"\n                  ],\n                  "doc": "The type of upstream entity in a fine-grained lineage"\n                },\n                "name": "upstreamType",\n                "doc": "The type of upstream entity"\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "array",\n                    "items": "string"\n                  }\n                ],\n                "name": "upstreams",\n                "default": null,\n                "doc": "Upstream entities in the lineage"\n              },\n              {\n                "type": {\n                  "type": "enum",\n                  "symbolDocs": {\n                    "FIELD": " Indicates that the lineage is for a single, specific, downstream field",\n                    "FIELD_SET": " Indicates that the lineage is for a set of downstream fields"\n                  },\n                  "name": "FineGrainedLineageDownstreamType",\n                  "namespace": "com.linkedin.dataset",\n                  "symbols": [\n                    "FIELD",\n                    "FIELD_SET"\n                  ],\n                  "doc": "The type of downstream field(s) in a fine-grained lineage"\n                },\n                "name": "downstreamType",\n                "doc": "The type of downstream field(s)"\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "array",\n                    "items": "string"\n                  }\n                ],\n                "name": "downstreams",\n                "default": null,\n                "doc": "Downstream fields in the lineage"\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "transformOperation",\n                "default": null,\n                "doc": "The transform operation applied to the upstream entities to produce the downstream field(s)"\n              },\n              {\n                "type": "float",\n                "name": "confidenceScore",\n                "default": 1.0,\n                "doc": "The confidence in this lineage between 0 (low confidence) and 1 (high confidence)"\n              },\n              {\n                "java": {\n                  "class": "com.linkedin.common.urn.Urn"\n                },\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "query",\n                "default": null,\n                "doc": "The query that was used to generate this lineage. \\nPresent only if the lineage was generated from a detected query."\n              }\n            ],\n            "doc": "A fine-grained lineage from upstream fields/datasets to downstream field(s)"\n          }\n        }\n      ],\n      "name": "fineGrainedLineages",\n      "default": null,\n      "doc": " List of fine-grained lineage information, including field-level lineage"\n    }\n  ],\n  "doc": "Upstream lineage of a dataset"\n}\n'))),(0,t.yg)("h3",{id:"institutionalmemory"},"institutionalMemory"),(0,t.yg)("p",null,"Institutional memory of an entity. This is a way to link to relevant documentation and provide description of the documentation. Institutional or tribal knowledge is very important for users to leverage the entity."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "institutionalMemory"\n  },\n  "name": "InstitutionalMemory",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "InstitutionalMemoryMetadata",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.url.Url",\n                "coercerClass": "com.linkedin.common.url.UrlCoercer"\n              },\n              "type": "string",\n              "name": "url",\n              "doc": "Link to an engineering design document or a wiki page."\n            },\n            {\n              "type": "string",\n              "name": "description",\n              "doc": "Description of the link."\n            },\n            {\n              "type": {\n                "type": "record",\n                "name": "AuditStamp",\n                "namespace": "com.linkedin.common",\n                "fields": [\n                  {\n                    "type": "long",\n                    "name": "time",\n                    "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": "string",\n                    "name": "actor",\n                    "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "impersonator",\n                    "default": null,\n                    "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                  },\n                  {\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "message",\n                    "default": null,\n                    "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                  }\n                ],\n                "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n              },\n              "name": "createStamp",\n              "doc": "Audit stamp associated with creation of this record"\n            }\n          ],\n          "doc": "Metadata corresponding to a record of institutional memory."\n        }\n      },\n      "name": "elements",\n      "doc": "List of records that represent institutional memory of an entity. Each record consists of a link, description, creator and timestamps associated with that record."\n    }\n  ],\n  "doc": "Institutional memory of an entity. This is a way to link to relevant documentation and provide description of the documentation. Institutional or tribal knowledge is very important for users to leverage the entity."\n}\n'))),(0,t.yg)("h3",{id:"ownership-1"},"ownership"),(0,t.yg)("p",null,"Ownership information of an entity."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "ownership"\n  },\n  "name": "Ownership",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "Owner",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "corpuser",\n                  "corpGroup"\n                ],\n                "name": "OwnedBy"\n              },\n              "Searchable": {\n                "addToFilters": true,\n                "fieldName": "owners",\n                "fieldType": "URN",\n                "filterNameOverride": "Owned By",\n                "hasValuesFieldName": "hasOwners",\n                "queryByDefault": false\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "owner",\n              "doc": "Owner URN, e.g. urn:li:corpuser:ldap, urn:li:corpGroup:group_name, and urn:li:multiProduct:mp_name\\n(Caveat: only corpuser is currently supported in the frontend.)"\n            },\n            {\n              "deprecated": true,\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "BUSINESS_OWNER": "A person or group who is responsible for logical, or business related, aspects of the asset.",\n                  "CONSUMER": "A person, group, or service that consumes the data\\nDeprecated! Use TECHNICAL_OWNER or BUSINESS_OWNER instead.",\n                  "CUSTOM": "Set when ownership type is unknown or a when new one is specified as an ownership type entity for which we have no\\nenum value for. This is used for backwards compatibility",\n                  "DATAOWNER": "A person or group that is owning the data\\nDeprecated! Use TECHNICAL_OWNER instead.",\n                  "DATA_STEWARD": "A steward, expert, or delegate responsible for the asset.",\n                  "DELEGATE": "A person or a group that overseas the operation, e.g. a DBA or SRE.\\nDeprecated! Use TECHNICAL_OWNER instead.",\n                  "DEVELOPER": "A person or group that is in charge of developing the code\\nDeprecated! Use TECHNICAL_OWNER instead.",\n                  "NONE": "No specific type associated to the owner.",\n                  "PRODUCER": "A person, group, or service that produces/generates the data\\nDeprecated! Use TECHNICAL_OWNER instead.",\n                  "STAKEHOLDER": "A person or a group that has direct business interest\\nDeprecated! Use TECHNICAL_OWNER, BUSINESS_OWNER, or STEWARD instead.",\n                  "TECHNICAL_OWNER": "person or group who is responsible for technical aspects of the asset."\n                },\n                "deprecatedSymbols": {\n                  "CONSUMER": true,\n                  "DATAOWNER": true,\n                  "DELEGATE": true,\n                  "DEVELOPER": true,\n                  "PRODUCER": true,\n                  "STAKEHOLDER": true\n                },\n                "name": "OwnershipType",\n                "namespace": "com.linkedin.common",\n                "symbols": [\n                  "CUSTOM",\n                  "TECHNICAL_OWNER",\n                  "BUSINESS_OWNER",\n                  "DATA_STEWARD",\n                  "NONE",\n                  "DEVELOPER",\n                  "DATAOWNER",\n                  "DELEGATE",\n                  "PRODUCER",\n                  "CONSUMER",\n                  "STAKEHOLDER"\n                ],\n                "doc": "Asset owner types"\n              },\n              "name": "type",\n              "doc": "The type of the ownership"\n            },\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "ownershipType"\n                ],\n                "name": "ownershipType"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "typeUrn",\n              "default": null,\n              "doc": "The type of the ownership\\nUrn of type O"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "OwnershipSource",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "enum",\n                        "symbolDocs": {\n                          "AUDIT": "Auditing system or audit logs",\n                          "DATABASE": "Database, e.g. GRANTS table",\n                          "FILE_SYSTEM": "File system, e.g. file/directory owner",\n                          "ISSUE_TRACKING_SYSTEM": "Issue tracking system, e.g. Jira",\n                          "MANUAL": "Manually provided by a user",\n                          "OTHER": "Other sources",\n                          "SERVICE": "Other ownership-like service, e.g. Nuage, ACL service etc",\n                          "SOURCE_CONTROL": "SCM system, e.g. GIT, SVN"\n                        },\n                        "name": "OwnershipSourceType",\n                        "namespace": "com.linkedin.common",\n                        "symbols": [\n                          "AUDIT",\n                          "DATABASE",\n                          "FILE_SYSTEM",\n                          "ISSUE_TRACKING_SYSTEM",\n                          "MANUAL",\n                          "SERVICE",\n                          "SOURCE_CONTROL",\n                          "OTHER"\n                        ]\n                      },\n                      "name": "type",\n                      "doc": "The type of the source"\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "url",\n                      "default": null,\n                      "doc": "A reference URL for the source"\n                    }\n                  ],\n                  "doc": "Source/provider of the ownership information"\n                }\n              ],\n              "name": "source",\n              "default": null,\n              "doc": "Source information for the ownership"\n            }\n          ],\n          "doc": "Ownership information"\n        }\n      },\n      "name": "owners",\n      "doc": "List of owners of the entity."\n    },\n    {\n      "Searchable": {\n        "/*": {\n          "fieldType": "MAP_ARRAY",\n          "queryByDefault": false\n        }\n      },\n      "type": [\n        {\n          "type": "map",\n          "values": {\n            "type": "array",\n            "items": "string"\n          }\n        },\n        "null"\n      ],\n      "name": "ownerTypes",\n      "default": {},\n      "doc": "Ownership type to Owners map, populated via mutation hook."\n    },\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          },\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "message",\n            "default": null,\n            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "lastModified",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0,\n        "message": null\n      },\n      "doc": "Audit stamp containing who last modified the record and when. A value of 0 in the time field indicates missing data."\n    }\n  ],\n  "doc": "Ownership information of an entity."\n}\n'))),(0,t.yg)("h3",{id:"status"},"status"),(0,t.yg)("p",null,"The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\nThis aspect is used to represent soft deletes conventionally."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "status"\n  },\n  "name": "Status",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN"\n      },\n      "type": "boolean",\n      "name": "removed",\n      "default": false,\n      "doc": "Whether the entity has been removed (soft-deleted)."\n    }\n  ],\n  "doc": "The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\\nThis aspect is used to represent soft deletes conventionally."\n}\n'))),(0,t.yg)("h3",{id:"schemametadata"},"schemaMetadata"),(0,t.yg)("p",null,"SchemaMetadata to describe metadata related to store schema"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "schemaMetadata"\n  },\n  "name": "SchemaMetadata",\n  "namespace": "com.linkedin.schema",\n  "fields": [\n    {\n      "validate": {\n        "strlen": {\n          "max": 500,\n          "min": 1\n        }\n      },\n      "type": "string",\n      "name": "schemaName",\n      "doc": "Schema name e.g. PageViewEvent, identity.Profile, ams.account_management_tracking"\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.DataPlatformUrn"\n      },\n      "type": "string",\n      "name": "platform",\n      "doc": "Standardized platform urn where schema is defined. The data platform Urn (urn:li:platform:{platform_name})"\n    },\n    {\n      "type": "long",\n      "name": "version",\n      "doc": "Every change to SchemaMetadata in the resource results in a new version. Version is server assigned. This version is differ from platform native schema version."\n    },\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          },\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "message",\n            "default": null,\n            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "created",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0,\n        "message": null\n      },\n      "doc": "An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": "com.linkedin.common.AuditStamp",\n      "name": "lastModified",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0,\n        "message": null\n      },\n      "doc": "An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": [\n        "null",\n        "com.linkedin.common.AuditStamp"\n      ],\n      "name": "deleted",\n      "default": null,\n      "doc": "An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.DatasetUrn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "dataset",\n      "default": null,\n      "doc": "Dataset this schema metadata is associated with."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "cluster",\n      "default": null,\n      "doc": "The cluster this schema metadata resides from"\n    },\n    {\n      "type": "string",\n      "name": "hash",\n      "doc": "the SHA1 hash of the schema content"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "EspressoSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "documentSchema",\n              "doc": "The native espresso document schema."\n            },\n            {\n              "type": "string",\n              "name": "tableSchema",\n              "doc": "The espresso table schema definition."\n            }\n          ],\n          "doc": "Schema text of an espresso table schema."\n        },\n        {\n          "type": "record",\n          "name": "OracleDDL",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "tableSchema",\n              "doc": "The native schema in the dataset\'s platform. This is a human readable (json blob) table schema."\n            }\n          ],\n          "doc": "Schema holder for oracle data definition language that describes an oracle table."\n        },\n        {\n          "type": "record",\n          "name": "MySqlDDL",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "tableSchema",\n              "doc": "The native schema in the dataset\'s platform. This is a human readable (json blob) table schema."\n            }\n          ],\n          "doc": "Schema holder for MySql data definition language that describes an MySql table."\n        },\n        {\n          "type": "record",\n          "name": "PrestoDDL",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "rawSchema",\n              "doc": "The raw schema in the dataset\'s platform. This includes the DDL and the columns extracted from DDL."\n            }\n          ],\n          "doc": "Schema holder for presto data definition language that describes a presto view."\n        },\n        {\n          "type": "record",\n          "name": "KafkaSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "documentSchema",\n              "doc": "The native kafka document schema. This is a human readable avro document schema."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "documentSchemaType",\n              "default": null,\n              "doc": "The native kafka document schema type. This can be AVRO/PROTOBUF/JSON."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "keySchema",\n              "default": null,\n              "doc": "The native kafka key schema as retrieved from Schema Registry"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "keySchemaType",\n              "default": null,\n              "doc": "The native kafka key schema type. This can be AVRO/PROTOBUF/JSON."\n            }\n          ],\n          "doc": "Schema holder for kafka schema."\n        },\n        {\n          "type": "record",\n          "name": "BinaryJsonSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "schema",\n              "doc": "The native schema text for binary JSON file format."\n            }\n          ],\n          "doc": "Schema text of binary JSON schema."\n        },\n        {\n          "type": "record",\n          "name": "OrcSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "schema",\n              "doc": "The native schema for ORC file format."\n            }\n          ],\n          "doc": "Schema text of an ORC schema."\n        },\n        {\n          "type": "record",\n          "name": "Schemaless",\n          "namespace": "com.linkedin.schema",\n          "fields": [],\n          "doc": "The dataset has no specific schema associated with it"\n        },\n        {\n          "type": "record",\n          "name": "KeyValueSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "keySchema",\n              "doc": "The raw schema for the key in the key-value store."\n            },\n            {\n              "type": "string",\n              "name": "valueSchema",\n              "doc": "The raw schema for the value in the key-value store."\n            }\n          ],\n          "doc": "Schema text of a key-value store schema."\n        },\n        {\n          "type": "record",\n          "name": "OtherSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "rawSchema",\n              "doc": "The native schema in the dataset\'s platform."\n            }\n          ],\n          "doc": "Schema holder for undefined schema types."\n        }\n      ],\n      "name": "platformSchema",\n      "doc": "The native schema in the dataset\'s platform."\n    },\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "SchemaField",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "Searchable": {\n                "boostScore": 1.0,\n                "fieldName": "fieldPaths",\n                "fieldType": "TEXT",\n                "queryByDefault": "true"\n              },\n              "type": "string",\n              "name": "fieldPath",\n              "doc": "Flattened name of the field. Field is computed from jsonPath field."\n            },\n            {\n              "Deprecated": true,\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "jsonPath",\n              "default": null,\n              "doc": "Flattened name of a field in JSON Path notation."\n            },\n            {\n              "type": "boolean",\n              "name": "nullable",\n              "default": false,\n              "doc": "Indicates if this field is optional or nullable"\n            },\n            {\n              "Searchable": {\n                "boostScore": 0.1,\n                "fieldName": "fieldDescriptions",\n                "fieldType": "TEXT"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "description",\n              "default": null,\n              "doc": "Description"\n            },\n            {\n              "Deprecated": true,\n              "Searchable": {\n                "boostScore": 0.2,\n                "fieldName": "fieldLabels",\n                "fieldType": "TEXT"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "label",\n              "default": null,\n              "doc": "Label of the field. Provides a more human-readable name for the field than field path. Some sources will\\nprovide this metadata but not all sources have the concept of a label. If just one string is associated with\\na field in a source, that is most likely a description.\\n\\nNote that this field is deprecated and is not surfaced in the UI."\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "created",\n              "default": null,\n              "doc": "An AuditStamp corresponding to the creation of this schema field."\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "lastModified",\n              "default": null,\n              "doc": "An AuditStamp corresponding to the last modification of this schema field."\n            },\n            {\n              "type": {\n                "type": "record",\n                "name": "SchemaFieldDataType",\n                "namespace": "com.linkedin.schema",\n                "fields": [\n                  {\n                    "type": [\n                      {\n                        "type": "record",\n                        "name": "BooleanType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Boolean field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "FixedType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Fixed field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "StringType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "String field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "BytesType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Bytes field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "NumberType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Number data type: long, integer, short, etc.."\n                      },\n                      {\n                        "type": "record",\n                        "name": "DateType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Date field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "TimeType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Time field type. This should also be used for datetimes."\n                      },\n                      {\n                        "type": "record",\n                        "name": "EnumType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Enum field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "NullType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Null field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "MapType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "keyType",\n                            "default": null,\n                            "doc": "Key type in a map"\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "valueType",\n                            "default": null,\n                            "doc": "Type of the value in a map"\n                          }\n                        ],\n                        "doc": "Map field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "ArrayType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": [\n                              "null",\n                              {\n                                "type": "array",\n                                "items": "string"\n                              }\n                            ],\n                            "name": "nestedType",\n                            "default": null,\n                            "doc": "List of types this array holds."\n                          }\n                        ],\n                        "doc": "Array field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "UnionType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": [\n                              "null",\n                              {\n                                "type": "array",\n                                "items": "string"\n                              }\n                            ],\n                            "name": "nestedTypes",\n                            "default": null,\n                            "doc": "List of types in union type."\n                          }\n                        ],\n                        "doc": "Union field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "RecordType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Record field type."\n                      }\n                    ],\n                    "name": "type",\n                    "doc": "Data platform specific types"\n                  }\n                ],\n                "doc": "Schema field data types"\n              },\n              "name": "type",\n              "doc": "Platform independent field type of the field."\n            },\n            {\n              "type": "string",\n              "name": "nativeDataType",\n              "doc": "The native type of the field in the dataset\'s platform as declared by platform schema."\n            },\n            {\n              "type": "boolean",\n              "name": "recursive",\n              "default": false,\n              "doc": "There are use cases when a field in type B references type A. A field in A references field of type B. In such cases, we will mark the first field as recursive."\n            },\n            {\n              "Relationship": {\n                "/tags/*/tag": {\n                  "entityTypes": [\n                    "tag"\n                  ],\n                  "name": "SchemaFieldTaggedWith"\n                }\n              },\n              "Searchable": {\n                "/tags/*/attribution/actor": {\n                  "fieldName": "fieldTagAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/tags/*/attribution/source": {\n                  "fieldName": "fieldTagAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/tags/*/attribution/time": {\n                  "fieldName": "fieldTagAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                },\n                "/tags/*/tag": {\n                  "boostScore": 0.5,\n                  "fieldName": "fieldTags",\n                  "fieldType": "URN"\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "Aspect": {\n                    "name": "globalTags"\n                  },\n                  "name": "GlobalTags",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "Relationship": {\n                        "/*/tag": {\n                          "entityTypes": [\n                            "tag"\n                          ],\n                          "name": "TaggedWith"\n                        }\n                      },\n                      "Searchable": {\n                        "/*/tag": {\n                          "addToFilters": true,\n                          "boostScore": 0.5,\n                          "fieldName": "tags",\n                          "fieldType": "URN",\n                          "filterNameOverride": "Tag",\n                          "hasValuesFieldName": "hasTags",\n                          "queryByDefault": true\n                        }\n                      },\n                      "type": {\n                        "type": "array",\n                        "items": {\n                          "type": "record",\n                          "name": "TagAssociation",\n                          "namespace": "com.linkedin.common",\n                          "fields": [\n                            {\n                              "java": {\n                                "class": "com.linkedin.common.urn.TagUrn"\n                              },\n                              "type": "string",\n                              "name": "tag",\n                              "doc": "Urn of the applied tag"\n                            },\n                            {\n                              "type": [\n                                "null",\n                                "string"\n                              ],\n                              "name": "context",\n                              "default": null,\n                              "doc": "Additional context about the association"\n                            },\n                            {\n                              "Searchable": {\n                                "/actor": {\n                                  "fieldName": "tagAttributionActors",\n                                  "fieldType": "URN",\n                                  "queryByDefault": false\n                                },\n                                "/source": {\n                                  "fieldName": "tagAttributionSources",\n                                  "fieldType": "URN",\n                                  "queryByDefault": false\n                                },\n                                "/time": {\n                                  "fieldName": "tagAttributionDates",\n                                  "fieldType": "DATETIME",\n                                  "queryByDefault": false\n                                }\n                              },\n                              "type": [\n                                "null",\n                                {\n                                  "type": "record",\n                                  "name": "MetadataAttribution",\n                                  "namespace": "com.linkedin.common",\n                                  "fields": [\n                                    {\n                                      "type": "long",\n                                      "name": "time",\n                                      "doc": "When this metadata was updated."\n                                    },\n                                    {\n                                      "java": {\n                                        "class": "com.linkedin.common.urn.Urn"\n                                      },\n                                      "type": "string",\n                                      "name": "actor",\n                                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                                    },\n                                    {\n                                      "java": {\n                                        "class": "com.linkedin.common.urn.Urn"\n                                      },\n                                      "type": [\n                                        "null",\n                                        "string"\n                                      ],\n                                      "name": "source",\n                                      "default": null,\n                                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                                    },\n                                    {\n                                      "type": {\n                                        "type": "map",\n                                        "values": "string"\n                                      },\n                                      "name": "sourceDetail",\n                                      "default": {},\n                                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                                    }\n                                  ],\n                                  "doc": "Information about who, why, and how this metadata was applied"\n                                }\n                              ],\n                              "name": "attribution",\n                              "default": null,\n                              "doc": "Information about who, why, and how this metadata was applied"\n                            }\n                          ],\n                          "doc": "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\\npropagation parameters."\n                        }\n                      },\n                      "name": "tags",\n                      "doc": "Tags associated with a given entity"\n                    }\n                  ],\n                  "doc": "Tag aspect used for applying tags to an entity"\n                }\n              ],\n              "name": "globalTags",\n              "default": null,\n              "doc": "Tags associated with the field"\n            },\n            {\n              "Relationship": {\n                "/terms/*/urn": {\n                  "entityTypes": [\n                    "glossaryTerm"\n                  ],\n                  "name": "SchemaFieldWithGlossaryTerm"\n                }\n              },\n              "Searchable": {\n                "/terms/*/attribution/actor": {\n                  "fieldName": "fieldTermAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/terms/*/attribution/source": {\n                  "fieldName": "fieldTermAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/terms/*/attribution/time": {\n                  "fieldName": "fieldTermAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                },\n                "/terms/*/urn": {\n                  "boostScore": 0.5,\n                  "fieldName": "fieldGlossaryTerms",\n                  "fieldType": "URN"\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "Aspect": {\n                    "name": "glossaryTerms"\n                  },\n                  "name": "GlossaryTerms",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "array",\n                        "items": {\n                          "type": "record",\n                          "name": "GlossaryTermAssociation",\n                          "namespace": "com.linkedin.common",\n                          "fields": [\n                            {\n                              "Relationship": {\n                                "entityTypes": [\n                                  "glossaryTerm"\n                                ],\n                                "name": "TermedWith"\n                              },\n                              "Searchable": {\n                                "addToFilters": true,\n                                "fieldName": "glossaryTerms",\n                                "fieldType": "URN",\n                                "filterNameOverride": "Glossary Term",\n                                "hasValuesFieldName": "hasGlossaryTerms",\n                                "includeSystemModifiedAt": true,\n                                "systemModifiedAtFieldName": "termsModifiedAt"\n                              },\n                              "java": {\n                                "class": "com.linkedin.common.urn.GlossaryTermUrn"\n                              },\n                              "type": "string",\n                              "name": "urn",\n                              "doc": "Urn of the applied glossary term"\n                            },\n                            {\n                              "java": {\n                                "class": "com.linkedin.common.urn.Urn"\n                              },\n                              "type": [\n                                "null",\n                                "string"\n                              ],\n                              "name": "actor",\n                              "default": null,\n                              "doc": "The user URN which will be credited for adding associating this term to the entity"\n                            },\n                            {\n                              "type": [\n                                "null",\n                                "string"\n                              ],\n                              "name": "context",\n                              "default": null,\n                              "doc": "Additional context about the association"\n                            },\n                            {\n                              "Searchable": {\n                                "/actor": {\n                                  "fieldName": "termAttributionActors",\n                                  "fieldType": "URN",\n                                  "queryByDefault": false\n                                },\n                                "/source": {\n                                  "fieldName": "termAttributionSources",\n                                  "fieldType": "URN",\n                                  "queryByDefault": false\n                                },\n                                "/time": {\n                                  "fieldName": "termAttributionDates",\n                                  "fieldType": "DATETIME",\n                                  "queryByDefault": false\n                                }\n                              },\n                              "type": [\n                                "null",\n                                "com.linkedin.common.MetadataAttribution"\n                              ],\n                              "name": "attribution",\n                              "default": null,\n                              "doc": "Information about who, why, and how this metadata was applied"\n                            }\n                          ],\n                          "doc": "Properties of an applied glossary term."\n                        }\n                      },\n                      "name": "terms",\n                      "doc": "The related business terms"\n                    },\n                    {\n                      "type": "com.linkedin.common.AuditStamp",\n                      "name": "auditStamp",\n                      "doc": "Audit stamp containing who reported the related business term"\n                    }\n                  ],\n                  "doc": "Related business terms information"\n                }\n              ],\n              "name": "glossaryTerms",\n              "default": null,\n              "doc": "Glossary terms associated with the field"\n            },\n            {\n              "type": "boolean",\n              "name": "isPartOfKey",\n              "default": false,\n              "doc": "For schema fields that are part of complex keys, set this field to true\\nWe do this to easily distinguish between value and key fields"\n            },\n            {\n              "type": [\n                "null",\n                "boolean"\n              ],\n              "name": "isPartitioningKey",\n              "default": null,\n              "doc": "For Datasets which are partitioned, this determines the partitioning key.\\nNote that multiple columns can be part of a partitioning key, but currently we do not support\\nrendering the ordered partitioning key."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "jsonProps",\n              "default": null,\n              "doc": "For schema fields that have other properties that are not modeled explicitly,\\nuse this field to serialize those properties into a JSON string"\n            }\n          ],\n          "doc": "SchemaField to describe metadata related to dataset schema."\n        }\n      },\n      "name": "fields",\n      "doc": "Client provided a list of fields from document schema."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": "string"\n        }\n      ],\n      "name": "primaryKeys",\n      "default": null,\n      "doc": "Client provided list of fields that define primary keys to access record. Field order defines hierarchical espresso keys. Empty lists indicates absence of primary key access patter. Value is a SchemaField@fieldPath."\n    },\n    {\n      "deprecated": "Use foreignKeys instead.",\n      "type": [\n        "null",\n        {\n          "type": "map",\n          "values": {\n            "type": "record",\n            "name": "ForeignKeySpec",\n            "namespace": "com.linkedin.schema",\n            "fields": [\n              {\n                "type": [\n                  {\n                    "type": "record",\n                    "name": "DatasetFieldForeignKey",\n                    "namespace": "com.linkedin.schema",\n                    "fields": [\n                      {\n                        "java": {\n                          "class": "com.linkedin.common.urn.DatasetUrn"\n                        },\n                        "type": "string",\n                        "name": "parentDataset",\n                        "doc": "dataset that stores the resource."\n                      },\n                      {\n                        "type": {\n                          "type": "array",\n                          "items": "string"\n                        },\n                        "name": "currentFieldPaths",\n                        "doc": "List of fields in hosting(current) SchemaMetadata that conform a foreign key. List can contain a single entry or multiple entries if several entries in hosting schema conform a foreign key in a single parent dataset."\n                      },\n                      {\n                        "type": "string",\n                        "name": "parentField",\n                        "doc": "SchemaField@fieldPath that uniquely identify field in parent dataset that this field references."\n                      }\n                    ],\n                    "doc": "For non-urn based foregin keys."\n                  },\n                  {\n                    "type": "record",\n                    "name": "UrnForeignKey",\n                    "namespace": "com.linkedin.schema",\n                    "fields": [\n                      {\n                        "type": "string",\n                        "name": "currentFieldPath",\n                        "doc": "Field in hosting(current) SchemaMetadata."\n                      }\n                    ],\n                    "doc": "If SchemaMetadata fields make any external references and references are of type com.linkedin.common.Urn or any children, this models can be used to mark it."\n                  }\n                ],\n                "name": "foreignKey",\n                "doc": "Foreign key definition in metadata schema."\n              }\n            ],\n            "doc": "Description of a foreign key in a schema."\n          }\n        }\n      ],\n      "name": "foreignKeysSpecs",\n      "default": null,\n      "doc": "Map captures all the references schema makes to external datasets. Map key is ForeignKeySpecName typeref."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "ForeignKeyConstraint",\n            "namespace": "com.linkedin.schema",\n            "fields": [\n              {\n                "type": "string",\n                "name": "name",\n                "doc": "Name of the constraint, likely provided from the source"\n              },\n              {\n                "Relationship": {\n                  "/*": {\n                    "entityTypes": [\n                      "schemaField"\n                    ],\n                    "name": "ForeignKeyTo"\n                  }\n                },\n                "type": {\n                  "type": "array",\n                  "items": "string"\n                },\n                "name": "foreignFields",\n                "doc": "Fields the constraint maps to on the foreign dataset"\n              },\n              {\n                "type": {\n                  "type": "array",\n                  "items": "string"\n                },\n                "name": "sourceFields",\n                "doc": "Fields the constraint maps to on the source dataset"\n              },\n              {\n                "Relationship": {\n                  "entityTypes": [\n                    "dataset"\n                  ],\n                  "name": "ForeignKeyToDataset"\n                },\n                "java": {\n                  "class": "com.linkedin.common.urn.Urn"\n                },\n                "type": "string",\n                "name": "foreignDataset",\n                "doc": "Reference to the foreign dataset for ease of lookup"\n              }\n            ],\n            "doc": "Description of a foreign key constraint in a schema."\n          }\n        }\n      ],\n      "name": "foreignKeys",\n      "default": null,\n      "doc": "List of foreign key constraints for the schema"\n    }\n  ],\n  "doc": "SchemaMetadata to describe metadata related to store schema"\n}\n'))),(0,t.yg)("h3",{id:"editableschemametadata"},"editableSchemaMetadata"),(0,t.yg)("p",null,"EditableSchemaMetadata stores editable changes made to schema metadata. This separates changes made from\ningestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "editableSchemaMetadata"\n  },\n  "name": "EditableSchemaMetadata",\n  "namespace": "com.linkedin.schema",\n  "fields": [\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          },\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "message",\n            "default": null,\n            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "created",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0,\n        "message": null\n      },\n      "doc": "An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": "com.linkedin.common.AuditStamp",\n      "name": "lastModified",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0,\n        "message": null\n      },\n      "doc": "An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": [\n        "null",\n        "com.linkedin.common.AuditStamp"\n      ],\n      "name": "deleted",\n      "default": null,\n      "doc": "An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."\n    },\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "EditableSchemaFieldInfo",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "fieldPath",\n              "doc": "FieldPath uniquely identifying the SchemaField this metadata is associated with"\n            },\n            {\n              "Searchable": {\n                "boostScore": 0.1,\n                "fieldName": "editedFieldDescriptions",\n                "fieldType": "TEXT"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "description",\n              "default": null,\n              "doc": "Description"\n            },\n            {\n              "Relationship": {\n                "/tags/*/tag": {\n                  "entityTypes": [\n                    "tag"\n                  ],\n                  "name": "EditableSchemaFieldTaggedWith"\n                }\n              },\n              "Searchable": {\n                "/tags/*/attribution/actor": {\n                  "fieldName": "editedFieldTagAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/tags/*/attribution/source": {\n                  "fieldName": "editedFieldTagAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/tags/*/attribution/time": {\n                  "fieldName": "editedFieldTagAttributionDates",\n                  "fieldType": "DATETIME"\n                },\n                "/tags/*/tag": {\n                  "boostScore": 0.5,\n                  "fieldName": "editedFieldTags",\n                  "fieldType": "URN"\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "Aspect": {\n                    "name": "globalTags"\n                  },\n                  "name": "GlobalTags",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "Relationship": {\n                        "/*/tag": {\n                          "entityTypes": [\n                            "tag"\n                          ],\n                          "name": "TaggedWith"\n                        }\n                      },\n                      "Searchable": {\n                        "/*/tag": {\n                          "addToFilters": true,\n                          "boostScore": 0.5,\n                          "fieldName": "tags",\n                          "fieldType": "URN",\n                          "filterNameOverride": "Tag",\n                          "hasValuesFieldName": "hasTags",\n                          "queryByDefault": true\n                        }\n                      },\n                      "type": {\n                        "type": "array",\n                        "items": {\n                          "type": "record",\n                          "name": "TagAssociation",\n                          "namespace": "com.linkedin.common",\n                          "fields": [\n                            {\n                              "java": {\n                                "class": "com.linkedin.common.urn.TagUrn"\n                              },\n                              "type": "string",\n                              "name": "tag",\n                              "doc": "Urn of the applied tag"\n                            },\n                            {\n                              "type": [\n                                "null",\n                                "string"\n                              ],\n                              "name": "context",\n                              "default": null,\n                              "doc": "Additional context about the association"\n                            },\n                            {\n                              "Searchable": {\n                                "/actor": {\n                                  "fieldName": "tagAttributionActors",\n                                  "fieldType": "URN",\n                                  "queryByDefault": false\n                                },\n                                "/source": {\n                                  "fieldName": "tagAttributionSources",\n                                  "fieldType": "URN",\n                                  "queryByDefault": false\n                                },\n                                "/time": {\n                                  "fieldName": "tagAttributionDates",\n                                  "fieldType": "DATETIME",\n                                  "queryByDefault": false\n                                }\n                              },\n                              "type": [\n                                "null",\n                                {\n                                  "type": "record",\n                                  "name": "MetadataAttribution",\n                                  "namespace": "com.linkedin.common",\n                                  "fields": [\n                                    {\n                                      "type": "long",\n                                      "name": "time",\n                                      "doc": "When this metadata was updated."\n                                    },\n                                    {\n                                      "java": {\n                                        "class": "com.linkedin.common.urn.Urn"\n                                      },\n                                      "type": "string",\n                                      "name": "actor",\n                                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                                    },\n                                    {\n                                      "java": {\n                                        "class": "com.linkedin.common.urn.Urn"\n                                      },\n                                      "type": [\n                                        "null",\n                                        "string"\n                                      ],\n                                      "name": "source",\n                                      "default": null,\n                                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                                    },\n                                    {\n                                      "type": {\n                                        "type": "map",\n                                        "values": "string"\n                                      },\n                                      "name": "sourceDetail",\n                                      "default": {},\n                                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                                    }\n                                  ],\n                                  "doc": "Information about who, why, and how this metadata was applied"\n                                }\n                              ],\n                              "name": "attribution",\n                              "default": null,\n                              "doc": "Information about who, why, and how this metadata was applied"\n                            }\n                          ],\n                          "doc": "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\\npropagation parameters."\n                        }\n                      },\n                      "name": "tags",\n                      "doc": "Tags associated with a given entity"\n                    }\n                  ],\n                  "doc": "Tag aspect used for applying tags to an entity"\n                }\n              ],\n              "name": "globalTags",\n              "default": null,\n              "doc": "Tags associated with the field"\n            },\n            {\n              "Relationship": {\n                "/terms/*/urn": {\n                  "entityTypes": [\n                    "glossaryTerm"\n                  ],\n                  "name": "EditableSchemaFieldWithGlossaryTerm"\n                }\n              },\n              "Searchable": {\n                "/terms/*/attribution/actor": {\n                  "fieldName": "editedFieldTermAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/terms/*/attribution/source": {\n                  "fieldName": "editedFieldTermAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/terms/*/attribution/time": {\n                  "fieldName": "editedFieldTermAttributionDates",\n                  "fieldType": "DATETIME"\n                },\n                "/terms/*/urn": {\n                  "boostScore": 0.5,\n                  "fieldName": "editedFieldGlossaryTerms",\n                  "fieldType": "URN",\n                  "includeSystemModifiedAt": true,\n                  "systemModifiedAtFieldName": "schemaFieldTermsModifiedAt"\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "Aspect": {\n                    "name": "glossaryTerms"\n                  },\n                  "name": "GlossaryTerms",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "array",\n                        "items": {\n                          "type": "record",\n                          "name": "GlossaryTermAssociation",\n                          "namespace": "com.linkedin.common",\n                          "fields": [\n                            {\n                              "Relationship": {\n                                "entityTypes": [\n                                  "glossaryTerm"\n                                ],\n                                "name": "TermedWith"\n                              },\n                              "Searchable": {\n                                "addToFilters": true,\n                                "fieldName": "glossaryTerms",\n                                "fieldType": "URN",\n                                "filterNameOverride": "Glossary Term",\n                                "hasValuesFieldName": "hasGlossaryTerms",\n                                "includeSystemModifiedAt": true,\n                                "systemModifiedAtFieldName": "termsModifiedAt"\n                              },\n                              "java": {\n                                "class": "com.linkedin.common.urn.GlossaryTermUrn"\n                              },\n                              "type": "string",\n                              "name": "urn",\n                              "doc": "Urn of the applied glossary term"\n                            },\n                            {\n                              "java": {\n                                "class": "com.linkedin.common.urn.Urn"\n                              },\n                              "type": [\n                                "null",\n                                "string"\n                              ],\n                              "name": "actor",\n                              "default": null,\n                              "doc": "The user URN which will be credited for adding associating this term to the entity"\n                            },\n                            {\n                              "type": [\n                                "null",\n                                "string"\n                              ],\n                              "name": "context",\n                              "default": null,\n                              "doc": "Additional context about the association"\n                            },\n                            {\n                              "Searchable": {\n                                "/actor": {\n                                  "fieldName": "termAttributionActors",\n                                  "fieldType": "URN",\n                                  "queryByDefault": false\n                                },\n                                "/source": {\n                                  "fieldName": "termAttributionSources",\n                                  "fieldType": "URN",\n                                  "queryByDefault": false\n                                },\n                                "/time": {\n                                  "fieldName": "termAttributionDates",\n                                  "fieldType": "DATETIME",\n                                  "queryByDefault": false\n                                }\n                              },\n                              "type": [\n                                "null",\n                                "com.linkedin.common.MetadataAttribution"\n                              ],\n                              "name": "attribution",\n                              "default": null,\n                              "doc": "Information about who, why, and how this metadata was applied"\n                            }\n                          ],\n                          "doc": "Properties of an applied glossary term."\n                        }\n                      },\n                      "name": "terms",\n                      "doc": "The related business terms"\n                    },\n                    {\n                      "type": "com.linkedin.common.AuditStamp",\n                      "name": "auditStamp",\n                      "doc": "Audit stamp containing who reported the related business term"\n                    }\n                  ],\n                  "doc": "Related business terms information"\n                }\n              ],\n              "name": "glossaryTerms",\n              "default": null,\n              "doc": "Glossary terms associated with the field"\n            }\n          ],\n          "doc": "SchemaField to describe metadata related to dataset schema."\n        }\n      },\n      "name": "editableSchemaFieldInfo",\n      "doc": "Client provided a list of fields from document schema."\n    }\n  ],\n  "doc": "EditableSchemaMetadata stores editable changes made to schema metadata. This separates changes made from\\ningestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines."\n}\n'))),(0,t.yg)("h3",{id:"globaltags"},"globalTags"),(0,t.yg)("p",null,"Tag aspect used for applying tags to an entity"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "globalTags"\n  },\n  "name": "GlobalTags",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Relationship": {\n        "/*/tag": {\n          "entityTypes": [\n            "tag"\n          ],\n          "name": "TaggedWith"\n        }\n      },\n      "Searchable": {\n        "/*/tag": {\n          "addToFilters": true,\n          "boostScore": 0.5,\n          "fieldName": "tags",\n          "fieldType": "URN",\n          "filterNameOverride": "Tag",\n          "hasValuesFieldName": "hasTags",\n          "queryByDefault": true\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "TagAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.TagUrn"\n              },\n              "type": "string",\n              "name": "tag",\n              "doc": "Urn of the applied tag"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "context",\n              "default": null,\n              "doc": "Additional context about the association"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "tagAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "tagAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "tagAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ],\n          "doc": "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\\npropagation parameters."\n        }\n      },\n      "name": "tags",\n      "doc": "Tags associated with a given entity"\n    }\n  ],\n  "doc": "Tag aspect used for applying tags to an entity"\n}\n'))),(0,t.yg)("h3",{id:"glossaryterms"},"glossaryTerms"),(0,t.yg)("p",null,"Related business terms information"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "glossaryTerms"\n  },\n  "name": "GlossaryTerms",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "GlossaryTermAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "glossaryTerm"\n                ],\n                "name": "TermedWith"\n              },\n              "Searchable": {\n                "addToFilters": true,\n                "fieldName": "glossaryTerms",\n                "fieldType": "URN",\n                "filterNameOverride": "Glossary Term",\n                "hasValuesFieldName": "hasGlossaryTerms",\n                "includeSystemModifiedAt": true,\n                "systemModifiedAtFieldName": "termsModifiedAt"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.GlossaryTermUrn"\n              },\n              "type": "string",\n              "name": "urn",\n              "doc": "Urn of the applied glossary term"\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "actor",\n              "default": null,\n              "doc": "The user URN which will be credited for adding associating this term to the entity"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "context",\n              "default": null,\n              "doc": "Additional context about the association"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "termAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "termAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "termAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ],\n          "doc": "Properties of an applied glossary term."\n        }\n      },\n      "name": "terms",\n      "doc": "The related business terms"\n    },\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          },\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "message",\n            "default": null,\n            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "auditStamp",\n      "doc": "Audit stamp containing who reported the related business term"\n    }\n  ],\n  "doc": "Related business terms information"\n}\n'))),(0,t.yg)("h3",{id:"browsepaths"},"browsePaths"),(0,t.yg)("p",null,"Shared aspect containing Browse Paths to be indexed for an entity."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "browsePaths"\n  },\n  "name": "BrowsePaths",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "fieldName": "browsePaths",\n          "fieldType": "BROWSE_PATH"\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "paths",\n      "doc": "A list of valid browse paths for the entity.\\n\\nBrowse paths are expected to be forward slash-separated strings. For example: \'prod/snowflake/datasetName\'"\n    }\n  ],\n  "doc": "Shared aspect containing Browse Paths to be indexed for an entity."\n}\n'))),(0,t.yg)("h3",{id:"dataplatforminstance"},"dataPlatformInstance"),(0,t.yg)("p",null,"The specific instance of the data platform that this entity belongs to"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "dataPlatformInstance"\n  },\n  "name": "DataPlatformInstance",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldType": "URN",\n        "filterNameOverride": "Platform"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "platform",\n      "doc": "Data Platform"\n    },\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldName": "platformInstance",\n        "fieldType": "URN",\n        "filterNameOverride": "Platform Instance"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "instance",\n      "default": null,\n      "doc": "Instance of the data platform (e.g. db instance)"\n    }\n  ],\n  "doc": "The specific instance of the data platform that this entity belongs to"\n}\n'))),(0,t.yg)("h3",{id:"viewproperties"},"viewProperties"),(0,t.yg)("p",null,"Details about a View.\ne.g. Gets activated when subTypes is view"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "viewProperties"\n  },\n  "name": "ViewProperties",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN",\n        "weightsPerFieldValue": {\n          "true": 0.5\n        }\n      },\n      "type": "boolean",\n      "name": "materialized",\n      "doc": "Whether the view is materialized"\n    },\n    {\n      "type": "string",\n      "name": "viewLogic",\n      "doc": "The view logic"\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "formattedViewLogic",\n      "default": null,\n      "doc": "The formatted view logic. This is particularly used for SQL sources, where the SQL\\nlogic is formatted for better readability, and with dbt, where this contains the\\ncompiled SQL logic."\n    },\n    {\n      "type": "string",\n      "name": "viewLanguage",\n      "doc": "The view logic language / dialect"\n    }\n  ],\n  "doc": "Details about a View. \\ne.g. Gets activated when subTypes is view"\n}\n'))),(0,t.yg)("h3",{id:"browsepathsv2"},"browsePathsV2"),(0,t.yg)("p",null,"Shared aspect containing a Browse Path to be indexed for an entity."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "browsePathsV2"\n  },\n  "name": "BrowsePathsV2",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "/*/id": {\n          "fieldName": "browsePathV2",\n          "fieldType": "BROWSE_PATH_V2"\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "BrowsePathEntry",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "type": "string",\n              "name": "id",\n              "doc": "The ID of the browse path entry. This is what gets stored in the index.\\nIf there\'s an urn associated with this entry, id and urn will be the same"\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "urn",\n              "default": null,\n              "doc": "Optional urn pointing to some entity in DataHub"\n            }\n          ],\n          "doc": "Represents a single level in an entity\'s browsePathV2"\n        }\n      },\n      "name": "path",\n      "doc": "A valid browse path for the entity. This field is provided by DataHub by default.\\nThis aspect is a newer version of browsePaths where we can encode more information in the path.\\nThis path is also based on containers for a given entity if it has containers.\\n\\nThis is stored in elasticsearch as unit-separator delimited strings and only includes platform specific folders or containers.\\nThese paths should not include high level info captured elsewhere ie. Platform and Environment."\n    }\n  ],\n  "doc": "Shared aspect containing a Browse Path to be indexed for an entity."\n}\n'))),(0,t.yg)("h3",{id:"subtypes"},"subTypes"),(0,t.yg)("p",null,"Sub Types. Use this aspect to specialize a generic Entity\ne.g. Making a Dataset also be a View or also be a LookerExplore"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "subTypes"\n  },\n  "name": "SubTypes",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "addToFilters": true,\n          "fieldType": "KEYWORD",\n          "filterNameOverride": "Sub Type",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "typeNames",\n      "doc": "The names of the specific types."\n    }\n  ],\n  "doc": "Sub Types. Use this aspect to specialize a generic Entity\\ne.g. Making a Dataset also be a View or also be a LookerExplore"\n}\n'))),(0,t.yg)("h3",{id:"domains"},"domains"),(0,t.yg)("p",null,"Links from an Asset to its Domains"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "domains"\n  },\n  "name": "Domains",\n  "namespace": "com.linkedin.domain",\n  "fields": [\n    {\n      "Relationship": {\n        "/*": {\n          "entityTypes": [\n            "domain"\n          ],\n          "name": "AssociatedWith"\n        }\n      },\n      "Searchable": {\n        "/*": {\n          "addToFilters": true,\n          "fieldName": "domains",\n          "fieldType": "URN",\n          "filterNameOverride": "Domain",\n          "hasValuesFieldName": "hasDomain"\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "domains",\n      "doc": "The Domains attached to an Asset"\n    }\n  ],\n  "doc": "Links from an Asset to its Domains"\n}\n'))),(0,t.yg)("h3",{id:"container"},"container"),(0,t.yg)("p",null,"Link from an asset to its parent container"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "container"\n  },\n  "name": "Container",\n  "namespace": "com.linkedin.container",\n  "fields": [\n    {\n      "Relationship": {\n        "entityTypes": [\n          "container"\n        ],\n        "name": "IsPartOf"\n      },\n      "Searchable": {\n        "addToFilters": true,\n        "fieldName": "container",\n        "fieldType": "URN",\n        "filterNameOverride": "Container",\n        "hasValuesFieldName": "hasContainer"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "container",\n      "doc": "The parent container of an asset"\n    }\n  ],\n  "doc": "Link from an asset to its parent container"\n}\n'))),(0,t.yg)("h3",{id:"deprecation"},"deprecation"),(0,t.yg)("p",null,"Deprecation status of an entity"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "deprecation"\n  },\n  "name": "Deprecation",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldType": "BOOLEAN",\n        "filterNameOverride": "Deprecated",\n        "weightsPerFieldValue": {\n          "true": 0.5\n        }\n      },\n      "type": "boolean",\n      "name": "deprecated",\n      "doc": "Whether the entity is deprecated."\n    },\n    {\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "decommissionTime",\n      "default": null,\n      "doc": "The time user plan to decommission this entity."\n    },\n    {\n      "type": "string",\n      "name": "note",\n      "doc": "Additional information about the entity deprecation plan, such as the wiki, doc, RB."\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "actor",\n      "doc": "The user URN which will be credited for modifying this deprecation content."\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "replacement",\n      "default": null\n    }\n  ],\n  "doc": "Deprecation status of an entity"\n}\n'))),(0,t.yg)("h3",{id:"testresults"},"testResults"),(0,t.yg)("p",null,"Information about a Test Result"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "testResults"\n  },\n  "name": "TestResults",\n  "namespace": "com.linkedin.test",\n  "fields": [\n    {\n      "Relationship": {\n        "/*/test": {\n          "entityTypes": [\n            "test"\n          ],\n          "name": "IsFailing"\n        }\n      },\n      "Searchable": {\n        "/*/test": {\n          "fieldName": "failingTests",\n          "fieldType": "URN",\n          "hasValuesFieldName": "hasFailingTests",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "TestResult",\n          "namespace": "com.linkedin.test",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "test",\n              "doc": "The urn of the test"\n            },\n            {\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "FAILURE": " The Test Failed",\n                  "SUCCESS": " The Test Succeeded"\n                },\n                "name": "TestResultType",\n                "namespace": "com.linkedin.test",\n                "symbols": [\n                  "SUCCESS",\n                  "FAILURE"\n                ]\n              },\n              "name": "type",\n              "doc": "The type of the result"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "testDefinitionMd5",\n              "default": null,\n              "doc": "The md5 of the test definition that was used to compute this result.\\nSee TestInfo.testDefinition.md5 for more information."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "AuditStamp",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "impersonator",\n                      "default": null,\n                      "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "message",\n                      "default": null,\n                      "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                    }\n                  ],\n                  "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n                }\n              ],\n              "name": "lastComputed",\n              "default": null,\n              "doc": "The audit stamp of when the result was computed, including the actor who computed it."\n            }\n          ],\n          "doc": "Information about a Test Result"\n        }\n      },\n      "name": "failing",\n      "doc": "Results that are failing"\n    },\n    {\n      "Relationship": {\n        "/*/test": {\n          "entityTypes": [\n            "test"\n          ],\n          "name": "IsPassing"\n        }\n      },\n      "Searchable": {\n        "/*/test": {\n          "fieldName": "passingTests",\n          "fieldType": "URN",\n          "hasValuesFieldName": "hasPassingTests",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "com.linkedin.test.TestResult"\n      },\n      "name": "passing",\n      "doc": "Results that are passing"\n    }\n  ],\n  "doc": "Information about a Test Result"\n}\n'))),(0,t.yg)("h3",{id:"siblings"},"siblings"),(0,t.yg)("p",null,"Siblings information of an entity."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "siblings"\n  },\n  "name": "Siblings",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Relationship": {\n        "/*": {\n          "entityTypes": [\n            "dataset"\n          ],\n          "name": "SiblingOf"\n        }\n      },\n      "Searchable": {\n        "/*": {\n          "addHasValuesToFilters": true,\n          "fieldName": "siblings",\n          "fieldType": "URN",\n          "hasValuesFieldName": "hasSiblings",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "siblings",\n      "doc": "List of sibling entities"\n    },\n    {\n      "type": "boolean",\n      "name": "primary",\n      "doc": "If this is the leader entity of the set of siblings"\n    }\n  ],\n  "doc": "Siblings information of an entity."\n}\n'))),(0,t.yg)("h3",{id:"embed"},"embed"),(0,t.yg)("p",null,"Information regarding rendering an embed for an asset."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "embed"\n  },\n  "name": "Embed",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "renderUrl",\n      "default": null,\n      "doc": "An embed URL to be rendered inside of an iframe."\n    }\n  ],\n  "doc": "Information regarding rendering an embed for an asset."\n}\n'))),(0,t.yg)("h3",{id:"incidentssummary"},"incidentsSummary"),(0,t.yg)("p",null,"Summary related incidents on an entity."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "incidentsSummary"\n  },\n  "name": "IncidentsSummary",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "deprecated": true,\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "resolvedIncidents",\n      "default": [],\n      "doc": "Resolved incidents for an asset\\nDeprecated! Use the richer resolvedIncidentsDetails instead."\n    },\n    {\n      "deprecated": true,\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "activeIncidents",\n      "default": [],\n      "doc": "Active incidents for an asset\\nDeprecated! Use the richer activeIncidentsDetails instead."\n    },\n    {\n      "Relationship": {\n        "/*/urn": {\n          "entityTypes": [\n            "incident"\n          ],\n          "name": "ResolvedIncidents"\n        }\n      },\n      "Searchable": {\n        "/*/createdAt": {\n          "fieldName": "resolvedIncidentCreatedTimes",\n          "fieldType": "DATETIME"\n        },\n        "/*/priority": {\n          "fieldName": "resolvedIncidentPriorities",\n          "fieldType": "COUNT"\n        },\n        "/*/resolvedAt": {\n          "fieldName": "resolvedIncidentResolvedTimes",\n          "fieldType": "DATETIME"\n        },\n        "/*/type": {\n          "fieldName": "resolvedIncidentTypes",\n          "fieldType": "KEYWORD"\n        },\n        "/*/urn": {\n          "fieldName": "resolvedIncidents",\n          "fieldType": "URN",\n          "hasValuesFieldName": "hasResolvedIncidents",\n          "numValuesFieldName": "numResolvedIncidents",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "IncidentSummaryDetails",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "urn",\n              "doc": "The urn of the incident"\n            },\n            {\n              "type": "string",\n              "name": "type",\n              "doc": "The type of an incident"\n            },\n            {\n              "type": "long",\n              "name": "createdAt",\n              "doc": "The time at which the incident was raised in milliseconds since epoch."\n            },\n            {\n              "type": [\n                "null",\n                "long"\n              ],\n              "name": "resolvedAt",\n              "default": null,\n              "doc": "The time at which the incident was marked as resolved in milliseconds since epoch. Null if the incident is still active."\n            },\n            {\n              "type": [\n                "null",\n                "int"\n              ],\n              "name": "priority",\n              "default": null,\n              "doc": "The priority of the incident"\n            }\n          ],\n          "doc": "Summary statistics about incidents on an entity."\n        }\n      },\n      "name": "resolvedIncidentDetails",\n      "default": [],\n      "doc": "Summary details about the set of resolved incidents"\n    },\n    {\n      "Relationship": {\n        "/*/urn": {\n          "entityTypes": [\n            "incident"\n          ],\n          "name": "ActiveIncidents"\n        }\n      },\n      "Searchable": {\n        "/*/createdAt": {\n          "fieldName": "activeIncidentCreatedTimes",\n          "fieldType": "DATETIME"\n        },\n        "/*/priority": {\n          "fieldName": "activeIncidentPriorities",\n          "fieldType": "COUNT"\n        },\n        "/*/type": {\n          "fieldName": "activeIncidentTypes",\n          "fieldType": "KEYWORD"\n        },\n        "/*/urn": {\n          "addHasValuesToFilters": true,\n          "fieldName": "activeIncidents",\n          "fieldType": "URN",\n          "hasValuesFieldName": "hasActiveIncidents",\n          "numValuesFieldName": "numActiveIncidents",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "com.linkedin.common.IncidentSummaryDetails"\n      },\n      "name": "activeIncidentDetails",\n      "default": [],\n      "doc": "Summary details about the set of active incidents"\n    }\n  ],\n  "doc": "Summary related incidents on an entity."\n}\n'))),(0,t.yg)("h3",{id:"access"},"access"),(0,t.yg)("p",null,"Aspect used for associating roles to a dataset or any asset"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "access"\n  },\n  "name": "Access",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "RoleAssociation",\n            "namespace": "com.linkedin.common",\n            "fields": [\n              {\n                "Relationship": {\n                  "entityTypes": [\n                    "role"\n                  ],\n                  "name": "AssociatedWith"\n                },\n                "Searchable": {\n                  "addToFilters": true,\n                  "fieldName": "roles",\n                  "fieldType": "URN",\n                  "filterNameOverride": "Role",\n                  "hasValuesFieldName": "hasRoles",\n                  "queryByDefault": false\n                },\n                "java": {\n                  "class": "com.linkedin.common.urn.Urn"\n                },\n                "type": "string",\n                "name": "urn",\n                "doc": "Urn of the External Role"\n              }\n            ],\n            "doc": "Properties of an applied Role. For now, just an Urn"\n          }\n        }\n      ],\n      "name": "roles",\n      "default": null,\n      "doc": "List of Roles which needs to be associated"\n    }\n  ],\n  "doc": "Aspect used for associating roles to a dataset or any asset"\n}\n'))),(0,t.yg)("h3",{id:"structuredproperties"},"structuredProperties"),(0,t.yg)("p",null,"Properties about an entity governed by StructuredPropertyDefinition"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "structuredProperties"\n  },\n  "name": "StructuredProperties",\n  "namespace": "com.linkedin.structured",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "StructuredPropertyValueAssignment",\n          "namespace": "com.linkedin.structured",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "propertyUrn",\n              "doc": "The property that is being assigned a value."\n            },\n            {\n              "type": {\n                "type": "array",\n                "items": [\n                  "string",\n                  "double"\n                ]\n              },\n              "name": "values",\n              "doc": "The value assigned to the property."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "AuditStamp",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "impersonator",\n                      "default": null,\n                      "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "message",\n                      "default": null,\n                      "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                    }\n                  ],\n                  "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n                }\n              ],\n              "name": "created",\n              "default": null,\n              "doc": "Audit stamp containing who created this relationship edge and when"\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "lastModified",\n              "default": null,\n              "doc": "Audit stamp containing who last modified this relationship edge and when"\n            }\n          ]\n        }\n      },\n      "name": "properties",\n      "doc": "Custom property bag."\n    }\n  ],\n  "doc": "Properties about an entity governed by StructuredPropertyDefinition"\n}\n'))),(0,t.yg)("h3",{id:"forms"},"forms"),(0,t.yg)("p",null,"Forms that are assigned to this entity to be filled out"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "forms"\n  },\n  "name": "Forms",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "/*/completedPrompts/*/id": {\n          "fieldName": "incompleteFormsCompletedPromptIds",\n          "fieldType": "KEYWORD",\n          "queryByDefault": false\n        },\n        "/*/completedPrompts/*/lastModified/time": {\n          "fieldName": "incompleteFormsCompletedPromptResponseTimes",\n          "fieldType": "DATETIME",\n          "queryByDefault": false\n        },\n        "/*/incompletePrompts/*/id": {\n          "fieldName": "incompleteFormsIncompletePromptIds",\n          "fieldType": "KEYWORD",\n          "queryByDefault": false\n        },\n        "/*/urn": {\n          "fieldName": "incompleteForms",\n          "fieldType": "URN",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "FormAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "urn",\n              "doc": "Urn of the applied form"\n            },\n            {\n              "type": {\n                "type": "array",\n                "items": {\n                  "type": "record",\n                  "name": "FormPromptAssociation",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "string",\n                      "name": "id",\n                      "doc": "The id for the prompt. This must be GLOBALLY UNIQUE."\n                    },\n                    {\n                      "type": {\n                        "type": "record",\n                        "name": "AuditStamp",\n                        "namespace": "com.linkedin.common",\n                        "fields": [\n                          {\n                            "type": "long",\n                            "name": "time",\n                            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                          },\n                          {\n                            "java": {\n                              "class": "com.linkedin.common.urn.Urn"\n                            },\n                            "type": "string",\n                            "name": "actor",\n                            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                          },\n                          {\n                            "java": {\n                              "class": "com.linkedin.common.urn.Urn"\n                            },\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "impersonator",\n                            "default": null,\n                            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "message",\n                            "default": null,\n                            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                          }\n                        ],\n                        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n                      },\n                      "name": "lastModified",\n                      "doc": "The last time this prompt was touched for the entity (set, unset)"\n                    },\n                    {\n                      "type": [\n                        "null",\n                        {\n                          "type": "record",\n                          "name": "FormPromptFieldAssociations",\n                          "namespace": "com.linkedin.common",\n                          "fields": [\n                            {\n                              "type": [\n                                "null",\n                                {\n                                  "type": "array",\n                                  "items": {\n                                    "type": "record",\n                                    "name": "FieldFormPromptAssociation",\n                                    "namespace": "com.linkedin.common",\n                                    "fields": [\n                                      {\n                                        "type": "string",\n                                        "name": "fieldPath",\n                                        "doc": "The field path on a schema field."\n                                      },\n                                      {\n                                        "type": "com.linkedin.common.AuditStamp",\n                                        "name": "lastModified",\n                                        "doc": "The last time this prompt was touched for the field on the entity (set, unset)"\n                                      }\n                                    ],\n                                    "doc": "Information about the status of a particular prompt for a specific schema field\\non an entity."\n                                  }\n                                }\n                              ],\n                              "name": "completedFieldPrompts",\n                              "default": null,\n                              "doc": "A list of field-level prompt associations that are not yet complete for this form."\n                            },\n                            {\n                              "type": [\n                                "null",\n                                {\n                                  "type": "array",\n                                  "items": "com.linkedin.common.FieldFormPromptAssociation"\n                                }\n                              ],\n                              "name": "incompleteFieldPrompts",\n                              "default": null,\n                              "doc": "A list of field-level prompt associations that are complete for this form."\n                            }\n                          ],\n                          "doc": "Information about the field-level prompt associations on a top-level prompt association."\n                        }\n                      ],\n                      "name": "fieldAssociations",\n                      "default": null,\n                      "doc": "Optional information about the field-level prompt associations."\n                    }\n                  ],\n                  "doc": "Information about the status of a particular prompt.\\nNote that this is where we can add additional information about individual responses:\\nactor, timestamp, and the response itself."\n                }\n              },\n              "name": "incompletePrompts",\n              "default": [],\n              "doc": "A list of prompts that are not yet complete for this form."\n            },\n            {\n              "type": {\n                "type": "array",\n                "items": "com.linkedin.common.FormPromptAssociation"\n              },\n              "name": "completedPrompts",\n              "default": [],\n              "doc": "A list of prompts that have been completed for this form."\n            }\n          ],\n          "doc": "Properties of an applied form."\n        }\n      },\n      "name": "incompleteForms",\n      "doc": "All incomplete forms assigned to the entity."\n    },\n    {\n      "Searchable": {\n        "/*/completedPrompts/*/id": {\n          "fieldName": "completedFormsCompletedPromptIds",\n          "fieldType": "KEYWORD",\n          "queryByDefault": false\n        },\n        "/*/completedPrompts/*/lastModified/time": {\n          "fieldName": "completedFormsCompletedPromptResponseTimes",\n          "fieldType": "DATETIME",\n          "queryByDefault": false\n        },\n        "/*/incompletePrompts/*/id": {\n          "fieldName": "completedFormsIncompletePromptIds",\n          "fieldType": "KEYWORD",\n          "queryByDefault": false\n        },\n        "/*/urn": {\n          "fieldName": "completedForms",\n          "fieldType": "URN",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "com.linkedin.common.FormAssociation"\n      },\n      "name": "completedForms",\n      "doc": "All complete forms assigned to the entity."\n    },\n    {\n      "Searchable": {\n        "/*/form": {\n          "fieldName": "verifiedForms",\n          "fieldType": "URN",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "FormVerificationAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "form",\n              "doc": "The urn of the form that granted this verification."\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "lastModified",\n              "default": null,\n              "doc": "An audit stamp capturing who and when verification was applied for this form."\n            }\n          ],\n          "doc": "An association between a verification and an entity that has been granted\\nvia completion of one or more forms of type \'VERIFICATION\'."\n        }\n      },\n      "name": "verifications",\n      "default": [],\n      "doc": "Verifications that have been applied to the entity via completed forms."\n    }\n  ],\n  "doc": "Forms that are assigned to this entity to be filled out"\n}\n'))),(0,t.yg)("h3",{id:"partitionssummary"},"partitionsSummary"),(0,t.yg)("p",null,"Defines how the data is partitioned for Data Lake tables (e.g. Hive, S3, Iceberg, Delta, Hudi, etc)."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "partitionsSummary"\n  },\n  "name": "PartitionsSummary",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "PartitionSummary",\n          "namespace": "com.linkedin.dataset",\n          "fields": [\n            {\n              "type": "string",\n              "name": "partition",\n              "doc": "A unique id / value for the partition for which statistics were collected,\\ngenerated by applying the key definition to a given row."\n            },\n            {\n              "type": [\n                "null",\n                "long"\n              ],\n              "name": "createdTime",\n              "default": null,\n              "doc": "The created time for a given partition."\n            },\n            {\n              "type": [\n                "null",\n                "long"\n              ],\n              "name": "lastModifiedTime",\n              "default": null,\n              "doc": "The last modified / touched time for a given partition."\n            }\n          ],\n          "doc": "Defines how the data is partitioned"\n        }\n      ],\n      "name": "minPartition",\n      "default": null,\n      "doc": "The minimum partition as ordered"\n    },\n    {\n      "type": [\n        "null",\n        "com.linkedin.dataset.PartitionSummary"\n      ],\n      "name": "maxPartition",\n      "default": null,\n      "doc": "The maximum partition as ordered"\n    }\n  ],\n  "doc": "Defines how the data is partitioned for Data Lake tables (e.g. Hive, S3, Iceberg, Delta, Hudi, etc)."\n}\n'))),(0,t.yg)("h3",{id:"versionproperties"},"versionProperties"),(0,t.yg)("p",null,"Properties about a versioned asset i.e. dataset, ML Model, etc."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "versionProperties"\n  },\n  "name": "VersionProperties",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Relationship": {\n        "entityTypes": [\n          "versionSet"\n        ],\n        "name": "VersionOf"\n      },\n      "Searchable": {\n        "queryByDefault": false\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "versionSet",\n      "doc": "The linked Version Set entity that ties multiple versioned assets together"\n    },\n    {\n      "Searchable": {\n        "/versionTag": {\n          "fieldName": "version",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "record",\n        "name": "VersionTag",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "versionTag",\n            "default": null\n          },\n          {\n            "type": [\n              "null",\n              {\n                "type": "record",\n                "name": "MetadataAttribution",\n                "namespace": "com.linkedin.common",\n                "fields": [\n                  {\n                    "type": "long",\n                    "name": "time",\n                    "doc": "When this metadata was updated."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": "string",\n                    "name": "actor",\n                    "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "source",\n                    "default": null,\n                    "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                  },\n                  {\n                    "type": {\n                      "type": "map",\n                      "values": "string"\n                    },\n                    "name": "sourceDetail",\n                    "default": {},\n                    "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                  }\n                ],\n                "doc": "Information about who, why, and how this metadata was applied"\n              }\n            ],\n            "name": "metadataAttribution",\n            "default": null\n          }\n        ],\n        "doc": "A resource-defined string representing the resource state for the purpose of concurrency control"\n      },\n      "name": "version",\n      "doc": "Label for this versioned asset, is unique within a version set"\n    },\n    {\n      "Searchable": {\n        "/*/versionTag": {\n          "fieldName": "aliases",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "com.linkedin.common.VersionTag"\n      },\n      "name": "aliases",\n      "default": [],\n      "doc": "Associated aliases for this versioned asset"\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "comment",\n      "default": null,\n      "doc": "Comment documenting what this version was created for, changes, or represents"\n    },\n    {\n      "Searchable": {\n        "fieldName": "versionSortId",\n        "queryByDefault": false\n      },\n      "type": "string",\n      "name": "sortId",\n      "doc": "Sort identifier that determines where a version lives in the order of the Version Set.\\nWhat this looks like depends on the Version Scheme. For sort ids generated by DataHub we use an 8 character string representation."\n    },\n    {\n      "type": {\n        "type": "enum",\n        "symbolDocs": {\n          "ALPHANUMERIC_GENERATED_BY_DATAHUB": "String managed by DataHub. Currently, an 8 character alphabetical string.",\n          "LEXICOGRAPHIC_STRING": "String sorted lexicographically."\n        },\n        "name": "VersioningScheme",\n        "namespace": "com.linkedin.versionset",\n        "symbols": [\n          "LEXICOGRAPHIC_STRING",\n          "ALPHANUMERIC_GENERATED_BY_DATAHUB"\n        ]\n      },\n      "name": "versioningScheme",\n      "default": "LEXICOGRAPHIC_STRING",\n      "doc": "What versioning scheme `sortId` belongs to.\\nDefaults to a plain string that is lexicographically sorted."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "AuditStamp",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "type": "long",\n              "name": "time",\n              "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "actor",\n              "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "impersonator",\n              "default": null,\n              "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "message",\n              "default": null,\n              "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n            }\n          ],\n          "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n        }\n      ],\n      "name": "sourceCreatedTimestamp",\n      "default": null,\n      "doc": "Timestamp reflecting when this asset version was created in the source system."\n    },\n    {\n      "type": [\n        "null",\n        "com.linkedin.common.AuditStamp"\n      ],\n      "name": "metadataCreatedTimestamp",\n      "default": null,\n      "doc": "Timestamp reflecting when the metadata for this version was created in DataHub"\n    },\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN",\n        "queryByDefault": false\n      },\n      "type": [\n        "null",\n        "boolean"\n      ],\n      "name": "isLatest",\n      "default": null,\n      "doc": "Marks whether this version is currently the latest. Set by a side effect and should not be modified by API."\n    }\n  ],\n  "doc": "Properties about a versioned asset i.e. dataset, ML Model, etc."\n}\n'))),(0,t.yg)("h3",{id:"icebergcataloginfo"},"icebergCatalogInfo"),(0,t.yg)("p",null,"Iceberg Catalog metadata associated with an Iceberg table/view"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "icebergCatalogInfo"\n  },\n  "name": "IcebergCatalogInfo",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "metadataPointer",\n      "default": null,\n      "doc": "When Datahub is the REST Catalog for an Iceberg Table, stores the current metadata pointer.\\nIf the Iceberg table is managed by an external catalog, the metadata pointer is not set."\n    },\n    {\n      "type": [\n        "null",\n        "boolean"\n      ],\n      "name": "view",\n      "default": null\n    }\n  ],\n  "doc": "Iceberg Catalog metadata associated with an Iceberg table/view"\n}\n'))),(0,t.yg)("h3",{id:"datasetprofile-timeseries"},"datasetProfile (Timeseries)"),(0,t.yg)("p",null,"Stats corresponding to datasets"),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetProfile",\n    "type": "timeseries"\n  },\n  "name": "DatasetProfile",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": "long",\n      "name": "timestampMillis",\n      "doc": "The event timestamp field as epoch at UTC in milli seconds."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "TimeWindowSize",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "CalendarInterval",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "SECOND",\n                  "MINUTE",\n                  "HOUR",\n                  "DAY",\n                  "WEEK",\n                  "MONTH",\n                  "QUARTER",\n                  "YEAR"\n                ]\n              },\n              "name": "unit",\n              "doc": "Interval unit such as minute/hour/day etc."\n            },\n            {\n              "type": "int",\n              "name": "multiple",\n              "default": 1,\n              "doc": "How many units. Defaults to 1."\n            }\n          ],\n          "doc": "Defines the size of a time window."\n        }\n      ],\n      "name": "eventGranularity",\n      "default": null,\n      "doc": "Granularity of the event if applicable"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "PartitionSpec",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "TimeseriesField": {},\n              "type": "string",\n              "name": "partition",\n              "doc": "A unique id / value for the partition for which statistics were collected,\\ngenerated by applying the key definition to a given row."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "TimeWindow",\n                  "namespace": "com.linkedin.timeseries",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "startTimeMillis",\n                      "doc": "Start time as epoch at UTC."\n                    },\n                    {\n                      "type": "com.linkedin.timeseries.TimeWindowSize",\n                      "name": "length",\n                      "doc": "The length of the window."\n                    }\n                  ]\n                }\n              ],\n              "name": "timePartition",\n              "default": null,\n              "doc": "Time window of the partition, if we are able to extract it from the partition key."\n            },\n            {\n              "deprecated": true,\n              "type": {\n                "type": "enum",\n                "name": "PartitionType",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "FULL_TABLE",\n                  "QUERY",\n                  "PARTITION"\n                ]\n              },\n              "name": "type",\n              "default": "PARTITION",\n              "doc": "Unused!"\n            }\n          ],\n          "doc": "A reference to a specific partition in a dataset."\n        },\n        "null"\n      ],\n      "name": "partitionSpec",\n      "default": {\n        "partition": "FULL_TABLE_SNAPSHOT",\n        "type": "FULL_TABLE",\n        "timePartition": null\n      },\n      "doc": "The optional partition specification."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "messageId",\n      "default": null,\n      "doc": "The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."\n    },\n    {\n      "Searchable": {\n        "fieldType": "COUNT",\n        "hasValuesFieldName": "hasRowCount"\n      },\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "rowCount",\n      "default": null,\n      "doc": "The total number of rows"\n    },\n    {\n      "Searchable": {\n        "fieldType": "COUNT",\n        "hasValuesFieldName": "hasColumnCount"\n      },\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "columnCount",\n      "default": null,\n      "doc": "The total number of columns (or schema fields)"\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "DatasetFieldProfile",\n            "namespace": "com.linkedin.dataset",\n            "fields": [\n              {\n                "type": "string",\n                "name": "fieldPath"\n              },\n              {\n                "type": [\n                  "null",\n                  "long"\n                ],\n                "name": "uniqueCount",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "float"\n                ],\n                "name": "uniqueProportion",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "long"\n                ],\n                "name": "nullCount",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "float"\n                ],\n                "name": "nullProportion",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "min",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "max",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "mean",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "median",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "stdev",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "array",\n                    "items": {\n                      "type": "record",\n                      "name": "Quantile",\n                      "namespace": "com.linkedin.dataset",\n                      "fields": [\n                        {\n                          "type": "string",\n                          "name": "quantile"\n                        },\n                        {\n                          "type": "string",\n                          "name": "value"\n                        }\n                      ]\n                    }\n                  }\n                ],\n                "name": "quantiles",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "array",\n                    "items": {\n                      "type": "record",\n                      "name": "ValueFrequency",\n                      "namespace": "com.linkedin.dataset",\n                      "fields": [\n                        {\n                          "type": "string",\n                          "name": "value"\n                        },\n                        {\n                          "type": "long",\n                          "name": "frequency"\n                        }\n                      ]\n                    }\n                  }\n                ],\n                "name": "distinctValueFrequencies",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "record",\n                    "name": "Histogram",\n                    "namespace": "com.linkedin.dataset",\n                    "fields": [\n                      {\n                        "type": {\n                          "type": "array",\n                          "items": "string"\n                        },\n                        "name": "boundaries"\n                      },\n                      {\n                        "type": {\n                          "type": "array",\n                          "items": "float"\n                        },\n                        "name": "heights"\n                      }\n                    ]\n                  }\n                ],\n                "name": "histogram",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "array",\n                    "items": "string"\n                  }\n                ],\n                "name": "sampleValues",\n                "default": null\n              }\n            ],\n            "doc": "Stats corresponding to fields in a dataset"\n          }\n        }\n      ],\n      "name": "fieldProfiles",\n      "default": null,\n      "doc": "Profiles for each column (or schema field)"\n    },\n    {\n      "Searchable": {\n        "fieldType": "COUNT",\n        "hasValuesFieldName": "hasSizeInBytes"\n      },\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "sizeInBytes",\n      "default": null,\n      "doc": "Storage size in bytes"\n    }\n  ],\n  "doc": "Stats corresponding to datasets"\n}\n'))),(0,t.yg)("h3",{id:"datasetusagestatistics-timeseries"},"datasetUsageStatistics (Timeseries)"),(0,t.yg)("p",null,"Stats corresponding to dataset's usage."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetUsageStatistics",\n    "type": "timeseries"\n  },\n  "name": "DatasetUsageStatistics",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": "long",\n      "name": "timestampMillis",\n      "doc": "The event timestamp field as epoch at UTC in milli seconds."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "TimeWindowSize",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "CalendarInterval",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "SECOND",\n                  "MINUTE",\n                  "HOUR",\n                  "DAY",\n                  "WEEK",\n                  "MONTH",\n                  "QUARTER",\n                  "YEAR"\n                ]\n              },\n              "name": "unit",\n              "doc": "Interval unit such as minute/hour/day etc."\n            },\n            {\n              "type": "int",\n              "name": "multiple",\n              "default": 1,\n              "doc": "How many units. Defaults to 1."\n            }\n          ],\n          "doc": "Defines the size of a time window."\n        }\n      ],\n      "name": "eventGranularity",\n      "default": null,\n      "doc": "Granularity of the event if applicable"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "PartitionSpec",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "TimeseriesField": {},\n              "type": "string",\n              "name": "partition",\n              "doc": "A unique id / value for the partition for which statistics were collected,\\ngenerated by applying the key definition to a given row."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "TimeWindow",\n                  "namespace": "com.linkedin.timeseries",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "startTimeMillis",\n                      "doc": "Start time as epoch at UTC."\n                    },\n                    {\n                      "type": "com.linkedin.timeseries.TimeWindowSize",\n                      "name": "length",\n                      "doc": "The length of the window."\n                    }\n                  ]\n                }\n              ],\n              "name": "timePartition",\n              "default": null,\n              "doc": "Time window of the partition, if we are able to extract it from the partition key."\n            },\n            {\n              "deprecated": true,\n              "type": {\n                "type": "enum",\n                "name": "PartitionType",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "FULL_TABLE",\n                  "QUERY",\n                  "PARTITION"\n                ]\n              },\n              "name": "type",\n              "default": "PARTITION",\n              "doc": "Unused!"\n            }\n          ],\n          "doc": "A reference to a specific partition in a dataset."\n        },\n        "null"\n      ],\n      "name": "partitionSpec",\n      "default": {\n        "partition": "FULL_TABLE_SNAPSHOT",\n        "type": "FULL_TABLE",\n        "timePartition": null\n      },\n      "doc": "The optional partition specification."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "messageId",\n      "default": null,\n      "doc": "The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "int"\n      ],\n      "name": "uniqueUserCount",\n      "default": null,\n      "doc": "Unique user count"\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "int"\n      ],\n      "name": "totalSqlQueries",\n      "default": null,\n      "doc": "Total SQL query count"\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": "string"\n        }\n      ],\n      "name": "topSqlQueries",\n      "default": null,\n      "doc": "Frequent SQL queries; mostly makes sense for datasets in SQL databases"\n    },\n    {\n      "TimeseriesFieldCollection": {\n        "key": "user"\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "DatasetUserUsageCounts",\n            "namespace": "com.linkedin.dataset",\n            "fields": [\n              {\n                "java": {\n                  "class": "com.linkedin.common.urn.Urn"\n                },\n                "type": "string",\n                "name": "user",\n                "doc": "The unique id of the user."\n              },\n              {\n                "TimeseriesField": {},\n                "type": "int",\n                "name": "count",\n                "doc": "Number of times the dataset has been used by the user."\n              },\n              {\n                "TimeseriesField": {},\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "userEmail",\n                "default": null,\n                "doc": "If user_email is set, we attempt to resolve the user\'s urn upon ingest"\n              }\n            ],\n            "doc": "Records a single user\'s usage counts for a given resource"\n          }\n        }\n      ],\n      "name": "userCounts",\n      "default": null,\n      "doc": "Users within this bucket, with frequency counts"\n    },\n    {\n      "TimeseriesFieldCollection": {\n        "key": "fieldPath"\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "DatasetFieldUsageCounts",\n            "namespace": "com.linkedin.dataset",\n            "fields": [\n              {\n                "type": "string",\n                "name": "fieldPath",\n                "doc": "The name of the field."\n              },\n              {\n                "TimeseriesField": {},\n                "type": "int",\n                "name": "count",\n                "doc": "Number of times the field has been used."\n              }\n            ],\n            "doc": "Records field-level usage counts for a given dataset"\n          }\n        }\n      ],\n      "name": "fieldCounts",\n      "default": null,\n      "doc": "Field-level usage stats"\n    }\n  ],\n  "doc": "Stats corresponding to dataset\'s usage."\n}\n'))),(0,t.yg)("h3",{id:"operation-timeseries"},"operation (Timeseries)"),(0,t.yg)("p",null,"Operational info for an entity."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "operation",\n    "type": "timeseries"\n  },\n  "name": "Operation",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": "long",\n      "name": "timestampMillis",\n      "doc": "The event timestamp field as epoch at UTC in milli seconds."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "TimeWindowSize",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "CalendarInterval",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "SECOND",\n                  "MINUTE",\n                  "HOUR",\n                  "DAY",\n                  "WEEK",\n                  "MONTH",\n                  "QUARTER",\n                  "YEAR"\n                ]\n              },\n              "name": "unit",\n              "doc": "Interval unit such as minute/hour/day etc."\n            },\n            {\n              "type": "int",\n              "name": "multiple",\n              "default": 1,\n              "doc": "How many units. Defaults to 1."\n            }\n          ],\n          "doc": "Defines the size of a time window."\n        }\n      ],\n      "name": "eventGranularity",\n      "default": null,\n      "doc": "Granularity of the event if applicable"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "PartitionSpec",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "TimeseriesField": {},\n              "type": "string",\n              "name": "partition",\n              "doc": "A unique id / value for the partition for which statistics were collected,\\ngenerated by applying the key definition to a given row."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "TimeWindow",\n                  "namespace": "com.linkedin.timeseries",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "startTimeMillis",\n                      "doc": "Start time as epoch at UTC."\n                    },\n                    {\n                      "type": "com.linkedin.timeseries.TimeWindowSize",\n                      "name": "length",\n                      "doc": "The length of the window."\n                    }\n                  ]\n                }\n              ],\n              "name": "timePartition",\n              "default": null,\n              "doc": "Time window of the partition, if we are able to extract it from the partition key."\n            },\n            {\n              "deprecated": true,\n              "type": {\n                "type": "enum",\n                "name": "PartitionType",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "FULL_TABLE",\n                  "QUERY",\n                  "PARTITION"\n                ]\n              },\n              "name": "type",\n              "default": "PARTITION",\n              "doc": "Unused!"\n            }\n          ],\n          "doc": "A reference to a specific partition in a dataset."\n        },\n        "null"\n      ],\n      "name": "partitionSpec",\n      "default": {\n        "partition": "FULL_TABLE_SNAPSHOT",\n        "type": "FULL_TABLE",\n        "timePartition": null\n      },\n      "doc": "The optional partition specification."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "messageId",\n      "default": null,\n      "doc": "The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."\n    },\n    {\n      "TimeseriesField": {},\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "actor",\n      "default": null,\n      "doc": "Actor who issued this operation."\n    },\n    {\n      "TimeseriesField": {},\n      "type": {\n        "type": "enum",\n        "symbolDocs": {\n          "ALTER": "Asset was altered",\n          "CREATE": "Asset was created",\n          "CUSTOM": "Custom asset operation",\n          "DELETE": "Rows were deleted",\n          "DROP": "Asset was dropped",\n          "INSERT": "Rows were inserted",\n          "UPDATE": "Rows were updated"\n        },\n        "name": "OperationType",\n        "namespace": "com.linkedin.common",\n        "symbols": [\n          "INSERT",\n          "UPDATE",\n          "DELETE",\n          "CREATE",\n          "ALTER",\n          "DROP",\n          "CUSTOM",\n          "UNKNOWN"\n        ],\n        "doc": "Enum to define the operation type when an entity changes."\n      },\n      "name": "operationType",\n      "doc": "Operation type of change."\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "customOperationType",\n      "default": null,\n      "doc": "A custom type of operation. Required if operationType is CUSTOM."\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "numAffectedRows",\n      "default": null,\n      "doc": "How many rows were affected by this operation."\n    },\n    {\n      "TimeseriesFieldCollection": {\n        "key": "datasetName"\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": "string"\n        }\n      ],\n      "name": "affectedDatasets",\n      "default": null,\n      "doc": "Which other datasets were affected by this operation."\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        {\n          "type": "enum",\n          "symbolDocs": {\n            "DATA_PLATFORM": "Rows were updated",\n            "DATA_PROCESS": "Provided by a Data Process"\n          },\n          "name": "OperationSourceType",\n          "namespace": "com.linkedin.common",\n          "symbols": [\n            "DATA_PROCESS",\n            "DATA_PLATFORM"\n          ],\n          "doc": "The source of an operation"\n        }\n      ],\n      "name": "sourceType",\n      "default": null,\n      "doc": "Source Type"\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "map",\n          "values": "string"\n        }\n      ],\n      "name": "customProperties",\n      "default": null,\n      "doc": "Custom properties"\n    },\n    {\n      "Searchable": {\n        "fieldName": "lastOperationTime",\n        "fieldType": "DATETIME"\n      },\n      "TimeseriesField": {},\n      "type": "long",\n      "name": "lastUpdatedTimestamp",\n      "doc": "The time at which the operation occurred. Would be better named \'operationTime\'"\n    }\n  ],\n  "doc": "Operational info for an entity."\n}\n'))),(0,t.yg)("h3",{id:"datasetdeprecation-deprecated"},"datasetDeprecation (Deprecated)"),(0,t.yg)("p",null,"Dataset deprecation status\nDeprecated! This aspect is deprecated in favor of the more-general-purpose 'Deprecation' aspect."),(0,t.yg)("details",null,(0,t.yg)("summary",null,"Schema"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetDeprecation"\n  },\n  "Deprecated": true,\n  "name": "DatasetDeprecation",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN",\n        "weightsPerFieldValue": {\n          "true": 0.5\n        }\n      },\n      "type": "boolean",\n      "name": "deprecated",\n      "doc": "Whether the dataset is deprecated by owner."\n    },\n    {\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "decommissionTime",\n      "default": null,\n      "doc": "The time user plan to decommission this dataset."\n    },\n    {\n      "type": "string",\n      "name": "note",\n      "doc": "Additional information about the dataset deprecation plan, such as the wiki, doc, RB."\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "actor",\n      "default": null,\n      "doc": "The corpuser URN which will be credited for modifying this deprecation content."\n    }\n  ],\n  "doc": "Dataset deprecation status\\nDeprecated! This aspect is deprecated in favor of the more-general-purpose \'Deprecation\' aspect."\n}\n'))),(0,t.yg)("h2",{id:"relationships"},"Relationships"),(0,t.yg)("h3",{id:"self"},"Self"),(0,t.yg)("p",null,"These are the relationships to itself, stored in this entity's aspects"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"DownstreamOf (via ",(0,t.yg)("inlineCode",{parentName:"li"},"upstreamLineage.upstreams.dataset"),")"),(0,t.yg)("li",{parentName:"ul"},"DownstreamOf (via ",(0,t.yg)("inlineCode",{parentName:"li"},"upstreamLineage.fineGrainedLineages"),")"),(0,t.yg)("li",{parentName:"ul"},"ForeignKeyToDataset (via ",(0,t.yg)("inlineCode",{parentName:"li"},"schemaMetadata.foreignKeys.foreignDataset"),")"),(0,t.yg)("li",{parentName:"ul"},"SiblingOf (via ",(0,t.yg)("inlineCode",{parentName:"li"},"siblings.siblings"),")")),(0,t.yg)("h3",{id:"outgoing"},"Outgoing"),(0,t.yg)("p",null,"These are the relationships stored in this entity's aspects"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"DownstreamOf"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"SchemaField via ",(0,t.yg)("inlineCode",{parentName:"li"},"upstreamLineage.fineGrainedLineages")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"OwnedBy"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Corpuser via ",(0,t.yg)("inlineCode",{parentName:"li"},"ownership.owners.owner")),(0,t.yg)("li",{parentName:"ul"},"CorpGroup via ",(0,t.yg)("inlineCode",{parentName:"li"},"ownership.owners.owner")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"ownershipType"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"OwnershipType via ",(0,t.yg)("inlineCode",{parentName:"li"},"ownership.owners.typeUrn")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"SchemaFieldTaggedWith"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Tag via ",(0,t.yg)("inlineCode",{parentName:"li"},"schemaMetadata.fields.globalTags")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"TaggedWith"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Tag via ",(0,t.yg)("inlineCode",{parentName:"li"},"schemaMetadata.fields.globalTags.tags")),(0,t.yg)("li",{parentName:"ul"},"Tag via ",(0,t.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata.editableSchemaFieldInfo.globalTags.tags")),(0,t.yg)("li",{parentName:"ul"},"Tag via ",(0,t.yg)("inlineCode",{parentName:"li"},"globalTags.tags")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"SchemaFieldWithGlossaryTerm"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"GlossaryTerm via ",(0,t.yg)("inlineCode",{parentName:"li"},"schemaMetadata.fields.glossaryTerms")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"TermedWith"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"GlossaryTerm via ",(0,t.yg)("inlineCode",{parentName:"li"},"schemaMetadata.fields.glossaryTerms.terms.urn")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"ForeignKeyTo"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"SchemaField via ",(0,t.yg)("inlineCode",{parentName:"li"},"schemaMetadata.foreignKeys.foreignFields")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"EditableSchemaFieldTaggedWith"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Tag via ",(0,t.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata.editableSchemaFieldInfo.globalTags")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"EditableSchemaFieldWithGlossaryTerm"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"GlossaryTerm via ",(0,t.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata.editableSchemaFieldInfo.glossaryTerms")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"AssociatedWith"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Domain via ",(0,t.yg)("inlineCode",{parentName:"li"},"domains.domains")),(0,t.yg)("li",{parentName:"ul"},"Role via ",(0,t.yg)("inlineCode",{parentName:"li"},"access.roles.urn")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"IsPartOf"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Container via ",(0,t.yg)("inlineCode",{parentName:"li"},"container.container")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"IsFailing"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Test via ",(0,t.yg)("inlineCode",{parentName:"li"},"testResults.failing")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"IsPassing"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Test via ",(0,t.yg)("inlineCode",{parentName:"li"},"testResults.passing")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"ResolvedIncidents"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Incident via ",(0,t.yg)("inlineCode",{parentName:"li"},"incidentsSummary.resolvedIncidentDetails")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"ActiveIncidents"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Incident via ",(0,t.yg)("inlineCode",{parentName:"li"},"incidentsSummary.activeIncidentDetails")))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"VersionOf"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"VersionSet via ",(0,t.yg)("inlineCode",{parentName:"li"},"versionProperties.versionSet"))))),(0,t.yg)("h2",{id:"global-metadata-model"},(0,t.yg)("a",{parentName:"h2",href:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png"},"Global Metadata Model")),(0,t.yg)("p",null,(0,t.yg)("img",{parentName:"p",src:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png",alt:"Global Graph"})))}y.isMDXComponent=!0}}]);