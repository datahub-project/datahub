"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[14176],{60889:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>m,default:()=>g,frontMatter:()=>d,metadata:()=>p,toc:()=>c});t(96540);var a=t(15680),s=t(53720),i=t(5400);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})),e}function l(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}const d={sidebar_position:16,title:"Assertion",slug:"/generated/metamodel/entities/assertion",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/assertion.md"},m="Assertion",p={unversionedId:"docs/generated/metamodel/entities/assertion",id:"docs/generated/metamodel/entities/assertion",title:"Assertion",description:"The assertion entity represents a data quality rule that can be applied to one or more datasets. Assertions are the foundation of DataHub's data quality framework, enabling organizations to define, monitor, and enforce expectations about their data. They encompass various types of checks including field-level validation, volume monitoring, freshness tracking, schema validation, and custom SQL-based rules.",source:"@site/genDocs/docs/generated/metamodel/entities/assertion.md",sourceDirName:"docs/generated/metamodel/entities",slug:"/generated/metamodel/entities/assertion",permalink:"/docs/generated/metamodel/entities/assertion",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/assertion.md",tags:[],version:"current",sidebarPosition:16,frontMatter:{sidebar_position:16,title:"Assertion",slug:"/generated/metamodel/entities/assertion",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/assertion.md"},sidebar:"overviewSidebar",previous:{title:"GlossaryNode",permalink:"/docs/generated/metamodel/entities/glossarynode"},next:{title:"ML Model",permalink:"/docs/generated/metamodel/entities/mlmodel"}},u={},c=[{value:"Identity",id:"identity",level:2},{value:"Generating Stable Assertion IDs",id:"generating-stable-assertion-ids",level:3},{value:"Important Capabilities",id:"important-capabilities",level:2},{value:"Assertion Types",id:"assertion-types",level:3},{value:"1. Field Assertions (FIELD)",id:"1-field-assertions-field",level:4},{value:"2. Volume Assertions (VOLUME)",id:"2-volume-assertions-volume",level:4},{value:"3. Freshness Assertions (FRESHNESS)",id:"3-freshness-assertions-freshness",level:4},{value:"4. Schema Assertions (DATA_SCHEMA)",id:"4-schema-assertions-data_schema",level:4},{value:"5. SQL Assertions (SQL)",id:"5-sql-assertions-sql",level:4},{value:"6. Custom Assertions (CUSTOM)",id:"6-custom-assertions-custom",level:4},{value:"Assertion Source",id:"assertion-source",level:3},{value:"Assertion Run Events",id:"assertion-run-events",level:3},{value:"Assertion Actions",id:"assertion-actions",level:3},{value:"Tags and Metadata",id:"tags-and-metadata",level:3},{value:"Standard Operators and Parameters",id:"standard-operators-and-parameters",level:3},{value:"Standard Aggregations",id:"standard-aggregations",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"Relationship to Datasets",id:"relationship-to-datasets",level:3},{value:"Relationship to Data Jobs",id:"relationship-to-data-jobs",level:3},{value:"Relationship to Data Platforms",id:"relationship-to-data-platforms",level:3},{value:"GraphQL API",id:"graphql-api",level:3},{value:"Integration with dbt",id:"integration-with-dbt",level:3},{value:"Integration with Great Expectations",id:"integration-with-great-expectations",level:3},{value:"Integration with Snowflake Data Quality",id:"integration-with-snowflake-data-quality",level:3},{value:"Notable Exceptions",id:"notable-exceptions",level:2},{value:"Legacy Dataset Assertion Type",id:"legacy-dataset-assertion-type",level:3},{value:"Assertion Results vs. Assertion Metrics",id:"assertion-results-vs-assertion-metrics",level:3},{value:"Assertion Scheduling",id:"assertion-scheduling",level:3},{value:"Assertion vs. Test Results",id:"assertion-vs-test-results",level:3},{value:"Technical Reference Guide",id:"technical-reference-guide",level:2},{value:"Reading the Field Tables",id:"reading-the-field-tables",level:3},{value:"Aspects",id:"aspects",level:3},{value:"assertionInfo",id:"assertioninfo",level:4},{value:"dataPlatformInstance",id:"dataplatforminstance",level:4},{value:"assertionActions",id:"assertionactions",level:4},{value:"status",id:"status",level:4},{value:"globalTags",id:"globaltags",level:4},{value:"assertionRunEvent (Timeseries)",id:"assertionrunevent-timeseries",level:4},{value:"Common Types",id:"common-types",level:3},{value:"AssertionAction",id:"assertionaction",level:4},{value:"AuditStamp",id:"auditstamp",level:4},{value:"Relationships",id:"relationships",level:3},{value:"Outgoing",id:"outgoing",level:4},{value:"Global Metadata Model",id:"global-metadata-model",level:3}],y={toc:c},h="wrapper";function g(e){var{components:n}=e,t=l(e,["components"]);return(0,a.yg)(h,o(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},a=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})))),a.forEach((function(n){r(e,n,t[n])}))}return e}({},y,t),{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"assertion"},"Assertion"),(0,a.yg)("p",null,"The assertion entity represents a data quality rule that can be applied to one or more datasets. Assertions are the foundation of DataHub's data quality framework, enabling organizations to define, monitor, and enforce expectations about their data. They encompass various types of checks including field-level validation, volume monitoring, freshness tracking, schema validation, and custom SQL-based rules."),(0,a.yg)("p",null,"Assertions can originate from multiple sources: they can be defined natively within DataHub, ingested from external data quality tools (such as Great Expectations, dbt tests, or Snowflake Data Quality), or inferred by ML-based systems. Each assertion tracks its evaluation history over time, maintaining a complete audit trail of passes, failures, and errors."),(0,a.yg)("h2",{id:"identity"},"Identity"),(0,a.yg)("p",null,"An ",(0,a.yg)("strong",{parentName:"p"},"Assertion")," is uniquely identified by an ",(0,a.yg)("inlineCode",{parentName:"p"},"assertionId"),", which is a globally unique identifier that remains constant across runs of the assertion. The URN format is:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"urn:li:assertion:<assertionId>\n")),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"assertionId")," is typically a generated GUID that uniquely identifies the assertion definition. For example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"urn:li:assertion:432475190cc846f2894b5b3aa4d55af2\n")),(0,a.yg)("h3",{id:"generating-stable-assertion-ids"},"Generating Stable Assertion IDs"),(0,a.yg)("p",null,"The logic for generating stable assertion IDs differs based on the source of the assertion:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Native Assertions"),": Created in DataHub Cloud's UI or API, the platform generates a UUID"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"External Assertions"),": Each integration tool generates IDs based on its own conventions:",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Great Expectations"),": Combines expectation suite name, expectation type, and parameters"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"dbt Tests"),": Uses the test's unique_id from the manifest"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Snowflake Data Quality"),": Uses the native DMF rule ID"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Inferred Assertions"),": ML-based systems generate IDs based on the inference model and target")),(0,a.yg)("p",null,"The key requirement is that the same assertion definition should always produce the same ",(0,a.yg)("inlineCode",{parentName:"p"},"assertionId"),", enabling DataHub to track the assertion's history over time even as it's re-evaluated."),(0,a.yg)("h2",{id:"important-capabilities"},"Important Capabilities"),(0,a.yg)("h3",{id:"assertion-types"},"Assertion Types"),(0,a.yg)("p",null,"DataHub supports several types of assertions, each designed to validate different aspects of data quality:"),(0,a.yg)("h4",{id:"1-field-assertions-field"},"1. Field Assertions (FIELD)"),(0,a.yg)("p",null,"Field assertions validate individual columns or fields within a dataset. They come in two sub-types:"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Field Values Assertions"),": Validate that each value in a column meets certain criteria. For example:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Values must be within a specific range"),(0,a.yg)("li",{parentName:"ul"},"Values must match a regex pattern"),(0,a.yg)("li",{parentName:"ul"},"Values must be one of a set of allowed values"),(0,a.yg)("li",{parentName:"ul"},"Values must not be null")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Field Metric Assertions"),": Validate aggregated statistics about a column. For example:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Null percentage must be less than 5%"),(0,a.yg)("li",{parentName:"ul"},"Unique count must equal row count (uniqueness check)"),(0,a.yg)("li",{parentName:"ul"},"Mean value must be between 0 and 100"),(0,a.yg)("li",{parentName:"ul"},"Standard deviation must be less than 10")),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Create a field uniqueness assertion"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/assertion_create_field_uniqueness.py\n# metadata-ingestion/examples/library/assertion_field_uniqueness.py\nimport os\n\nimport datahub.emitter.mce_builder as builder\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AssertionInfoClass,\n    AssertionStdOperatorClass,\n    AssertionTypeClass,\n    FieldAssertionInfoClass,\n    FieldAssertionTypeClass,\n    FieldMetricAssertionClass,\n    FieldMetricTypeClass,\n    SchemaFieldSpecClass,\n)\n\nemitter = DatahubRestEmitter(\n    gms_server=os.getenv("DATAHUB_GMS_URL", "http://localhost:8080"),\n    token=os.getenv("DATAHUB_GMS_TOKEN"),\n)\n\ndataset_urn = builder.make_dataset_urn(platform="snowflake", name="mydb.myschema.users")\n\nfield_assertion_info = FieldAssertionInfoClass(\n    type=FieldAssertionTypeClass.FIELD_METRIC,\n    entity=dataset_urn,\n    fieldMetricAssertion=FieldMetricAssertionClass(\n        field=SchemaFieldSpecClass(\n            path="user_id",\n            type="VARCHAR",\n            nativeType="VARCHAR",\n        ),\n        metric=FieldMetricTypeClass.UNIQUE_COUNT,\n        operator=AssertionStdOperatorClass.EQUAL_TO,\n        parameters=None,\n    ),\n)\n\nassertion_info = AssertionInfoClass(\n    type=AssertionTypeClass.FIELD,\n    fieldAssertion=field_assertion_info,\n    description="User ID must be unique across all rows",\n)\n\nassertion_urn = builder.make_assertion_urn(\n    builder.datahub_guid(\n        {"entity": dataset_urn, "field": "user_id", "type": "uniqueness"}\n    )\n)\n\nassertion_info_mcp = MetadataChangeProposalWrapper(\n    entityUrn=assertion_urn,\n    aspect=assertion_info,\n)\n\nemitter.emit_mcp(assertion_info_mcp)\nprint(f"Created field uniqueness assertion: {assertion_urn}")\n\n'))),(0,a.yg)("h4",{id:"2-volume-assertions-volume"},"2. Volume Assertions (VOLUME)"),(0,a.yg)("p",null,"Volume assertions monitor the amount of data in a dataset. They support several sub-types:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"ROW_COUNT_TOTAL"),": Total number of rows must meet expectations"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"ROW_COUNT_CHANGE"),": Change in row count over time must meet expectations"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"INCREMENTING_SEGMENT_ROW_COUNT_TOTAL"),": Latest partition/segment row count"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"INCREMENTING_SEGMENT_ROW_COUNT_CHANGE"),": Change between consecutive partitions")),(0,a.yg)("p",null,"Volume assertions are critical for detecting data pipeline failures, incomplete loads, or unexpected data growth."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Create a row count volume assertion"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/assertion_create_volume_rows.py\n# metadata-ingestion/examples/library/assertion_volume_rows.py\nimport os\n\nimport datahub.emitter.mce_builder as builder\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AssertionInfoClass,\n    AssertionStdOperatorClass,\n    AssertionStdParameterClass,\n    AssertionStdParametersClass,\n    AssertionStdParameterTypeClass,\n    AssertionTypeClass,\n    RowCountTotalClass,\n    VolumeAssertionInfoClass,\n    VolumeAssertionTypeClass,\n)\n\nemitter = DatahubRestEmitter(\n    gms_server=os.getenv("DATAHUB_GMS_URL", "http://localhost:8080"),\n    token=os.getenv("DATAHUB_GMS_TOKEN"),\n)\n\ndataset_urn = builder.make_dataset_urn(\n    platform="bigquery", name="project.dataset.orders"\n)\n\nvolume_assertion_info = VolumeAssertionInfoClass(\n    type=VolumeAssertionTypeClass.ROW_COUNT_TOTAL,\n    entity=dataset_urn,\n    rowCountTotal=RowCountTotalClass(\n        operator=AssertionStdOperatorClass.BETWEEN,\n        parameters=AssertionStdParametersClass(\n            minValue=AssertionStdParameterClass(\n                type=AssertionStdParameterTypeClass.NUMBER,\n                value="1000",\n            ),\n            maxValue=AssertionStdParameterClass(\n                type=AssertionStdParameterTypeClass.NUMBER,\n                value="1000000",\n            ),\n        ),\n    ),\n)\n\nassertion_info = AssertionInfoClass(\n    type=AssertionTypeClass.VOLUME,\n    volumeAssertion=volume_assertion_info,\n    description="Orders table must contain between 1,000 and 1,000,000 rows",\n)\n\nassertion_urn = builder.make_assertion_urn(\n    builder.datahub_guid({"entity": dataset_urn, "type": "row-count-range"})\n)\n\nassertion_info_mcp = MetadataChangeProposalWrapper(\n    entityUrn=assertion_urn,\n    aspect=assertion_info,\n)\n\nemitter.emit_mcp(assertion_info_mcp)\nprint(f"Created volume assertion: {assertion_urn}")\n\n'))),(0,a.yg)("h4",{id:"3-freshness-assertions-freshness"},"3. Freshness Assertions (FRESHNESS)"),(0,a.yg)("p",null,"Freshness assertions ensure data is updated within expected time windows. Two types are supported:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"DATASET_CHANGE"),": Based on dataset change operations (insert, update, delete) captured from audit logs"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"DATA_JOB_RUN"),": Based on successful execution of a data job")),(0,a.yg)("p",null,"Freshness assertions define a schedule that specifies when updates should occur (e.g., daily by 9 AM, every 4 hours) and what tolerance is acceptable."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Create a dataset change freshness assertion"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/assertion_create_freshness.py\n# metadata-ingestion/examples/library/assertion_freshness.py\nimport os\n\nimport datahub.emitter.mce_builder as builder\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AssertionInfoClass,\n    AssertionTypeClass,\n    FreshnessAssertionInfoClass,\n    FreshnessAssertionScheduleClass,\n    FreshnessAssertionScheduleTypeClass,\n    FreshnessAssertionTypeClass,\n    FreshnessCronScheduleClass,\n)\n\nemitter = DatahubRestEmitter(\n    gms_server=os.getenv("DATAHUB_GMS_URL", "http://localhost:8080"),\n    token=os.getenv("DATAHUB_GMS_TOKEN"),\n)\n\ndataset_urn = builder.make_dataset_urn(\n    platform="redshift", name="prod.analytics.daily_metrics"\n)\n\nfreshness_assertion_info = FreshnessAssertionInfoClass(\n    type=FreshnessAssertionTypeClass.DATASET_CHANGE,\n    entity=dataset_urn,\n    schedule=FreshnessAssertionScheduleClass(\n        type=FreshnessAssertionScheduleTypeClass.CRON,\n        cron=FreshnessCronScheduleClass(\n            cron="0 9 * * *",\n            timezone="America/Los_Angeles",\n            windowStartOffsetMs=None,\n        ),\n    ),\n)\n\nassertion_info = AssertionInfoClass(\n    type=AssertionTypeClass.FRESHNESS,\n    freshnessAssertion=freshness_assertion_info,\n    description="Daily metrics table must be updated every day by 9 AM Pacific Time",\n)\n\nassertion_urn = builder.make_assertion_urn(\n    builder.datahub_guid({"entity": dataset_urn, "type": "freshness-daily-9am"})\n)\n\nassertion_info_mcp = MetadataChangeProposalWrapper(\n    entityUrn=assertion_urn,\n    aspect=assertion_info,\n)\n\nemitter.emit_mcp(assertion_info_mcp)\nprint(f"Created freshness assertion: {assertion_urn}")\n\n'))),(0,a.yg)("h4",{id:"4-schema-assertions-data_schema"},"4. Schema Assertions (DATA_SCHEMA)"),(0,a.yg)("p",null,"Schema assertions validate that a dataset's structure matches expectations. They verify:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Presence or absence of specific columns"),(0,a.yg)("li",{parentName:"ul"},"Column data types"),(0,a.yg)("li",{parentName:"ul"},"Column ordering (optional)"),(0,a.yg)("li",{parentName:"ul"},"Schema compatibility modes:",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"EXACT_MATCH"),": Schema must match exactly"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"SUPERSET"),": Actual schema can have additional columns"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"SUBSET"),": Actual schema can have fewer columns")))),(0,a.yg)("p",null,"Schema assertions are valuable for detecting breaking changes in upstream data sources."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Create a schema assertion"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/assertion_create_schema.py\n# metadata-ingestion/examples/library/assertion_schema.py\nimport os\nimport time\n\nimport datahub.emitter.mce_builder as builder\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AssertionInfoClass,\n    AssertionTypeClass,\n    AuditStampClass,\n    NumberTypeClass,\n    SchemaAssertionCompatibilityClass,\n    SchemaAssertionInfoClass,\n    SchemaFieldClass,\n    SchemaFieldDataTypeClass,\n    SchemalessClass,\n    SchemaMetadataClass,\n    StringTypeClass,\n)\n\nemitter = DatahubRestEmitter(\n    gms_server=os.getenv("DATAHUB_GMS_URL", "http://localhost:8080"),\n    token=os.getenv("DATAHUB_GMS_TOKEN"),\n)\n\ndataset_urn = builder.make_dataset_urn(platform="kafka", name="prod.user_events")\n\ncurrent_timestamp = int(time.time() * 1000)\naudit_stamp = AuditStampClass(\n    time=current_timestamp,\n    actor="urn:li:corpuser:datahub",\n)\n\nexpected_schema = SchemaMetadataClass(\n    schemaName="user_events",\n    platform=builder.make_data_platform_urn("kafka"),\n    version=0,\n    created=audit_stamp,\n    lastModified=audit_stamp,\n    fields=[\n        SchemaFieldClass(\n            fieldPath="user_id",\n            type=SchemaFieldDataTypeClass(type=StringTypeClass()),\n            nativeDataType="string",\n            lastModified=audit_stamp,\n        ),\n        SchemaFieldClass(\n            fieldPath="event_type",\n            type=SchemaFieldDataTypeClass(type=StringTypeClass()),\n            nativeDataType="string",\n            lastModified=audit_stamp,\n        ),\n        SchemaFieldClass(\n            fieldPath="timestamp",\n            type=SchemaFieldDataTypeClass(type=NumberTypeClass()),\n            nativeDataType="long",\n            lastModified=audit_stamp,\n        ),\n        SchemaFieldClass(\n            fieldPath="properties",\n            type=SchemaFieldDataTypeClass(type=StringTypeClass()),\n            nativeDataType="string",\n            lastModified=audit_stamp,\n        ),\n    ],\n    hash="",\n    platformSchema=SchemalessClass(),\n)\n\nschema_assertion_info = SchemaAssertionInfoClass(\n    entity=dataset_urn,\n    schema=expected_schema,\n    compatibility=SchemaAssertionCompatibilityClass.SUPERSET,\n)\n\nassertion_info = AssertionInfoClass(\n    type=AssertionTypeClass.DATA_SCHEMA,\n    schemaAssertion=schema_assertion_info,\n    description="User events stream must have required schema fields (can include additional fields)",\n)\n\nassertion_urn = builder.make_assertion_urn(\n    builder.datahub_guid({"entity": dataset_urn, "type": "schema-check"})\n)\n\nassertion_info_mcp = MetadataChangeProposalWrapper(\n    entityUrn=assertion_urn,\n    aspect=assertion_info,\n)\n\nemitter.emit_mcp(assertion_info_mcp)\nprint(f"Created schema assertion: {assertion_urn}")\n\n'))),(0,a.yg)("h4",{id:"5-sql-assertions-sql"},"5. SQL Assertions (SQL)"),(0,a.yg)("p",null,"SQL assertions allow custom validation logic using arbitrary SQL queries. Two types:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"METRIC"),": Execute SQL and assert the returned metric meets expectations"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"METRIC_CHANGE"),": Assert the change in a SQL metric over time")),(0,a.yg)("p",null,"SQL assertions provide maximum flexibility for complex validation scenarios that don't fit other assertion types, such as cross-table referential integrity checks or business rule validation."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Create a SQL metric assertion"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/assertion_create_sql_metric.py\n# metadata-ingestion/examples/library/assertion_sql_metric.py\nimport os\n\nimport datahub.emitter.mce_builder as builder\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AssertionInfoClass,\n    AssertionStdOperatorClass,\n    AssertionStdParameterClass,\n    AssertionStdParametersClass,\n    AssertionStdParameterTypeClass,\n    AssertionTypeClass,\n    SqlAssertionInfoClass,\n    SqlAssertionTypeClass,\n)\n\nemitter = DatahubRestEmitter(\n    gms_server=os.getenv("DATAHUB_GMS_URL", "http://localhost:8080"),\n    token=os.getenv("DATAHUB_GMS_TOKEN"),\n)\n\ndataset_urn = builder.make_dataset_urn(platform="postgres", name="public.transactions")\n\nsql_assertion_info = SqlAssertionInfoClass(\n    type=SqlAssertionTypeClass.METRIC,\n    entity=dataset_urn,\n    statement="SELECT SUM(amount) FROM public.transactions WHERE status = \'completed\' AND date = CURRENT_DATE",\n    operator=AssertionStdOperatorClass.GREATER_THAN_OR_EQUAL_TO,\n    parameters=AssertionStdParametersClass(\n        value=AssertionStdParameterClass(\n            type=AssertionStdParameterTypeClass.NUMBER,\n            value="0",\n        )\n    ),\n)\n\nassertion_info = AssertionInfoClass(\n    type=AssertionTypeClass.SQL,\n    sqlAssertion=sql_assertion_info,\n    description="Total completed transaction amount today must be non-negative",\n)\n\nassertion_urn = builder.make_assertion_urn(\n    builder.datahub_guid(\n        {"entity": dataset_urn, "type": "sql-completed-transactions-sum"}\n    )\n)\n\nassertion_info_mcp = MetadataChangeProposalWrapper(\n    entityUrn=assertion_urn,\n    aspect=assertion_info,\n)\n\nemitter.emit_mcp(assertion_info_mcp)\nprint(f"Created SQL assertion: {assertion_urn}")\n\n'))),(0,a.yg)("h4",{id:"6-custom-assertions-custom"},"6. Custom Assertions (CUSTOM)"),(0,a.yg)("p",null,"Custom assertions provide an extension point for assertion types not directly modeled in DataHub. They're useful when:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Integrating third-party data quality tools with unique assertion types"),(0,a.yg)("li",{parentName:"ul"},"Starting integration before fully mapping to DataHub's type system"),(0,a.yg)("li",{parentName:"ul"},"Implementing organization-specific validation logic")),(0,a.yg)("h3",{id:"assertion-source"},"Assertion Source"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"assertionInfo")," aspect includes an ",(0,a.yg)("inlineCode",{parentName:"p"},"AssertionSource")," that identifies the origin of the assertion:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"NATIVE"),": Defined directly in DataHub (DataHub Cloud feature)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"EXTERNAL"),": Ingested from external tools (Great Expectations, dbt, Snowflake, etc.)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"INFERRED"),": Generated by ML-based inference systems (DataHub Cloud feature)")),(0,a.yg)("p",null,"External assertions should have a corresponding ",(0,a.yg)("inlineCode",{parentName:"p"},"dataPlatformInstance")," aspect that identifies the specific platform instance they originated from."),(0,a.yg)("h3",{id:"assertion-run-events"},"Assertion Run Events"),(0,a.yg)("p",null,"Assertion evaluations are tracked using the ",(0,a.yg)("inlineCode",{parentName:"p"},"assertionRunEvent")," timeseries aspect. Each evaluation creates a new event with:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"timestampMillis"),": When the evaluation occurred"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"runId"),": Platform-specific identifier for this evaluation run"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"asserteeUrn"),": The entity being asserted (typically a dataset)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"assertionUrn"),": The assertion being evaluated"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"status"),": COMPLETE, RUNNING, or ERROR"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"result"),": SUCCESS, FAILURE, or ERROR with details"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"batchSpec"),": Optional information about the data batch evaluated"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"runtimeContext"),": Optional key-value pairs with runtime parameters")),(0,a.yg)("p",null,"Run events enable tracking assertion health over time, identifying trends, and debugging failures."),(0,a.yg)("h3",{id:"assertion-actions"},"Assertion Actions"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"assertionActions")," aspect defines automated responses to assertion outcomes:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"onSuccess"),": Actions triggered when assertion passes"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"onFailure"),": Actions triggered when assertion fails")),(0,a.yg)("p",null,"Common actions include:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Sending notifications (email, Slack, PagerDuty)"),(0,a.yg)("li",{parentName:"ul"},"Creating incidents"),(0,a.yg)("li",{parentName:"ul"},"Triggering downstream workflows"),(0,a.yg)("li",{parentName:"ul"},"Updating metadata")),(0,a.yg)("h3",{id:"tags-and-metadata"},"Tags and Metadata"),(0,a.yg)("p",null,"Like other DataHub entities, assertions support standard metadata capabilities:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"globalTags"),": Categorize and organize assertions"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"glossaryTerms"),": Link assertions to business concepts"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"status"),": Mark assertions as active or deprecated")),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add tags to an assertion"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/assertion_add_tag.py\n# metadata-ingestion/examples/library/assertion_add_tags.py\nimport datahub.emitter.mce_builder as builder\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DataHubGraph, DataHubGraphConfig\nfrom datahub.metadata.schema_classes import (\n    GlobalTagsClass,\n    TagAssociationClass,\n)\n\ngraph = DataHubGraph(DataHubGraphConfig(server="http://localhost:8080"))\nemitter = DatahubRestEmitter("http://localhost:8080")\n\nassertion_urn = "urn:li:assertion:432475190cc846f2894b5b3aa4d55af2"\n\nexisting_tags = graph.get_aspect(\n    entity_urn=assertion_urn,\n    aspect_type=GlobalTagsClass,\n)\n\nif existing_tags is None:\n    existing_tags = GlobalTagsClass(tags=[])\n\ntag_to_add = builder.make_tag_urn("data-quality")\n\ntag_association = TagAssociationClass(tag=tag_to_add)\n\nif tag_association not in existing_tags.tags:\n    existing_tags.tags.append(tag_association)\n\n    tags_mcp = MetadataChangeProposalWrapper(\n        entityUrn=assertion_urn,\n        aspect=existing_tags,\n    )\n\n    emitter.emit_mcp(tags_mcp)\n    print(f"Added tag \'{tag_to_add}\' to assertion {assertion_urn}")\nelse:\n    print(f"Tag \'{tag_to_add}\' already exists on assertion {assertion_urn}")\n\n'))),(0,a.yg)("h3",{id:"standard-operators-and-parameters"},"Standard Operators and Parameters"),(0,a.yg)("p",null,"Assertions use a standard set of operators for comparisons:"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Numeric"),": ",(0,a.yg)("inlineCode",{parentName:"p"},"BETWEEN"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"LESS_THAN"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"LESS_THAN_OR_EQUAL_TO"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"GREATER_THAN"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"GREATER_THAN_OR_EQUAL_TO"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"EQUAL_TO"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"NOT_EQUAL_TO")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"String"),": ",(0,a.yg)("inlineCode",{parentName:"p"},"CONTAIN"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"START_WITH"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"END_WITH"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"REGEX_MATCH"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"IN"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"NOT_IN")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Boolean"),": ",(0,a.yg)("inlineCode",{parentName:"p"},"IS_TRUE"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"IS_FALSE"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"NULL"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"NOT_NULL")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Native"),": ",(0,a.yg)("inlineCode",{parentName:"p"},"_NATIVE_")," for platform-specific operators"),(0,a.yg)("p",null,"Parameters are provided via ",(0,a.yg)("inlineCode",{parentName:"p"},"AssertionStdParameters"),":"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"value"),": Single value for most operators"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"minValue"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"maxValue"),": Range endpoints for ",(0,a.yg)("inlineCode",{parentName:"li"},"BETWEEN")),(0,a.yg)("li",{parentName:"ul"},"Parameter types: ",(0,a.yg)("inlineCode",{parentName:"li"},"NUMBER"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"STRING"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"SET"))),(0,a.yg)("h3",{id:"standard-aggregations"},"Standard Aggregations"),(0,a.yg)("p",null,"Field and volume assertions can apply aggregation functions before evaluation:"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Statistical"),": ",(0,a.yg)("inlineCode",{parentName:"p"},"MEAN"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"MEDIAN"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"STDDEV"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"MIN"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"MAX"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"SUM")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Count-based"),": ",(0,a.yg)("inlineCode",{parentName:"p"},"ROW_COUNT"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"COLUMN_COUNT"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"UNIQUE_COUNT"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"NULL_COUNT")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Proportional"),": ",(0,a.yg)("inlineCode",{parentName:"p"},"UNIQUE_PROPORTION"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"NULL_PROPORTION")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Identity"),": ",(0,a.yg)("inlineCode",{parentName:"p"},"IDENTITY")," (no aggregation), ",(0,a.yg)("inlineCode",{parentName:"p"},"COLUMNS")," (all columns)"),(0,a.yg)("h2",{id:"integration-points"},"Integration Points"),(0,a.yg)("h3",{id:"relationship-to-datasets"},"Relationship to Datasets"),(0,a.yg)("p",null,"Assertions have a strong relationship with datasets through the ",(0,a.yg)("inlineCode",{parentName:"p"},"Asserts")," relationship:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Field assertions target specific dataset columns"),(0,a.yg)("li",{parentName:"ul"},"Volume assertions monitor dataset row counts"),(0,a.yg)("li",{parentName:"ul"},"Freshness assertions track dataset update times"),(0,a.yg)("li",{parentName:"ul"},"Schema assertions validate dataset structure"),(0,a.yg)("li",{parentName:"ul"},"SQL assertions query dataset contents")),(0,a.yg)("p",null,"Datasets maintain a reverse relationship, showing all assertions that validate them. This enables users to understand the quality checks applied to any dataset."),(0,a.yg)("h3",{id:"relationship-to-data-jobs"},"Relationship to Data Jobs"),(0,a.yg)("p",null,"Freshness assertions can target data jobs (pipelines) to ensure they execute on schedule. When a ",(0,a.yg)("inlineCode",{parentName:"p"},"FreshnessAssertionInfo")," has ",(0,a.yg)("inlineCode",{parentName:"p"},"type=DATA_JOB_RUN"),", the ",(0,a.yg)("inlineCode",{parentName:"p"},"entity")," field references a dataJob URN rather than a dataset."),(0,a.yg)("h3",{id:"relationship-to-data-platforms"},"Relationship to Data Platforms"),(0,a.yg)("p",null,"External assertions maintain a relationship to their source platform through the ",(0,a.yg)("inlineCode",{parentName:"p"},"dataPlatformInstance")," aspect. This enables:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Filtering assertions by source tool"),(0,a.yg)("li",{parentName:"ul"},"Deep-linking back to the source platform"),(0,a.yg)("li",{parentName:"ul"},"Understanding the assertion's external context")),(0,a.yg)("h3",{id:"graphql-api"},"GraphQL API"),(0,a.yg)("p",null,"Assertions are fully accessible via DataHub's GraphQL API:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Query assertions and their run history"),(0,a.yg)("li",{parentName:"ul"},"Create and update native assertions"),(0,a.yg)("li",{parentName:"ul"},"Delete assertions"),(0,a.yg)("li",{parentName:"ul"},"Retrieve assertions for a specific dataset")),(0,a.yg)("p",null,"Key GraphQL types:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"Assertion"),": The main assertion entity"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"AssertionInfo"),": Assertion definition and type"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"AssertionRunEvent"),": Evaluation results"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"AssertionSource"),": Origin metadata")),(0,a.yg)("h3",{id:"integration-with-dbt"},"Integration with dbt"),(0,a.yg)("p",null,"DataHub's dbt integration automatically converts dbt tests into assertions:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Schema Tests"),": Mapped to field assertions (not_null, unique, accepted_values, relationships)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Data Tests"),": Mapped to SQL assertions"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Test Metadata"),": Test severity, tags, and descriptions are preserved")),(0,a.yg)("h3",{id:"integration-with-great-expectations"},"Integration with Great Expectations"),(0,a.yg)("p",null,"The Great Expectations integration maps expectations to assertion types:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Column expectations \u2192 Field assertions"),(0,a.yg)("li",{parentName:"ul"},"Table expectations \u2192 Volume or schema assertions"),(0,a.yg)("li",{parentName:"ul"},"Custom expectations \u2192 Custom assertions")),(0,a.yg)("p",null,"Each expectation suite becomes a collection of assertions in DataHub."),(0,a.yg)("h3",{id:"integration-with-snowflake-data-quality"},"Integration with Snowflake Data Quality"),(0,a.yg)("p",null,"Snowflake DMF (Data Metric Functions) rules are ingested as assertions:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Row count rules \u2192 Volume assertions"),(0,a.yg)("li",{parentName:"ul"},"Uniqueness rules \u2192 Field metric assertions"),(0,a.yg)("li",{parentName:"ul"},"Freshness rules \u2192 Freshness assertions"),(0,a.yg)("li",{parentName:"ul"},"Custom metric rules \u2192 SQL assertions")),(0,a.yg)("h2",{id:"notable-exceptions"},"Notable Exceptions"),(0,a.yg)("h3",{id:"legacy-dataset-assertion-type"},"Legacy Dataset Assertion Type"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"DATASET")," assertion type is a legacy format that predates the more specific field, volume, freshness, and schema assertion types. It uses ",(0,a.yg)("inlineCode",{parentName:"p"},"DatasetAssertionInfo")," with a generic structure. New integrations should use the more specific assertion types (FIELD, VOLUME, FRESHNESS, DATA_SCHEMA, SQL) as they provide better type safety and UI rendering."),(0,a.yg)("h3",{id:"assertion-results-vs-assertion-metrics"},"Assertion Results vs. Assertion Metrics"),(0,a.yg)("p",null,"While assertions track pass/fail status, DataHub also supports more detailed metrics through the ",(0,a.yg)("inlineCode",{parentName:"p"},"AssertionResult")," object:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"actualAggValue"),": The actual value observed (for numeric assertions)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"externalUrl"),": Link to detailed results in the source system"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"nativeResults"),": Platform-specific result details")),(0,a.yg)("p",null,"This enables richer debugging and understanding of why assertions fail."),(0,a.yg)("h3",{id:"assertion-scheduling"},"Assertion Scheduling"),(0,a.yg)("p",null,"DataHub tracks when assertions run through ",(0,a.yg)("inlineCode",{parentName:"p"},"assertionRunEvent")," timeseries data, but does not directly schedule assertion evaluations. Scheduling is handled by:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Native Assertions"),": DataHub Cloud's built-in scheduler"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"External Assertions"),": The source platform's scheduler (dbt, Airflow, etc.)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"On-Demand"),": Manual or API-triggered evaluations")),(0,a.yg)("p",null,"DataHub provides monitoring and alerting based on the assertion run events, regardless of the scheduling mechanism."),(0,a.yg)("h3",{id:"assertion-vs-test-results"},"Assertion vs. Test Results"),(0,a.yg)("p",null,"DataHub has two related concepts:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Assertions"),": First-class entities that define data quality rules"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Test Results"),": A simpler aspect that can be attached to datasets")),(0,a.yg)("p",null,"Test results are lightweight pass/fail indicators without the full expressiveness of assertions. Use assertions for production data quality monitoring and test results for simple ingestion-time validation."),(0,a.yg)("h2",{id:"technical-reference-guide"},"Technical Reference Guide"),(0,a.yg)("p",null,"The sections above provide an overview of how to use this entity. The following sections provide detailed technical information about how metadata is stored and represented in DataHub."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Aspects")," are the individual pieces of metadata that can be attached to an entity. Each aspect contains specific information (like ownership, tags, or properties) and is stored as a separate record, allowing for flexible and incremental metadata updates."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Relationships")," show how this entity connects to other entities in the metadata graph. These connections are derived from the fields within each aspect and form the foundation of DataHub's knowledge graph."),(0,a.yg)("h3",{id:"reading-the-field-tables"},"Reading the Field Tables"),(0,a.yg)("p",null,"Each aspect's field table includes an ",(0,a.yg)("strong",{parentName:"p"},"Annotations")," column that provides additional metadata about how fields are used:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"\u26a0\ufe0f Deprecated"),": This field is deprecated and may be removed in a future version. Check the description for the recommended alternative"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Searchable"),": This field is indexed and can be searched in DataHub's search interface"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Searchable (fieldname)"),": When the field name in parentheses is shown, it indicates the field is indexed under a different name in the search index. For example, ",(0,a.yg)("inlineCode",{parentName:"li"},"dashboardTool")," is indexed as ",(0,a.yg)("inlineCode",{parentName:"li"},"tool")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"\u2192 RelationshipName"),": This field creates a relationship to another entity. The arrow indicates this field contains a reference (URN) to another entity, and the name indicates the type of relationship (e.g., ",(0,a.yg)("inlineCode",{parentName:"li"},"\u2192 Contains"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"\u2192 OwnedBy"),")")),(0,a.yg)("p",null,"Fields with complex types (like ",(0,a.yg)("inlineCode",{parentName:"p"},"Edge"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"AuditStamp"),") link to their definitions in the ",(0,a.yg)("a",{parentName:"p",href:"#common-types"},"Common Types")," section below."),(0,a.yg)("h3",{id:"aspects"},"Aspects"),(0,a.yg)("h4",{id:"assertioninfo"},"assertionInfo"),(0,a.yg)("p",null,"Information about an assertion"),(0,a.yg)(s.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"customProperties"),(0,a.yg)("td",{parentName:"tr",align:null},"map"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Custom property bag."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"externalUrl"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"URL where the reference exist"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"type"),(0,a.yg)("td",{parentName:"tr",align:null},"AssertionType"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Type of assertion. Assertion types can evolve to span Datasets, Flows (Pipelines), Models, Featur..."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"datasetAssertion"),(0,a.yg)("td",{parentName:"tr",align:null},"DatasetAssertionInfo"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"A Dataset Assertion definition. This field is populated when the type is DATASET."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"freshnessAssertion"),(0,a.yg)("td",{parentName:"tr",align:null},"FreshnessAssertionInfo"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"An Freshness Assertion definition. This field is populated when the type is FRESHNESS."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"volumeAssertion"),(0,a.yg)("td",{parentName:"tr",align:null},"VolumeAssertionInfo"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"An Volume Assertion definition. This field is populated when the type is VOLUME."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"sqlAssertion"),(0,a.yg)("td",{parentName:"tr",align:null},"SqlAssertionInfo"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"A SQL Assertion definition. This field is populated when the type is SQL."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"fieldAssertion"),(0,a.yg)("td",{parentName:"tr",align:null},"FieldAssertionInfo"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"A Field Assertion definition. This field is populated when the type is FIELD."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"schemaAssertion"),(0,a.yg)("td",{parentName:"tr",align:null},"SchemaAssertionInfo"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"An schema Assertion definition. This field is populated when the type is DATA_SCHEMA"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"customAssertion"),(0,a.yg)("td",{parentName:"tr",align:null},"CustomAssertionInfo"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"A Custom Assertion definition. This field is populated when type is CUSTOM."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"source"),(0,a.yg)("td",{parentName:"tr",align:null},"AssertionSource"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"The source or origin of the Assertion definition.  If the source type of the Assertion is EXTERNA..."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"lastUpdated"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"The time at which the assertion was last updated and the actor who updated it. This field is only..."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"description"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"An optional human-readable description of the assertion"),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "assertionInfo"\n  },\n  "name": "AssertionInfo",\n  "namespace": "com.linkedin.assertion",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "fieldType": "TEXT",\n          "queryByDefault": true\n        }\n      },\n      "type": {\n        "type": "map",\n        "values": "string"\n      },\n      "name": "customProperties",\n      "default": {},\n      "doc": "Custom property bag."\n    },\n    {\n      "Searchable": {\n        "fieldType": "KEYWORD"\n      },\n      "java": {\n        "class": "com.linkedin.common.url.Url",\n        "coercerClass": "com.linkedin.common.url.UrlCoercer"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "externalUrl",\n      "default": null,\n      "doc": "URL where the reference exist"\n    },\n    {\n      "Searchable": {},\n      "type": {\n        "type": "enum",\n        "symbolDocs": {\n          "CUSTOM": "A custom assertion. \\nWhen this is the value, the customAssertion field will be populated.\\nUse this assertion type when the exact type of assertion is not modeled in DataHub or\\nas a starting point when integrating third-party data quality tools.",\n          "DATASET": "A single-dataset assertion.\\nWhen this is the value, the datasetAssertion field will be populated.",\n          "DATA_SCHEMA": "A schema or structural assertion.\\n\\nWould have named this SCHEMA but the codegen for PDL does not allow this (reserved word).",\n          "FIELD": "A structured assertion targeting a specific column or field of the Dataset.",\n          "FRESHNESS": "A freshness assertion, or an assertion which indicates when a particular operation should occur\\nto an asset.",\n          "SQL": "A raw SQL-statement based assertion",\n          "VOLUME": "A volume assertion, or an assertion which indicates how much data should be available for a\\nparticular asset."\n        },\n        "name": "AssertionType",\n        "namespace": "com.linkedin.assertion",\n        "symbols": [\n          "DATASET",\n          "FRESHNESS",\n          "VOLUME",\n          "SQL",\n          "FIELD",\n          "DATA_SCHEMA",\n          "CUSTOM"\n        ]\n      },\n      "name": "type",\n      "doc": "Type of assertion. Assertion types can evolve to span Datasets, Flows (Pipelines), Models, Features etc."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "DatasetAssertionInfo",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "dataset"\n                ],\n                "name": "Asserts"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "dataset",\n              "doc": "The dataset targeted by this assertion."\n            },\n            {\n              "Searchable": {},\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "DATASET_COLUMN": "This assertion applies to dataset column(s)",\n                  "DATASET_ROWS": "This assertion applies to entire rows of the dataset",\n                  "DATASET_SCHEMA": "This assertion applies to the schema of the dataset",\n                  "DATASET_STORAGE_SIZE": "This assertion applies to the storage size of the dataset",\n                  "UNKNOWN": "The scope of the assertion is unknown"\n                },\n                "name": "DatasetAssertionScope",\n                "namespace": "com.linkedin.assertion",\n                "symbols": [\n                  "DATASET_COLUMN",\n                  "DATASET_ROWS",\n                  "DATASET_STORAGE_SIZE",\n                  "DATASET_SCHEMA",\n                  "UNKNOWN"\n                ]\n              },\n              "name": "scope",\n              "doc": "Scope of the Assertion. What part of the dataset does this assertion apply to?"\n            },\n            {\n              "Relationship": {\n                "/*": {\n                  "entityTypes": [\n                    "schemaField"\n                  ],\n                  "name": "Asserts"\n                }\n              },\n              "Searchable": {\n                "/*": {\n                  "fieldType": "URN"\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "array",\n                  "items": "string"\n                }\n              ],\n              "name": "fields",\n              "default": null,\n              "doc": "One or more dataset schema fields that are targeted by this assertion.\\n\\nThis field is expected to be provided if the assertion scope is DATASET_COLUMN."\n            },\n            {\n              "Searchable": {},\n              "type": [\n                "null",\n                {\n                  "type": "enum",\n                  "symbolDocs": {\n                    "COLUMNS": "Assertion is applied on all columns.",\n                    "COLUMN_COUNT": "Assertion is applied on number of columns.",\n                    "IDENTITY": "Assertion is applied on individual column value. (No aggregation)",\n                    "MAX": "Assertion is applied on column std deviation",\n                    "MEAN": "Assertion is applied on column mean",\n                    "MEDIAN": "Assertion is applied on column median",\n                    "MIN": "Assertion is applied on column min",\n                    "NULL_COUNT": "Assertion is applied on number of null values in column",\n                    "NULL_PROPORTION": "Assertion is applied on proportion of null values in column",\n                    "ROW_COUNT": "Assertion is applied on number of rows.",\n                    "STDDEV": "Assertion is applied on column std deviation",\n                    "SUM": "Assertion is applied on column sum",\n                    "UNIQUE_COUNT": "Assertion is applied on number of distinct values in column",\n                    "UNIQUE_PROPORTION": "Assertion is applied on proportion of distinct values in column",\n                    "UNIQUE_PROPOTION": "Assertion is applied on proportion of distinct values in column\\n\\nDeprecated! Use UNIQUE_PROPORTION instead.",\n                    "_NATIVE_": "Other"\n                  },\n                  "name": "AssertionStdAggregation",\n                  "namespace": "com.linkedin.assertion",\n                  "symbols": [\n                    "ROW_COUNT",\n                    "COLUMNS",\n                    "COLUMN_COUNT",\n                    "IDENTITY",\n                    "MEAN",\n                    "MEDIAN",\n                    "UNIQUE_COUNT",\n                    "UNIQUE_PROPORTION",\n                    "UNIQUE_PROPOTION",\n                    "NULL_COUNT",\n                    "NULL_PROPORTION",\n                    "STDDEV",\n                    "MIN",\n                    "MAX",\n                    "SUM",\n                    "_NATIVE_"\n                  ],\n                  "doc": "The function that is applied to the aggregation input (schema, rows, column values) before evaluating an operator."\n                }\n              ],\n              "name": "aggregation",\n              "default": null,\n              "doc": "Standardized assertion operator\\nThis field is left blank if there is no selected aggregation or metric for a particular column."\n            },\n            {\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "BETWEEN": "Value being asserted is between min_value and max_value.  Requires \'minValue\' & \'maxValue\' parameters.",\n                  "CONTAIN": "Value being asserted contains value. Requires \'value\' parameter.",\n                  "END_WITH": "Value being asserted ends with value. Requires \'value\' parameter.",\n                  "EQUAL_TO": "Value being asserted is equal to value. Requires \'value\' parameter.",\n                  "GREATER_THAN": "Value being asserted is greater than some value. Requires \'value\' parameter.",\n                  "GREATER_THAN_OR_EQUAL_TO": "Value being asserted is greater than or equal to some value. Requires \'value\' parameter.",\n                  "IN": "Value being asserted is one of the array values. Requires \'value\' parameter.",\n                  "IS_FALSE": "Value being asserted is false. Requires no parameters.",\n                  "IS_TRUE": "Value being asserted is true. Requires no parameters.",\n                  "LESS_THAN": "Value being asserted is less than a max value. Requires \'value\' parameter.",\n                  "LESS_THAN_OR_EQUAL_TO": "Value being asserted is less than or equal to some value. Requires \'value\' parameter.",\n                  "NOT_EQUAL_TO": "Value being asserted is not equal to value. Requires \'value\' parameter.",\n                  "NOT_IN": "Value being asserted is not in one of the array values. Requires \'value\' parameter.",\n                  "NOT_NULL": "Value being asserted is not null. Requires no parameters.",\n                  "NULL": "Value being asserted is null. Requires no parameters.",\n                  "REGEX_MATCH": "Value being asserted matches the regex value. Requires \'value\' parameter.",\n                  "START_WITH": "Value being asserted starts with value. Requires \'value\' parameter.",\n                  "_NATIVE_": "Other"\n                },\n                "name": "AssertionStdOperator",\n                "namespace": "com.linkedin.assertion",\n                "symbols": [\n                  "BETWEEN",\n                  "LESS_THAN",\n                  "LESS_THAN_OR_EQUAL_TO",\n                  "GREATER_THAN",\n                  "GREATER_THAN_OR_EQUAL_TO",\n                  "EQUAL_TO",\n                  "NOT_EQUAL_TO",\n                  "NULL",\n                  "NOT_NULL",\n                  "CONTAIN",\n                  "END_WITH",\n                  "START_WITH",\n                  "REGEX_MATCH",\n                  "IN",\n                  "NOT_IN",\n                  "IS_TRUE",\n                  "IS_FALSE",\n                  "_NATIVE_"\n                ],\n                "doc": "A boolean operator that is applied on the input to an assertion, after an aggregation function has been applied."\n              },\n              "name": "operator",\n              "doc": "Standardized assertion operator"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "AssertionStdParameters",\n                  "namespace": "com.linkedin.assertion",\n                  "fields": [\n                    {\n                      "type": [\n                        "null",\n                        {\n                          "type": "record",\n                          "name": "AssertionStdParameter",\n                          "namespace": "com.linkedin.assertion",\n                          "fields": [\n                            {\n                              "type": "string",\n                              "name": "value",\n                              "doc": "The parameter value"\n                            },\n                            {\n                              "type": {\n                                "type": "enum",\n                                "symbolDocs": {\n                                  "LIST": "A list of values. When used, value should be formatted as a serialized JSON array.",\n                                  "NUMBER": "A numeric value",\n                                  "SET": "A set of values. When used, value should be formatted as a serialized JSON array.",\n                                  "STRING": "A string value",\n                                  "UNKNOWN": "A value of unknown type"\n                                },\n                                "name": "AssertionStdParameterType",\n                                "namespace": "com.linkedin.assertion",\n                                "symbols": [\n                                  "STRING",\n                                  "NUMBER",\n                                  "LIST",\n                                  "SET",\n                                  "UNKNOWN"\n                                ]\n                              },\n                              "name": "type",\n                              "doc": "The type of the parameter"\n                            }\n                          ],\n                          "doc": "Single parameter for AssertionStdOperators."\n                        }\n                      ],\n                      "name": "value",\n                      "default": null,\n                      "doc": "The value parameter of an assertion"\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "com.linkedin.assertion.AssertionStdParameter"\n                      ],\n                      "name": "maxValue",\n                      "default": null,\n                      "doc": "The maxValue parameter of an assertion"\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "com.linkedin.assertion.AssertionStdParameter"\n                      ],\n                      "name": "minValue",\n                      "default": null,\n                      "doc": "The minValue parameter of an assertion"\n                    }\n                  ],\n                  "doc": "Parameters for AssertionStdOperators."\n                }\n              ],\n              "name": "parameters",\n              "default": null,\n              "doc": "Standard parameters required for the assertion. e.g. min_value, max_value, value, columns"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "nativeType",\n              "default": null,\n              "doc": "Native assertion type"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "map",\n                  "values": "string"\n                }\n              ],\n              "name": "nativeParameters",\n              "default": null,\n              "doc": "Native parameters required for the assertion."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "logic",\n              "default": null\n            }\n          ],\n          "doc": "Attributes that are applicable to single-Dataset Assertions"\n        }\n      ],\n      "name": "datasetAssertion",\n      "default": null,\n      "doc": "A Dataset Assertion definition. This field is populated when the type is DATASET."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "FreshnessAssertionInfo",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Searchable": {},\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "DATASET_CHANGE": "An Freshness based on Operations performed on a particular Dataset (insert, update, delete, etc) and sourced from an audit log, as\\nopposed to based on the highest watermark in a timestamp column (e.g. a query). Only valid when entity is of type \\"dataset\\".",\n                  "DATA_JOB_RUN": "An Freshness based on a successful execution of a Data Job."\n                },\n                "name": "FreshnessAssertionType",\n                "namespace": "com.linkedin.assertion",\n                "symbols": [\n                  "DATASET_CHANGE",\n                  "DATA_JOB_RUN"\n                ]\n              },\n              "name": "type",\n              "doc": "The type of the freshness assertion being monitored."\n            },\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "dataset",\n                  "dataJob"\n                ],\n                "name": "Asserts"\n              },\n              "Searchable": {\n                "fieldType": "URN"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "entity",\n              "doc": "The entity targeted by this Freshness check."\n            },\n            {\n              "Searchable": {\n                "/type": {\n                  "fieldName": "scheduleType"\n                }\n              },\n              "type": {\n                "type": "record",\n                "name": "FreshnessAssertionSchedule",\n                "namespace": "com.linkedin.assertion",\n                "fields": [\n                  {\n                    "type": {\n                      "type": "enum",\n                      "symbolDocs": {\n                        "CRON": "A highly configurable recurring schedule which describes the times of events described\\nby a CRON schedule, with the evaluation schedule assuming to be matching the cron schedule.\\n\\nIn a CRON schedule type, we compute the look-back window to be the time between the last scheduled event\\nand the current event (evaluation time). This means that the evaluation schedule must match exactly\\nthe schedule defined inside the cron schedule.\\n\\nFor example, a CRON schedule defined as \\"0 8 * * *\\" would represent a schedule of \\"every day by 8am\\". Assuming\\nthat the assertion evaluation schedule is defined to match this, the freshness assertion would be evaluated in the following way:\\n\\n    1. Compute the \\"last scheduled occurrence\\" of the event using the CRON schedule. For example, yesterday at 8am.\\n    2. Compute the bounds of a time window between the \\"last scheduled occurrence\\" (yesterday at 8am) until the \\"current occurrence\\" (today at 8am)\\n    3. Verify that the target event has occurred within the CRON-interval window.\\n    4. If the target event has occurred within the time window, then assertion passes.\\n    5. If the target event has not occurred within the time window, then the assertion fails.",\n                        "FIXED_INTERVAL": "A fixed interval which is used to compute a look-back window for use when evaluating the assertion relative\\nto the Evaluation Time of the Assertion.\\n\\nTo compute the valid look-back window, we subtract the fixed interval from the evaluation time. Then, we verify\\nthat the target event has occurred within that window.\\n\\nFor example, a fixed interval of \\"24h\\" would represent a schedule of \\"in the last 24 hours\\".\\nThe 24 hour interval is relative to the evaluation time of the assertion. For example if we schedule the assertion\\nto be evaluated each hour, we\'d compute the result as follows:\\n\\n    1. Subtract the fixed interval from the current time (Evaluation time) to compute the bounds of a fixed look-back window.\\n    2. Verify that the target event has occurred within the look-back window.\\n    3. If the target event has occurred within the time window, then assertion passes.\\n    4. If the target event has not occurred within the time window, then the assertion fails.",\n                        "SINCE_THE_LAST_CHECK": "A stateful check that takes the last time this check ran to determine the look-back window.\\n\\nTo compute the valid look-back- window, we start at the time the monitor last evaluated this assertion,\\nand we end at the point in time the check is currently running.\\n\\nFor example, let\'s say a Freshness assertion is of type SINCE_THE_LAST_CHECK, and the monitor is configured to\\nrun every day at 12:00am. Let\'s assume this assertion was last evaluated yesterday at 12:04am. We\'d compute\\nthe result as follows:\\n\\n    1. Get the timestamp for the last run of the monitor on this assertion.\\n    2. look_back_window_start_time = latest_monitor_run.timestampMillis [ie. 12:04a yesterday]\\n    3. look_back_window_end_time = nowMillis [ie. 12:02a today]\\n    4. If the target event has occurred within the window [ie. 12:04a yday to 12:02a today],\\n       then the assertion passes.\\n    5. If the target event has not occurred within the window, then the assertion fails."\n                      },\n                      "name": "FreshnessAssertionScheduleType",\n                      "namespace": "com.linkedin.assertion",\n                      "symbols": [\n                        "CRON",\n                        "FIXED_INTERVAL",\n                        "SINCE_THE_LAST_CHECK"\n                      ]\n                    },\n                    "name": "type",\n                    "doc": "The type of a Freshness Assertion Schedule.\\n\\nOnce we support data-time-relative schedules (e.g. schedules relative to time partitions),\\nwe will add those schedule types here."\n                  },\n                  {\n                    "type": [\n                      "null",\n                      {\n                        "type": "record",\n                        "name": "FreshnessCronSchedule",\n                        "namespace": "com.linkedin.assertion",\n                        "fields": [\n                          {\n                            "type": "string",\n                            "name": "cron",\n                            "doc": "A cron-formatted execution interval, as a cron string, e.g. 1 * * * *"\n                          },\n                          {\n                            "type": "string",\n                            "name": "timezone",\n                            "doc": "Timezone in which the cron interval applies, e.g. America/Los Angeles"\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "long"\n                            ],\n                            "name": "windowStartOffsetMs",\n                            "default": null,\n                            "doc": "An optional offset in milliseconds to SUBTRACT from the timestamp generated by the cron schedule\\nto generate the lower bounds of the \\"freshness window\\", or the window of time in which an event must have occurred in order for the Freshness check\\nto be considering passing.\\n\\nIf left empty, the start of the SLA window will be the _end_ of the previously evaluated Freshness window."\n                          }\n                        ],\n                        "doc": "Attributes defining a CRON-formatted schedule used for defining a freshness assertion."\n                      }\n                    ],\n                    "name": "cron",\n                    "default": null,\n                    "doc": "A cron schedule. This field is required when type is CRON."\n                  },\n                  {\n                    "type": [\n                      "null",\n                      {\n                        "type": "record",\n                        "name": "FixedIntervalSchedule",\n                        "namespace": "com.linkedin.assertion",\n                        "fields": [\n                          {\n                            "type": {\n                              "type": "enum",\n                              "name": "CalendarInterval",\n                              "namespace": "com.linkedin.timeseries",\n                              "symbols": [\n                                "SECOND",\n                                "MINUTE",\n                                "HOUR",\n                                "DAY",\n                                "WEEK",\n                                "MONTH",\n                                "QUARTER",\n                                "YEAR"\n                              ]\n                            },\n                            "name": "unit",\n                            "doc": "Interval unit such as minute/hour/day etc."\n                          },\n                          {\n                            "type": "int",\n                            "name": "multiple",\n                            "default": 1,\n                            "doc": "How many units. Defaults to 1."\n                          }\n                        ],\n                        "doc": "Attributes defining a relative fixed interval SLA schedule."\n                      }\n                    ],\n                    "name": "fixedInterval",\n                    "default": null,\n                    "doc": "A fixed interval schedule. This field is required when type is FIXED_INTERVAL."\n                  }\n                ],\n                "doc": "Attributes defining a single Freshness schedule."\n              },\n              "name": "schedule",\n              "doc": "Produce FAILURE Assertion Result if the asset is not updated on the cadence and within the time range described by the schedule."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "DatasetFilter",\n                  "namespace": "com.linkedin.dataset",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "enum",\n                        "symbolDocs": {\n                          "SQL": "The partition is represented as a an opaque, raw SQL\\nclause."\n                        },\n                        "name": "DatasetFilterType",\n                        "namespace": "com.linkedin.dataset",\n                        "symbols": [\n                          "SQL"\n                        ]\n                      },\n                      "name": "type",\n                      "doc": "How the partition will be represented in this model.\\n\\nIn the future, we\'ll likely add support for more structured\\npredicates."\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "sql",\n                      "default": null,\n                      "doc": "The raw where clause string which will be used for monitoring.\\nRequired if the type is SQL."\n                    }\n                  ],\n                  "doc": "A definition of filters that should be used when\\nquerying an external Dataset or Table.\\n\\nNote that this models should NOT be used for working with\\nsearch / filter on DataHub Platform itself."\n                }\n              ],\n              "name": "filter",\n              "default": null,\n              "doc": "A definition of the specific filters that should be applied, when performing monitoring.\\nIf not provided, there is no filter, and the full table is under consideration."\n            }\n          ],\n          "doc": "Attributes defining a Freshness Assertion."\n        }\n      ],\n      "name": "freshnessAssertion",\n      "default": null,\n      "doc": "An Freshness Assertion definition. This field is populated when the type is FRESHNESS."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "VolumeAssertionInfo",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Searchable": {},\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "INCREMENTING_SEGMENT_ROW_COUNT_CHANGE": "A volume assertion that compares the row counts in neighboring \\"segments\\" or \\"partitions\\"\\nof an incrementing column.\\nThis can be used to track changes between subsequent date partition\\nin a table, for example.",\n                  "INCREMENTING_SEGMENT_ROW_COUNT_TOTAL": "A volume assertion that checks the latest \\"segment\\" in a table based on an incrementing\\ncolumn to check whether it\'s row count falls into a particular range.\\n\\nThis can be used to monitor the row count of an incrementing date-partition column segment.",\n                  "ROW_COUNT_CHANGE": "A volume assertion that is evaluated against an incremental row count of a dataset,\\nor a row count change.",\n                  "ROW_COUNT_TOTAL": "A volume assertion that is evaluated against the total row count of a dataset."\n                },\n                "name": "VolumeAssertionType",\n                "namespace": "com.linkedin.assertion",\n                "symbols": [\n                  "ROW_COUNT_TOTAL",\n                  "ROW_COUNT_CHANGE",\n                  "INCREMENTING_SEGMENT_ROW_COUNT_TOTAL",\n                  "INCREMENTING_SEGMENT_ROW_COUNT_CHANGE"\n                ]\n              },\n              "name": "type",\n              "doc": "The type of the volume assertion being monitored."\n            },\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "dataset"\n                ],\n                "name": "Asserts"\n              },\n              "Searchable": {\n                "fieldType": "URN"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "entity",\n              "doc": "The entity targeted by this Volume check."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "RowCountTotal",\n                  "namespace": "com.linkedin.assertion",\n                  "fields": [\n                    {\n                      "type": "com.linkedin.assertion.AssertionStdOperator",\n                      "name": "operator",\n                      "doc": "The operator you\'d like to apply.\\n\\nNote that only numeric operators are valid inputs:\\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\\nBETWEEN."\n                    },\n                    {\n                      "type": "com.linkedin.assertion.AssertionStdParameters",\n                      "name": "parameters",\n                      "doc": "The parameters you\'d like to provide as input to the operator.\\n\\nNote that only numeric parameter types are valid inputs: NUMBER."\n                    }\n                  ],\n                  "doc": "Attributes defining a ROW_COUNT_TOTAL volume assertion."\n                }\n              ],\n              "name": "rowCountTotal",\n              "default": null,\n              "doc": "Produce FAILURE Assertion Result if the row count of the asset does not meet specific requirements.\\nRequired if type is \'ROW_COUNT_TOTAL\'"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "RowCountChange",\n                  "namespace": "com.linkedin.assertion",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "enum",\n                        "symbolDocs": {\n                          "ABSOLUTE": "A change that is defined in absolute terms.",\n                          "PERCENTAGE": "A change that is defined in relative terms using percentage change\\nfrom the original value."\n                        },\n                        "name": "AssertionValueChangeType",\n                        "namespace": "com.linkedin.assertion",\n                        "symbols": [\n                          "ABSOLUTE",\n                          "PERCENTAGE"\n                        ],\n                        "doc": "An enum to represent a type of change in an assertion value, metric, or measurement."\n                      },\n                      "name": "type",\n                      "doc": "The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage."\n                    },\n                    {\n                      "type": "com.linkedin.assertion.AssertionStdOperator",\n                      "name": "operator",\n                      "doc": "The operator you\'d like to apply.\\n\\nNote that only numeric operators are valid inputs:\\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\\nBETWEEN."\n                    },\n                    {\n                      "type": "com.linkedin.assertion.AssertionStdParameters",\n                      "name": "parameters",\n                      "doc": "The parameters you\'d like to provide as input to the operator.\\n\\nNote that only numeric parameter types are valid inputs: NUMBER."\n                    }\n                  ],\n                  "doc": "Attributes defining a ROW_COUNT_CHANGE volume assertion."\n                }\n              ],\n              "name": "rowCountChange",\n              "default": null,\n              "doc": "Produce FAILURE Assertion Result if the delta row count of the asset does not meet specific requirements\\nwithin a given period of time.\\nRequired if type is \'ROW_COUNT_CHANGE\'"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "IncrementingSegmentRowCountTotal",\n                  "namespace": "com.linkedin.assertion",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "record",\n                        "name": "IncrementingSegmentSpec",\n                        "namespace": "com.linkedin.assertion",\n                        "fields": [\n                          {\n                            "type": {\n                              "type": "record",\n                              "name": "SchemaFieldSpec",\n                              "namespace": "com.linkedin.schema",\n                              "fields": [\n                                {\n                                  "type": "string",\n                                  "name": "path",\n                                  "doc": "The field path"\n                                },\n                                {\n                                  "type": "string",\n                                  "name": "type",\n                                  "doc": "The DataHub standard schema field type."\n                                },\n                                {\n                                  "type": "string",\n                                  "name": "nativeType",\n                                  "doc": "The native field type"\n                                }\n                              ],\n                              "doc": "Lightweight spec used for referencing a particular schema field."\n                            },\n                            "name": "field",\n                            "doc": "The field to use to generate segments. It must be constantly incrementing as new rows are inserted."\n                          },\n                          {\n                            "type": [\n                              "null",\n                              {\n                                "type": "record",\n                                "name": "IncrementingSegmentFieldTransformer",\n                                "namespace": "com.linkedin.assertion",\n                                "fields": [\n                                  {\n                                    "type": {\n                                      "type": "enum",\n                                      "symbolDocs": {\n                                        "CEILING": "Rounds a numeric value up to the nearest integer.",\n                                        "FLOOR": "Rounds a numeric value down to the nearest integer.",\n                                        "NATIVE": "A backdoor to provide a native operator type specific to a given source system like\\nSnowflake, Redshift, BQ, etc.",\n                                        "TIMESTAMP_MS_TO_DATE": "Rounds a timestamp (in milliseconds) down to the start of the day.",\n                                        "TIMESTAMP_MS_TO_HOUR": "Rounds a timestamp (in milliseconds) down to the nearest hour.",\n                                        "TIMESTAMP_MS_TO_MINUTE": "Rounds a timestamp (in seconds) down to the start of the month.",\n                                        "TIMESTAMP_MS_TO_MONTH": "Rounds a timestamp (in milliseconds) down to the start of the month",\n                                        "TIMESTAMP_MS_TO_YEAR": "Rounds a timestamp (in milliseconds) down to the start of the year"\n                                      },\n                                      "name": "IncrementingSegmentFieldTransformerType",\n                                      "namespace": "com.linkedin.assertion",\n                                      "symbols": [\n                                        "TIMESTAMP_MS_TO_MINUTE",\n                                        "TIMESTAMP_MS_TO_HOUR",\n                                        "TIMESTAMP_MS_TO_DATE",\n                                        "TIMESTAMP_MS_TO_MONTH",\n                                        "TIMESTAMP_MS_TO_YEAR",\n                                        "FLOOR",\n                                        "CEILING",\n                                        "NATIVE"\n                                      ]\n                                    },\n                                    "name": "type",\n                                    "doc": "A \'standard\' transformer type. Note that not all source systems will support all operators."\n                                  },\n                                  {\n                                    "type": [\n                                      "null",\n                                      "string"\n                                    ],\n                                    "name": "nativeType",\n                                    "default": null,\n                                    "doc": "The \'native\' transformer type, useful as a back door if a custom operator is required.\\nThis field is required if the type is NATIVE."\n                                  }\n                                ],\n                                "doc": "The definition of the transformer function  that should be applied to a given field / column value in a dataset\\nin order to determine the segment or bucket that it belongs to, which in turn is used to evaluate\\nvolume assertions."\n                              }\n                            ],\n                            "name": "transformer",\n                            "default": null,\n                            "doc": "Optional transformer function to apply to the field in order to obtain the final segment or bucket identifier.\\nIf not provided, then no operator will be applied to the field. (identity function)"\n                          }\n                        ],\n                        "doc": "Core attributes required to identify an incrementing segment in a table. This type is mainly useful\\nfor tables that constantly increase with new rows being added on a particular cadence (e.g. fact or event tables)\\n\\nAn incrementing segment represents a logical chunk of data which is INSERTED\\ninto a dataset on a regular interval, along with the presence of a constantly-incrementing column\\nvalue such as an event time, date partition, or last modified column.\\n\\nAn incrementing segment is principally identified by 2 key attributes combined:\\n\\n 1. A field or column that represents the incrementing value. New rows that are inserted will be identified using this column.\\n    Note that the value of this column may not by itself represent the \\"bucket\\" or the \\"segment\\" in which the row falls.\\n\\n 2. [Optional] An transformer function that may be applied to the selected column value in order\\n    to obtain the final \\"segment identifier\\" or \\"bucket identifier\\". Rows that have the same value after applying the transformation\\n    will be grouped into the same segment, using which the final value (e.g. row count) will be determined."\n                      },\n                      "name": "segment",\n                      "doc": "A specification of how the \'segment\' can be derived using a column and an optional transformer function."\n                    },\n                    {\n                      "type": "com.linkedin.assertion.AssertionStdOperator",\n                      "name": "operator",\n                      "doc": "The operator you\'d like to apply.\\n\\nNote that only numeric operators are valid inputs:\\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\\nBETWEEN."\n                    },\n                    {\n                      "type": "com.linkedin.assertion.AssertionStdParameters",\n                      "name": "parameters",\n                      "doc": "The parameters you\'d like to provide as input to the operator.\\n\\nNote that only numeric parameter types are valid inputs: NUMBER."\n                    }\n                  ],\n                  "doc": "Attributes defining an INCREMENTING_SEGMENT_ROW_COUNT_TOTAL volume assertion."\n                }\n              ],\n              "name": "incrementingSegmentRowCountTotal",\n              "default": null,\n              "doc": "Produce FAILURE Assertion Result if the asset\'s latest incrementing segment row count total\\ndoes not meet specific requirements. Required if type is \'INCREMENTING_SEGMENT_ROW_COUNT_TOTAL\'"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "IncrementingSegmentRowCountChange",\n                  "namespace": "com.linkedin.assertion",\n                  "fields": [\n                    {\n                      "type": "com.linkedin.assertion.IncrementingSegmentSpec",\n                      "name": "segment",\n                      "doc": "A specification of how the \'segment\' can be derived using a column and an optional transformer function."\n                    },\n                    {\n                      "type": "com.linkedin.assertion.AssertionValueChangeType",\n                      "name": "type",\n                      "doc": "The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage."\n                    },\n                    {\n                      "type": "com.linkedin.assertion.AssertionStdOperator",\n                      "name": "operator",\n                      "doc": "The operator you\'d like to apply to the row count value\\n\\nNote that only numeric operators are valid inputs:\\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\\nBETWEEN."\n                    },\n                    {\n                      "type": "com.linkedin.assertion.AssertionStdParameters",\n                      "name": "parameters",\n                      "doc": "The parameters you\'d like to provide as input to the operator.\\n\\nNote that only numeric parameter types are valid inputs: NUMBER."\n                    }\n                  ],\n                  "doc": "Attributes defining an INCREMENTING_SEGMENT_ROW_COUNT_CHANGE volume assertion."\n                }\n              ],\n              "name": "incrementingSegmentRowCountChange",\n              "default": null,\n              "doc": "Produce FAILURE Assertion Result if the asset\'s incrementing segment row count delta\\ndoes not meet specific requirements. Required if type is \'INCREMENTING_SEGMENT_ROW_COUNT_CHANGE\'"\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.dataset.DatasetFilter"\n              ],\n              "name": "filter",\n              "default": null,\n              "doc": "A definition of the specific filters that should be applied, when performing monitoring.\\nIf not provided, there is no filter, and the full table is under consideration."\n            }\n          ],\n          "doc": "Attributes defining a dataset Volume Assertion"\n        }\n      ],\n      "name": "volumeAssertion",\n      "default": null,\n      "doc": "An Volume Assertion definition. This field is populated when the type is VOLUME."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "SqlAssertionInfo",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Searchable": {},\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "METRIC": "A SQL Metric Assertion, e.g. one based on a numeric value returned by an arbitrary SQL query.",\n                  "METRIC_CHANGE": "A SQL assertion that is evaluated against the CHANGE in a metric assertion\\nover time."\n                },\n                "name": "SqlAssertionType",\n                "namespace": "com.linkedin.assertion",\n                "symbols": [\n                  "METRIC",\n                  "METRIC_CHANGE"\n                ]\n              },\n              "name": "type",\n              "doc": "The type of the SQL assertion being monitored."\n            },\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "dataset"\n                ],\n                "name": "Asserts"\n              },\n              "Searchable": {\n                "fieldType": "URN"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "entity",\n              "doc": "The entity targeted by this SQL check."\n            },\n            {\n              "type": "string",\n              "name": "statement",\n              "doc": "The SQL statement to be executed when evaluating the assertion (or computing the metric).\\nThis should be a valid and complete statement, executable by itself.\\n\\nUsually this should be a SELECT query statement."\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.assertion.AssertionValueChangeType"\n              ],\n              "name": "changeType",\n              "default": null,\n              "doc": "The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage.\\nThis value is required if the type is METRIC_CHANGE."\n            },\n            {\n              "type": "com.linkedin.assertion.AssertionStdOperator",\n              "name": "operator",\n              "doc": "The operator you\'d like to apply to the result of the SQL query.\\n\\nNote that at this time, only numeric operators are valid inputs:\\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\\nBETWEEN."\n            },\n            {\n              "type": "com.linkedin.assertion.AssertionStdParameters",\n              "name": "parameters",\n              "doc": "The parameters you\'d like to provide as input to the operator.\\n\\nNote that only numeric parameter types are valid inputs: NUMBER."\n            }\n          ],\n          "doc": "Attributes defining a SQL Assertion"\n        }\n      ],\n      "name": "sqlAssertion",\n      "default": null,\n      "doc": "A SQL Assertion definition. This field is populated when the type is SQL."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "FieldAssertionInfo",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Searchable": {},\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "FIELD_METRIC": "An assertion used to validate the value of a common field / column metric (e.g. aggregation) such as null count + percentage,\\nmin, max, median, and more.",\n                  "FIELD_VALUES": "An assertion used to validate the values contained with a field / column given a set of rows."\n                },\n                "name": "FieldAssertionType",\n                "namespace": "com.linkedin.assertion",\n                "symbols": [\n                  "FIELD_VALUES",\n                  "FIELD_METRIC"\n                ]\n              },\n              "name": "type",\n              "doc": "The type of the field assertion being monitored."\n            },\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "dataset"\n                ],\n                "name": "Asserts"\n              },\n              "Searchable": {\n                "fieldType": "URN"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "entity",\n              "doc": "The entity targeted by this Field check."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "FieldValuesAssertion",\n                  "namespace": "com.linkedin.assertion",\n                  "fields": [\n                    {\n                      "Searchable": {\n                        "/path": {\n                          "fieldName": "fieldPath"\n                        }\n                      },\n                      "type": "com.linkedin.schema.SchemaFieldSpec",\n                      "name": "field",\n                      "doc": "The field under evaluation"\n                    },\n                    {\n                      "type": [\n                        "null",\n                        {\n                          "type": "record",\n                          "name": "FieldTransform",\n                          "namespace": "com.linkedin.assertion",\n                          "fields": [\n                            {\n                              "type": {\n                                "type": "enum",\n                                "symbolDocs": {\n                                  "LENGTH": "Obtain the length of a string field / column (applicable to string types)"\n                                },\n                                "name": "FieldTransformType",\n                                "namespace": "com.linkedin.assertion",\n                                "symbols": [\n                                  "LENGTH"\n                                ]\n                              },\n                              "name": "type",\n                              "doc": "The type of the field transform, e.g. the transformation\\nfunction / operator to apply."\n                            }\n                          ],\n                          "doc": "Definition of a transform applied to the values of a column / field.\\nNote that the applicability of a field transform ultimately depends on the native type\\nof the field / column.\\n\\nModel has single field to permit extension."\n                        }\n                      ],\n                      "name": "transform",\n                      "default": null,\n                      "doc": "An optional transform to apply to field values\\nbefore evaluating the operator.\\n\\nIf none is applied, the field value will be compared as is."\n                    },\n                    {\n                      "type": "com.linkedin.assertion.AssertionStdOperator",\n                      "name": "operator",\n                      "doc": "The predicate to evaluate against a single value of the field.\\nDepending on the operator, parameters may be required in order to successfully\\nevaluate the assertion against the field value."\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "com.linkedin.assertion.AssertionStdParameters"\n                      ],\n                      "name": "parameters",\n                      "default": null,\n                      "doc": "Standard parameters required for the assertion. e.g. min_value, max_value, value, columns"\n                    },\n                    {\n                      "type": {\n                        "type": "record",\n                        "name": "FieldValuesFailThreshold",\n                        "namespace": "com.linkedin.assertion",\n                        "fields": [\n                          {\n                            "type": {\n                              "type": "enum",\n                              "name": "FieldValuesFailThresholdType",\n                              "namespace": "com.linkedin.assertion",\n                              "symbols": [\n                                "COUNT",\n                                "PERCENTAGE"\n                              ]\n                            },\n                            "name": "type",\n                            "default": "COUNT",\n                            "doc": "The type of failure threshold. Either based on the number\\nof column values (rows) that fail the expectations, or the percentage\\nof the total rows under consideration."\n                          },\n                          {\n                            "type": "long",\n                            "name": "value",\n                            "default": 0,\n                            "doc": "By default this is 0, meaning that ALL column values (i.e. rows) must\\nmeet the defined expectations."\n                          }\n                        ]\n                      },\n                      "name": "failThreshold",\n                      "doc": "Additional customization about when the assertion\\nshould be officially considered failing."\n                    },\n                    {\n                      "type": "boolean",\n                      "name": "excludeNulls",\n                      "default": true,\n                      "doc": "Whether to ignore or allow nulls when running the values assertion. (i.e.\\nconsider only non-null values) using operators OTHER than the IS_NULL operator.\\n\\nDefaults to true, allowing null values."\n                    }\n                  ],\n                  "doc": "Attributes defining a field values assertion, which asserts that the values for a field / column\\nof a dataset / table matches a set of expectations.\\n\\nIn other words, this type of assertion acts as a semantic constraint applied to fields for a specific column.\\n\\nTODO: We should display the \\"failed row count\\" to the user if the column fails the verification rules.\\nTODO: Determine whether we need an \\"operator\\" that can be applied to the field."\n                }\n              ],\n              "name": "fieldValuesAssertion",\n              "default": null,\n              "doc": "The definition of an assertion that validates individual values of a field / column for a set of rows.\\nThis type of assertion verifies that each column value meets a particular requirement."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "FieldMetricAssertion",\n                  "namespace": "com.linkedin.assertion",\n                  "fields": [\n                    {\n                      "Searchable": {\n                        "/path": {\n                          "fieldName": "fieldPath"\n                        }\n                      },\n                      "type": "com.linkedin.schema.SchemaFieldSpec",\n                      "name": "field",\n                      "doc": "The field under evaluation"\n                    },\n                    {\n                      "type": {\n                        "type": "enum",\n                        "symbolDocs": {\n                          "EMPTY_COUNT": "The number of empty string values found in the value set (applies to string columns).\\nNote: This is a completely different metric different from NULL_COUNT!",\n                          "EMPTY_PERCENTAGE": "The percentage of empty string values to total rows for the dataset (applies to string columns)\\nNote: This is a completely different metric different from NULL_PERCENTAGE!",\n                          "MAX": "The maximum value in the column set (applies to numeric columns)",\n                          "MAX_LENGTH": "The maximum length found in the column set (applies to string columns)",\n                          "MEAN": "The mean length found in the column set (applies to numeric columns)",\n                          "MEDIAN": "The median length found in the column set (applies to numeric columns)",\n                          "MIN": "The minimum value in the column set (applies to numeric columns)",\n                          "MIN_LENGTH": "The minimum length found in the column set (applies to string columns)",\n                          "NEGATIVE_COUNT": "The number of negative values found in the value set (applies to numeric columns)",\n                          "NEGATIVE_PERCENTAGE": "The percentage of negative values to total rows for the dataset (applies to numeric columns)",\n                          "NULL_COUNT": "The number of null values found in the column value set",\n                          "NULL_PERCENTAGE": "The percentage of null values to total rows for the dataset",\n                          "STDDEV": "The stddev length found in the column set (applies to numeric columns)",\n                          "UNIQUE_COUNT": "The number of unique values found in the column value set",\n                          "UNIQUE_PERCENTAGE": "The percentage of unique values to total rows for the dataset",\n                          "ZERO_COUNT": "The number of zero values found in the value set (applies to numeric columns)",\n                          "ZERO_PERCENTAGE": "The percentage of zero values to total rows for the dataset (applies to numeric columns)"\n                        },\n                        "name": "FieldMetricType",\n                        "namespace": "com.linkedin.assertion",\n                        "symbols": [\n                          "UNIQUE_COUNT",\n                          "UNIQUE_PERCENTAGE",\n                          "NULL_COUNT",\n                          "NULL_PERCENTAGE",\n                          "MIN",\n                          "MAX",\n                          "MEAN",\n                          "MEDIAN",\n                          "STDDEV",\n                          "NEGATIVE_COUNT",\n                          "NEGATIVE_PERCENTAGE",\n                          "ZERO_COUNT",\n                          "ZERO_PERCENTAGE",\n                          "MIN_LENGTH",\n                          "MAX_LENGTH",\n                          "EMPTY_COUNT",\n                          "EMPTY_PERCENTAGE"\n                        ],\n                        "doc": "A standard metric that can be derived from the set of values\\nfor a specific field / column of a dataset / table."\n                      },\n                      "name": "metric",\n                      "doc": "The specific metric to assert against. This is the value that\\nwill be obtained by applying a standard operation, such as an aggregation,\\nto the selected field."\n                    },\n                    {\n                      "type": "com.linkedin.assertion.AssertionStdOperator",\n                      "name": "operator",\n                      "doc": "The predicate to evaluate against the metric for the field / column.\\nDepending on the operator, parameters may be required in order to successfully\\nevaluate the assertion against the metric value."\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "com.linkedin.assertion.AssertionStdParameters"\n                      ],\n                      "name": "parameters",\n                      "default": null,\n                      "doc": "Standard parameters required for the assertion. e.g. min_value, max_value, value, columns"\n                    }\n                  ],\n                  "doc": "Attributes defining a field metric assertion, which asserts an expectation against\\na common metric derived from the set of field / column values, for example:\\nmax, min, median, null count, null percentage, unique count, unique percentage, and more."\n                }\n              ],\n              "name": "fieldMetricAssertion",\n              "default": null,\n              "doc": "The definition of an assertion that validates a common metric obtained about a field / column for a set of rows.\\nThis type of assertion verifies that the value of a high-level metric obtained by aggregating over a column meets\\nexpectations"\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.dataset.DatasetFilter"\n              ],\n              "name": "filter",\n              "default": null,\n              "doc": "A definition of the specific filters that should be applied, when performing monitoring.\\nIf not provided, there is no filter, and the full table is under consideration.\\nIf using DataHub Dataset Profiles as the assertion source type, the value of this field will be ignored."\n            }\n          ],\n          "doc": "Attributes defining a Field Assertion."\n        }\n      ],\n      "name": "fieldAssertion",\n      "default": null,\n      "doc": "A Field Assertion definition. This field is populated when the type is FIELD."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "SchemaAssertionInfo",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "dataset",\n                  "dataJob"\n                ],\n                "name": "Asserts"\n              },\n              "Searchable": {\n                "fieldType": "URN"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "entity",\n              "doc": "The entity targeted by the assertion"\n            },\n            {\n              "type": {\n                "type": "record",\n                "Aspect": {\n                  "name": "schemaMetadata"\n                },\n                "name": "SchemaMetadata",\n                "namespace": "com.linkedin.schema",\n                "fields": [\n                  {\n                    "validate": {\n                      "strlen": {\n                        "max": 500,\n                        "min": 1\n                      }\n                    },\n                    "type": "string",\n                    "name": "schemaName",\n                    "doc": "Schema name e.g. PageViewEvent, identity.Profile, ams.account_management_tracking"\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.DataPlatformUrn"\n                    },\n                    "type": "string",\n                    "name": "platform",\n                    "doc": "Standardized platform urn where schema is defined. The data platform Urn (urn:li:platform:{platform_name})"\n                  },\n                  {\n                    "type": "long",\n                    "name": "version",\n                    "doc": "Every change to SchemaMetadata in the resource results in a new version. Version is server assigned. This version is differ from platform native schema version."\n                  },\n                  {\n                    "type": {\n                      "type": "record",\n                      "name": "AuditStamp",\n                      "namespace": "com.linkedin.common",\n                      "fields": [\n                        {\n                          "type": "long",\n                          "name": "time",\n                          "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                        },\n                        {\n                          "java": {\n                            "class": "com.linkedin.common.urn.Urn"\n                          },\n                          "type": "string",\n                          "name": "actor",\n                          "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                        },\n                        {\n                          "java": {\n                            "class": "com.linkedin.common.urn.Urn"\n                          },\n                          "type": [\n                            "null",\n                            "string"\n                          ],\n                          "name": "impersonator",\n                          "default": null,\n                          "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                        },\n                        {\n                          "type": [\n                            "null",\n                            "string"\n                          ],\n                          "name": "message",\n                          "default": null,\n                          "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                        }\n                      ],\n                      "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n                    },\n                    "name": "created",\n                    "default": {\n                      "actor": "urn:li:corpuser:unknown",\n                      "impersonator": null,\n                      "time": 0,\n                      "message": null\n                    },\n                    "doc": "An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."\n                  },\n                  {\n                    "type": "com.linkedin.common.AuditStamp",\n                    "name": "lastModified",\n                    "default": {\n                      "actor": "urn:li:corpuser:unknown",\n                      "impersonator": null,\n                      "time": 0,\n                      "message": null\n                    },\n                    "doc": "An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."\n                  },\n                  {\n                    "type": [\n                      "null",\n                      "com.linkedin.common.AuditStamp"\n                    ],\n                    "name": "deleted",\n                    "default": null,\n                    "doc": "An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.DatasetUrn"\n                    },\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "dataset",\n                    "default": null,\n                    "doc": "Dataset this schema metadata is associated with."\n                  },\n                  {\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "cluster",\n                    "default": null,\n                    "doc": "The cluster this schema metadata resides from"\n                  },\n                  {\n                    "type": "string",\n                    "name": "hash",\n                    "doc": "the SHA1 hash of the schema content"\n                  },\n                  {\n                    "type": [\n                      {\n                        "type": "record",\n                        "name": "EspressoSchema",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": "string",\n                            "name": "documentSchema",\n                            "doc": "The native espresso document schema."\n                          },\n                          {\n                            "type": "string",\n                            "name": "tableSchema",\n                            "doc": "The espresso table schema definition."\n                          }\n                        ],\n                        "doc": "Schema text of an espresso table schema."\n                      },\n                      {\n                        "type": "record",\n                        "name": "OracleDDL",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": "string",\n                            "name": "tableSchema",\n                            "doc": "The native schema in the dataset\'s platform. This is a human readable (json blob) table schema."\n                          }\n                        ],\n                        "doc": "Schema holder for oracle data definition language that describes an oracle table."\n                      },\n                      {\n                        "type": "record",\n                        "name": "MySqlDDL",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": "string",\n                            "name": "tableSchema",\n                            "doc": "The native schema in the dataset\'s platform. This is a human readable (json blob) table schema."\n                          }\n                        ],\n                        "doc": "Schema holder for MySql data definition language that describes an MySql table."\n                      },\n                      {\n                        "type": "record",\n                        "name": "PrestoDDL",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": "string",\n                            "name": "rawSchema",\n                            "doc": "The raw schema in the dataset\'s platform. This includes the DDL and the columns extracted from DDL."\n                          }\n                        ],\n                        "doc": "Schema holder for presto data definition language that describes a presto view."\n                      },\n                      {\n                        "type": "record",\n                        "name": "KafkaSchema",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": "string",\n                            "name": "documentSchema",\n                            "doc": "The native kafka document schema. This is a human readable avro document schema."\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "documentSchemaType",\n                            "default": null,\n                            "doc": "The native kafka document schema type. This can be AVRO/PROTOBUF/JSON."\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "keySchema",\n                            "default": null,\n                            "doc": "The native kafka key schema as retrieved from Schema Registry"\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "keySchemaType",\n                            "default": null,\n                            "doc": "The native kafka key schema type. This can be AVRO/PROTOBUF/JSON."\n                          }\n                        ],\n                        "doc": "Schema holder for kafka schema."\n                      },\n                      {\n                        "type": "record",\n                        "name": "BinaryJsonSchema",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": "string",\n                            "name": "schema",\n                            "doc": "The native schema text for binary JSON file format."\n                          }\n                        ],\n                        "doc": "Schema text of binary JSON schema."\n                      },\n                      {\n                        "type": "record",\n                        "name": "OrcSchema",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": "string",\n                            "name": "schema",\n                            "doc": "The native schema for ORC file format."\n                          }\n                        ],\n                        "doc": "Schema text of an ORC schema."\n                      },\n                      {\n                        "type": "record",\n                        "name": "Schemaless",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "The dataset has no specific schema associated with it"\n                      },\n                      {\n                        "type": "record",\n                        "name": "KeyValueSchema",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": "string",\n                            "name": "keySchema",\n                            "doc": "The raw schema for the key in the key-value store."\n                          },\n                          {\n                            "type": "string",\n                            "name": "valueSchema",\n                            "doc": "The raw schema for the value in the key-value store."\n                          }\n                        ],\n                        "doc": "Schema text of a key-value store schema."\n                      },\n                      {\n                        "type": "record",\n                        "name": "OtherSchema",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": "string",\n                            "name": "rawSchema",\n                            "doc": "The native schema in the dataset\'s platform."\n                          }\n                        ],\n                        "doc": "Schema holder for undefined schema types."\n                      }\n                    ],\n                    "name": "platformSchema",\n                    "doc": "The native schema in the dataset\'s platform."\n                  },\n                  {\n                    "type": {\n                      "type": "array",\n                      "items": {\n                        "type": "record",\n                        "name": "SchemaField",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "Searchable": {\n                              "boostScore": 1.0,\n                              "fieldName": "fieldPaths",\n                              "fieldType": "TEXT",\n                              "queryByDefault": "true"\n                            },\n                            "type": "string",\n                            "name": "fieldPath",\n                            "doc": "Flattened name of the field. Field is computed from jsonPath field."\n                          },\n                          {\n                            "Deprecated": true,\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "jsonPath",\n                            "default": null,\n                            "doc": "Flattened name of a field in JSON Path notation."\n                          },\n                          {\n                            "type": "boolean",\n                            "name": "nullable",\n                            "default": false,\n                            "doc": "Indicates if this field is optional or nullable"\n                          },\n                          {\n                            "Searchable": {\n                              "boostScore": 0.1,\n                              "fieldName": "fieldDescriptions",\n                              "fieldType": "TEXT"\n                            },\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "description",\n                            "default": null,\n                            "doc": "Description"\n                          },\n                          {\n                            "Deprecated": true,\n                            "Searchable": {\n                              "boostScore": 0.2,\n                              "fieldName": "fieldLabels",\n                              "fieldType": "TEXT"\n                            },\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "label",\n                            "default": null,\n                            "doc": "Label of the field. Provides a more human-readable name for the field than field path. Some sources will\\nprovide this metadata but not all sources have the concept of a label. If just one string is associated with\\na field in a source, that is most likely a description.\\n\\nNote that this field is deprecated and is not surfaced in the UI."\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "com.linkedin.common.AuditStamp"\n                            ],\n                            "name": "created",\n                            "default": null,\n                            "doc": "An AuditStamp corresponding to the creation of this schema field."\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "com.linkedin.common.AuditStamp"\n                            ],\n                            "name": "lastModified",\n                            "default": null,\n                            "doc": "An AuditStamp corresponding to the last modification of this schema field."\n                          },\n                          {\n                            "type": {\n                              "type": "record",\n                              "name": "SchemaFieldDataType",\n                              "namespace": "com.linkedin.schema",\n                              "fields": [\n                                {\n                                  "type": [\n                                    {\n                                      "type": "record",\n                                      "name": "BooleanType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [],\n                                      "doc": "Boolean field type."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "FixedType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [],\n                                      "doc": "Fixed field type."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "StringType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [],\n                                      "doc": "String field type."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "BytesType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [],\n                                      "doc": "Bytes field type."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "NumberType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [],\n                                      "doc": "Number data type: long, integer, short, etc.."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "DateType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [],\n                                      "doc": "Date field type."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "TimeType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [],\n                                      "doc": "Time field type. This should also be used for datetimes."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "EnumType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [],\n                                      "doc": "Enum field type."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "NullType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [],\n                                      "doc": "Null field type."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "MapType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [\n                                        {\n                                          "type": [\n                                            "null",\n                                            "string"\n                                          ],\n                                          "name": "keyType",\n                                          "default": null,\n                                          "doc": "Key type in a map"\n                                        },\n                                        {\n                                          "type": [\n                                            "null",\n                                            "string"\n                                          ],\n                                          "name": "valueType",\n                                          "default": null,\n                                          "doc": "Type of the value in a map"\n                                        }\n                                      ],\n                                      "doc": "Map field type."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "ArrayType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [\n                                        {\n                                          "type": [\n                                            "null",\n                                            {\n                                              "type": "array",\n                                              "items": "string"\n                                            }\n                                          ],\n                                          "name": "nestedType",\n                                          "default": null,\n                                          "doc": "List of types this array holds."\n                                        }\n                                      ],\n                                      "doc": "Array field type."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "UnionType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [\n                                        {\n                                          "type": [\n                                            "null",\n                                            {\n                                              "type": "array",\n                                              "items": "string"\n                                            }\n                                          ],\n                                          "name": "nestedTypes",\n                                          "default": null,\n                                          "doc": "List of types in union type."\n                                        }\n                                      ],\n                                      "doc": "Union field type."\n                                    },\n                                    {\n                                      "type": "record",\n                                      "name": "RecordType",\n                                      "namespace": "com.linkedin.schema",\n                                      "fields": [],\n                                      "doc": "Record field type."\n                                    }\n                                  ],\n                                  "name": "type",\n                                  "doc": "Data platform specific types"\n                                }\n                              ],\n                              "doc": "Schema field data types"\n                            },\n                            "name": "type",\n                            "doc": "Platform independent field type of the field."\n                          },\n                          {\n                            "type": "string",\n                            "name": "nativeDataType",\n                            "doc": "The native type of the field in the dataset\'s platform as declared by platform schema."\n                          },\n                          {\n                            "type": "boolean",\n                            "name": "recursive",\n                            "default": false,\n                            "doc": "There are use cases when a field in type B references type A. A field in A references field of type B. In such cases, we will mark the first field as recursive."\n                          },\n                          {\n                            "Relationship": {\n                              "/tags/*/tag": {\n                                "entityTypes": [\n                                  "tag"\n                                ],\n                                "name": "SchemaFieldTaggedWith"\n                              }\n                            },\n                            "Searchable": {\n                              "/tags/*/attribution/actor": {\n                                "fieldName": "fieldTagAttributionActors",\n                                "fieldType": "URN",\n                                "queryByDefault": false\n                              },\n                              "/tags/*/attribution/source": {\n                                "fieldName": "fieldTagAttributionSources",\n                                "fieldType": "URN",\n                                "queryByDefault": false\n                              },\n                              "/tags/*/attribution/time": {\n                                "fieldName": "fieldTagAttributionDates",\n                                "fieldType": "DATETIME",\n                                "queryByDefault": false\n                              },\n                              "/tags/*/tag": {\n                                "boostScore": 0.5,\n                                "fieldName": "fieldTags",\n                                "fieldType": "URN"\n                              }\n                            },\n                            "type": [\n                              "null",\n                              {\n                                "type": "record",\n                                "Aspect": {\n                                  "name": "globalTags"\n                                },\n                                "name": "GlobalTags",\n                                "namespace": "com.linkedin.common",\n                                "fields": [\n                                  {\n                                    "Relationship": {\n                                      "/*/tag": {\n                                        "entityTypes": [\n                                          "tag"\n                                        ],\n                                        "name": "TaggedWith"\n                                      }\n                                    },\n                                    "Searchable": {\n                                      "/*/tag": {\n                                        "addToFilters": true,\n                                        "boostScore": 0.5,\n                                        "fieldName": "tags",\n                                        "fieldType": "URN",\n                                        "filterNameOverride": "Tag",\n                                        "hasValuesFieldName": "hasTags",\n                                        "queryByDefault": true\n                                      }\n                                    },\n                                    "type": {\n                                      "type": "array",\n                                      "items": {\n                                        "type": "record",\n                                        "name": "TagAssociation",\n                                        "namespace": "com.linkedin.common",\n                                        "fields": [\n                                          {\n                                            "java": {\n                                              "class": "com.linkedin.common.urn.TagUrn"\n                                            },\n                                            "type": "string",\n                                            "name": "tag",\n                                            "doc": "Urn of the applied tag"\n                                          },\n                                          {\n                                            "type": [\n                                              "null",\n                                              "string"\n                                            ],\n                                            "name": "context",\n                                            "default": null,\n                                            "doc": "Additional context about the association"\n                                          },\n                                          {\n                                            "Searchable": {\n                                              "/actor": {\n                                                "fieldName": "tagAttributionActors",\n                                                "fieldType": "URN",\n                                                "queryByDefault": false\n                                              },\n                                              "/source": {\n                                                "fieldName": "tagAttributionSources",\n                                                "fieldType": "URN",\n                                                "queryByDefault": false\n                                              },\n                                              "/time": {\n                                                "fieldName": "tagAttributionDates",\n                                                "fieldType": "DATETIME",\n                                                "queryByDefault": false\n                                              }\n                                            },\n                                            "type": [\n                                              "null",\n                                              {\n                                                "type": "record",\n                                                "name": "MetadataAttribution",\n                                                "namespace": "com.linkedin.common",\n                                                "fields": [\n                                                  {\n                                                    "type": "long",\n                                                    "name": "time",\n                                                    "doc": "When this metadata was updated."\n                                                  },\n                                                  {\n                                                    "java": {\n                                                      "class": "com.linkedin.common.urn.Urn"\n                                                    },\n                                                    "type": "string",\n                                                    "name": "actor",\n                                                    "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                                                  },\n                                                  {\n                                                    "java": {\n                                                      "class": "com.linkedin.common.urn.Urn"\n                                                    },\n                                                    "type": [\n                                                      "null",\n                                                      "string"\n                                                    ],\n                                                    "name": "source",\n                                                    "default": null,\n                                                    "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                                                  },\n                                                  {\n                                                    "type": {\n                                                      "type": "map",\n                                                      "values": "string"\n                                                    },\n                                                    "name": "sourceDetail",\n                                                    "default": {},\n                                                    "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                                                  }\n                                                ],\n                                                "doc": "Information about who, why, and how this metadata was applied"\n                                              }\n                                            ],\n                                            "name": "attribution",\n                                            "default": null,\n                                            "doc": "Information about who, why, and how this metadata was applied"\n                                          }\n                                        ],\n                                        "doc": "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\\npropagation parameters."\n                                      }\n                                    },\n                                    "name": "tags",\n                                    "doc": "Tags associated with a given entity"\n                                  }\n                                ],\n                                "doc": "Tag aspect used for applying tags to an entity"\n                              }\n                            ],\n                            "name": "globalTags",\n                            "default": null,\n                            "doc": "Tags associated with the field"\n                          },\n                          {\n                            "Relationship": {\n                              "/terms/*/urn": {\n                                "entityTypes": [\n                                  "glossaryTerm"\n                                ],\n                                "name": "SchemaFieldWithGlossaryTerm"\n                              }\n                            },\n                            "Searchable": {\n                              "/terms/*/attribution/actor": {\n                                "fieldName": "fieldTermAttributionActors",\n                                "fieldType": "URN",\n                                "queryByDefault": false\n                              },\n                              "/terms/*/attribution/source": {\n                                "fieldName": "fieldTermAttributionSources",\n                                "fieldType": "URN",\n                                "queryByDefault": false\n                              },\n                              "/terms/*/attribution/time": {\n                                "fieldName": "fieldTermAttributionDates",\n                                "fieldType": "DATETIME",\n                                "queryByDefault": false\n                              },\n                              "/terms/*/urn": {\n                                "boostScore": 0.5,\n                                "fieldName": "fieldGlossaryTerms",\n                                "fieldType": "URN"\n                              }\n                            },\n                            "type": [\n                              "null",\n                              {\n                                "type": "record",\n                                "Aspect": {\n                                  "name": "glossaryTerms"\n                                },\n                                "name": "GlossaryTerms",\n                                "namespace": "com.linkedin.common",\n                                "fields": [\n                                  {\n                                    "type": {\n                                      "type": "array",\n                                      "items": {\n                                        "type": "record",\n                                        "name": "GlossaryTermAssociation",\n                                        "namespace": "com.linkedin.common",\n                                        "fields": [\n                                          {\n                                            "Relationship": {\n                                              "entityTypes": [\n                                                "glossaryTerm"\n                                              ],\n                                              "name": "TermedWith"\n                                            },\n                                            "Searchable": {\n                                              "addToFilters": true,\n                                              "fieldName": "glossaryTerms",\n                                              "fieldType": "URN",\n                                              "filterNameOverride": "Glossary Term",\n                                              "hasValuesFieldName": "hasGlossaryTerms",\n                                              "includeSystemModifiedAt": true,\n                                              "systemModifiedAtFieldName": "termsModifiedAt"\n                                            },\n                                            "java": {\n                                              "class": "com.linkedin.common.urn.GlossaryTermUrn"\n                                            },\n                                            "type": "string",\n                                            "name": "urn",\n                                            "doc": "Urn of the applied glossary term"\n                                          },\n                                          {\n                                            "java": {\n                                              "class": "com.linkedin.common.urn.Urn"\n                                            },\n                                            "type": [\n                                              "null",\n                                              "string"\n                                            ],\n                                            "name": "actor",\n                                            "default": null,\n                                            "doc": "The user URN which will be credited for adding associating this term to the entity"\n                                          },\n                                          {\n                                            "type": [\n                                              "null",\n                                              "string"\n                                            ],\n                                            "name": "context",\n                                            "default": null,\n                                            "doc": "Additional context about the association"\n                                          },\n                                          {\n                                            "Searchable": {\n                                              "/actor": {\n                                                "fieldName": "termAttributionActors",\n                                                "fieldType": "URN",\n                                                "queryByDefault": false\n                                              },\n                                              "/source": {\n                                                "fieldName": "termAttributionSources",\n                                                "fieldType": "URN",\n                                                "queryByDefault": false\n                                              },\n                                              "/time": {\n                                                "fieldName": "termAttributionDates",\n                                                "fieldType": "DATETIME",\n                                                "queryByDefault": false\n                                              }\n                                            },\n                                            "type": [\n                                              "null",\n                                              "com.linkedin.common.MetadataAttribution"\n                                            ],\n                                            "name": "attribution",\n                                            "default": null,\n                                            "doc": "Information about who, why, and how this metadata was applied"\n                                          }\n                                        ],\n                                        "doc": "Properties of an applied glossary term."\n                                      }\n                                    },\n                                    "name": "terms",\n                                    "doc": "The related business terms"\n                                  },\n                                  {\n                                    "type": "com.linkedin.common.AuditStamp",\n                                    "name": "auditStamp",\n                                    "doc": "Audit stamp containing who reported the related business term"\n                                  }\n                                ],\n                                "doc": "Related business terms information"\n                              }\n                            ],\n                            "name": "glossaryTerms",\n                            "default": null,\n                            "doc": "Glossary terms associated with the field"\n                          },\n                          {\n                            "type": "boolean",\n                            "name": "isPartOfKey",\n                            "default": false,\n                            "doc": "For schema fields that are part of complex keys, set this field to true\\nWe do this to easily distinguish between value and key fields"\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "boolean"\n                            ],\n                            "name": "isPartitioningKey",\n                            "default": null,\n                            "doc": "For Datasets which are partitioned, this determines the partitioning key.\\nNote that multiple columns can be part of a partitioning key, but currently we do not support\\nrendering the ordered partitioning key."\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "jsonProps",\n                            "default": null,\n                            "doc": "For schema fields that have other properties that are not modeled explicitly,\\nuse this field to serialize those properties into a JSON string"\n                          }\n                        ],\n                        "doc": "SchemaField to describe metadata related to dataset schema."\n                      }\n                    },\n                    "name": "fields",\n                    "doc": "Client provided a list of fields from document schema."\n                  },\n                  {\n                    "type": [\n                      "null",\n                      {\n                        "type": "array",\n                        "items": "string"\n                      }\n                    ],\n                    "name": "primaryKeys",\n                    "default": null,\n                    "doc": "Client provided list of fields that define primary keys to access record. Field order defines hierarchical espresso keys. Empty lists indicates absence of primary key access patter. Value is a SchemaField@fieldPath."\n                  },\n                  {\n                    "deprecated": "Use foreignKeys instead.",\n                    "type": [\n                      "null",\n                      {\n                        "type": "map",\n                        "values": {\n                          "type": "record",\n                          "name": "ForeignKeySpec",\n                          "namespace": "com.linkedin.schema",\n                          "fields": [\n                            {\n                              "type": [\n                                {\n                                  "type": "record",\n                                  "name": "DatasetFieldForeignKey",\n                                  "namespace": "com.linkedin.schema",\n                                  "fields": [\n                                    {\n                                      "java": {\n                                        "class": "com.linkedin.common.urn.DatasetUrn"\n                                      },\n                                      "type": "string",\n                                      "name": "parentDataset",\n                                      "doc": "dataset that stores the resource."\n                                    },\n                                    {\n                                      "type": {\n                                        "type": "array",\n                                        "items": "string"\n                                      },\n                                      "name": "currentFieldPaths",\n                                      "doc": "List of fields in hosting(current) SchemaMetadata that conform a foreign key. List can contain a single entry or multiple entries if several entries in hosting schema conform a foreign key in a single parent dataset."\n                                    },\n                                    {\n                                      "type": "string",\n                                      "name": "parentField",\n                                      "doc": "SchemaField@fieldPath that uniquely identify field in parent dataset that this field references."\n                                    }\n                                  ],\n                                  "doc": "For non-urn based foregin keys."\n                                },\n                                {\n                                  "type": "record",\n                                  "name": "UrnForeignKey",\n                                  "namespace": "com.linkedin.schema",\n                                  "fields": [\n                                    {\n                                      "type": "string",\n                                      "name": "currentFieldPath",\n                                      "doc": "Field in hosting(current) SchemaMetadata."\n                                    }\n                                  ],\n                                  "doc": "If SchemaMetadata fields make any external references and references are of type com.linkedin.common.Urn or any children, this models can be used to mark it."\n                                }\n                              ],\n                              "name": "foreignKey",\n                              "doc": "Foreign key definition in metadata schema."\n                            }\n                          ],\n                          "doc": "Description of a foreign key in a schema."\n                        }\n                      }\n                    ],\n                    "name": "foreignKeysSpecs",\n                    "default": null,\n                    "doc": "Map captures all the references schema makes to external datasets. Map key is ForeignKeySpecName typeref."\n                  },\n                  {\n                    "type": [\n                      "null",\n                      {\n                        "type": "array",\n                        "items": {\n                          "type": "record",\n                          "name": "ForeignKeyConstraint",\n                          "namespace": "com.linkedin.schema",\n                          "fields": [\n                            {\n                              "type": "string",\n                              "name": "name",\n                              "doc": "Name of the constraint, likely provided from the source"\n                            },\n                            {\n                              "Relationship": {\n                                "/*": {\n                                  "entityTypes": [\n                                    "schemaField"\n                                  ],\n                                  "name": "ForeignKeyTo"\n                                }\n                              },\n                              "type": {\n                                "type": "array",\n                                "items": "string"\n                              },\n                              "name": "foreignFields",\n                              "doc": "Fields the constraint maps to on the foreign dataset"\n                            },\n                            {\n                              "type": {\n                                "type": "array",\n                                "items": "string"\n                              },\n                              "name": "sourceFields",\n                              "doc": "Fields the constraint maps to on the source dataset"\n                            },\n                            {\n                              "Relationship": {\n                                "entityTypes": [\n                                  "dataset"\n                                ],\n                                "name": "ForeignKeyToDataset"\n                              },\n                              "java": {\n                                "class": "com.linkedin.common.urn.Urn"\n                              },\n                              "type": "string",\n                              "name": "foreignDataset",\n                              "doc": "Reference to the foreign dataset for ease of lookup"\n                            }\n                          ],\n                          "doc": "Description of a foreign key constraint in a schema."\n                        }\n                      }\n                    ],\n                    "name": "foreignKeys",\n                    "default": null,\n                    "doc": "List of foreign key constraints for the schema"\n                  }\n                ],\n                "doc": "SchemaMetadata to describe metadata related to store schema"\n              },\n              "name": "schema",\n              "doc": "A definition of the expected structure for the asset\\n\\nNote that many of the fields of this model, especially those related to metadata (tags, terms)\\nwill go unused in this context."\n            },\n            {\n              "type": [\n                {\n                  "type": "enum",\n                  "symbolDocs": {\n                    "EXACT_MATCH": "The actual schema must be exactly the same as the expected schema",\n                    "SUBSET": "The actual schema must be a subset of the expected schema",\n                    "SUPERSET": "The actual schema must be a superset of the expected schema"\n                  },\n                  "name": "SchemaAssertionCompatibility",\n                  "namespace": "com.linkedin.assertion",\n                  "symbols": [\n                    "EXACT_MATCH",\n                    "SUPERSET",\n                    "SUBSET"\n                  ]\n                },\n                "null"\n              ],\n              "name": "compatibility",\n              "default": "EXACT_MATCH",\n              "doc": "The required compatibility level for the schema assertion to pass."\n            }\n          ],\n          "doc": "Attributes that are applicable to schema assertions"\n        }\n      ],\n      "name": "schemaAssertion",\n      "default": null,\n      "doc": "An schema Assertion definition. This field is populated when the type is DATA_SCHEMA"\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "CustomAssertionInfo",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Searchable": {\n                "fieldName": "customType"\n              },\n              "type": "string",\n              "name": "type",\n              "doc": "The type of custom assertion.\\nThis is how your assertion will appear categorized in DataHub UI. "\n            },\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "dataset"\n                ],\n                "name": "Asserts"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "entity",\n              "doc": "The entity targeted by this assertion.\\nThis can have support more entityTypes (e.g. dataJob) in future"\n            },\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "schemaField"\n                ],\n                "name": "Asserts"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "field",\n              "default": null,\n              "doc": "dataset schema field targeted by this assertion.\\n\\nThis field is expected to be provided if the assertion is on dataset field"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "logic",\n              "default": null\n            }\n          ],\n          "doc": "Attributes that are applicable to Custom Assertions"\n        }\n      ],\n      "name": "customAssertion",\n      "default": null,\n      "doc": "A Custom Assertion definition. This field is populated when type is CUSTOM."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "AssertionSource",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Searchable": {\n                "fieldName": "sourceType"\n              },\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "EXTERNAL": "The assertion was defined and managed externally of DataHub.",\n                  "INFERRED": "The assertion was inferred, e.g. from offline AI / ML models.\\nDataHub Cloud only",\n                  "NATIVE": "The assertion was defined natively on DataHub by a user.\\nDataHub Cloud only"\n                },\n                "name": "AssertionSourceType",\n                "namespace": "com.linkedin.assertion",\n                "symbols": [\n                  "NATIVE",\n                  "EXTERNAL",\n                  "INFERRED"\n                ]\n              },\n              "name": "type",\n              "doc": "The type of the Assertion Source"\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "created",\n              "default": null,\n              "doc": "The time at which the assertion was initially created and the author who created it.\\nThis field is only present for Native assertions created after this field was introduced."\n            }\n          ],\n          "doc": "The source of an assertion"\n        }\n      ],\n      "name": "source",\n      "default": null,\n      "doc": "The source or origin of the Assertion definition.\\n\\nIf the source type of the Assertion is EXTERNAL, it is expected to have a corresponding dataPlatformInstance aspect detailing\\nthe platform where it was ingested from."\n    },\n    {\n      "type": [\n        "null",\n        "com.linkedin.common.AuditStamp"\n      ],\n      "name": "lastUpdated",\n      "default": null,\n      "doc": "The time at which the assertion was last updated and the actor who updated it.\\nThis field is only present for Native assertions updated after this field was introduced."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "description",\n      "default": null,\n      "doc": "An optional human-readable description of the assertion"\n    }\n  ],\n  "doc": "Information about an assertion"\n}\n')))),(0,a.yg)("h4",{id:"dataplatforminstance"},"dataPlatformInstance"),(0,a.yg)("p",null,"The specific instance of the data platform that this entity belongs to"),(0,a.yg)(s.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"platform"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Data Platform"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"instance"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Instance of the data platform (e.g. db instance)"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable (platformInstance)"))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "dataPlatformInstance"\n  },\n  "name": "DataPlatformInstance",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldType": "URN",\n        "filterNameOverride": "Platform"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "platform",\n      "doc": "Data Platform"\n    },\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldName": "platformInstance",\n        "fieldType": "URN",\n        "filterNameOverride": "Platform Instance"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "instance",\n      "default": null,\n      "doc": "Instance of the data platform (e.g. db instance)"\n    }\n  ],\n  "doc": "The specific instance of the data platform that this entity belongs to"\n}\n')))),(0,a.yg)("h4",{id:"assertionactions"},"assertionActions"),(0,a.yg)("p",null,"The Actions about an Assertion"),(0,a.yg)(s.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"onSuccess"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#assertionaction"},"AssertionAction"),"[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Actions to be executed on successful assertion run."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"onFailure"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#assertionaction"},"AssertionAction"),"[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Actions to be executed on failed assertion run."),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "assertionActions"\n  },\n  "name": "AssertionActions",\n  "namespace": "com.linkedin.assertion",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "AssertionAction",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "RAISE_INCIDENT": "Raise an incident.",\n                  "RESOLVE_INCIDENT": "Resolve open incidents related to the assertion."\n                },\n                "name": "AssertionActionType",\n                "namespace": "com.linkedin.assertion",\n                "symbols": [\n                  "RAISE_INCIDENT",\n                  "RESOLVE_INCIDENT"\n                ]\n              },\n              "name": "type",\n              "doc": "The type of the Action"\n            }\n          ],\n          "doc": "The Actions about an Assertion.\\nIn the future, we\'ll likely extend this model to support additional\\nparameters or options related to the assertion actions."\n        }\n      },\n      "name": "onSuccess",\n      "default": [],\n      "doc": "Actions to be executed on successful assertion run."\n    },\n    {\n      "type": {\n        "type": "array",\n        "items": "com.linkedin.assertion.AssertionAction"\n      },\n      "name": "onFailure",\n      "default": [],\n      "doc": "Actions to be executed on failed assertion run."\n    }\n  ],\n  "doc": "The Actions about an Assertion"\n}\n')))),(0,a.yg)("h4",{id:"status"},"status"),(0,a.yg)("p",null,"The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\nThis aspect is used to represent soft deletes conventionally."),(0,a.yg)(s.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"removed"),(0,a.yg)("td",{parentName:"tr",align:null},"boolean"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Whether the entity has been removed (soft-deleted)."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "status"\n  },\n  "name": "Status",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN"\n      },\n      "type": "boolean",\n      "name": "removed",\n      "default": false,\n      "doc": "Whether the entity has been removed (soft-deleted)."\n    }\n  ],\n  "doc": "The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\\nThis aspect is used to represent soft deletes conventionally."\n}\n')))),(0,a.yg)("h4",{id:"globaltags"},"globalTags"),(0,a.yg)("p",null,"Tag aspect used for applying tags to an entity"),(0,a.yg)(s.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"tags"),(0,a.yg)("td",{parentName:"tr",align:null},"TagAssociation[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Tags associated with a given entity"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable, \u2192 TaggedWith"))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "globalTags"\n  },\n  "name": "GlobalTags",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Relationship": {\n        "/*/tag": {\n          "entityTypes": [\n            "tag"\n          ],\n          "name": "TaggedWith"\n        }\n      },\n      "Searchable": {\n        "/*/tag": {\n          "addToFilters": true,\n          "boostScore": 0.5,\n          "fieldName": "tags",\n          "fieldType": "URN",\n          "filterNameOverride": "Tag",\n          "hasValuesFieldName": "hasTags",\n          "queryByDefault": true\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "TagAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.TagUrn"\n              },\n              "type": "string",\n              "name": "tag",\n              "doc": "Urn of the applied tag"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "context",\n              "default": null,\n              "doc": "Additional context about the association"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "tagAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "tagAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "tagAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ],\n          "doc": "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\\npropagation parameters."\n        }\n      },\n      "name": "tags",\n      "doc": "Tags associated with a given entity"\n    }\n  ],\n  "doc": "Tag aspect used for applying tags to an entity"\n}\n')))),(0,a.yg)("h4",{id:"assertionrunevent-timeseries"},"assertionRunEvent (Timeseries)"),(0,a.yg)("p",null,"An event representing the current status of evaluating an assertion on a batch.\nAssertionRunEvent should be used for reporting the status of a run as an assertion evaluation progresses."),(0,a.yg)(s.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"timestampMillis"),(0,a.yg)("td",{parentName:"tr",align:null},"long"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"The event timestamp field as epoch at UTC in milli seconds."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable (lastCompletedTime)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"runId"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Native (platform-specific) identifier for this run"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"asserteeUrn"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"status"),(0,a.yg)("td",{parentName:"tr",align:null},"AssertionRunStatus"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"The status of the assertion run as per this timeseries event."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"result"),(0,a.yg)("td",{parentName:"tr",align:null},"AssertionResult"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Results of assertion, present if the status is COMPLETE"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"runtimeContext"),(0,a.yg)("td",{parentName:"tr",align:null},"map"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Runtime parameters of evaluation"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"batchSpec"),(0,a.yg)("td",{parentName:"tr",align:null},"BatchSpec"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Specification of the batch which this run is evaluating"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"assertionUrn"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"eventGranularity"),(0,a.yg)("td",{parentName:"tr",align:null},"TimeWindowSize"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Granularity of the event if applicable"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"partitionSpec"),(0,a.yg)("td",{parentName:"tr",align:null},"PartitionSpec"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"The optional partition specification."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"messageId"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"The optional messageId, if provided serves as a custom user-defined unique identifier for an aspe..."),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "assertionRunEvent",\n    "type": "timeseries"\n  },\n  "name": "AssertionRunEvent",\n  "namespace": "com.linkedin.assertion",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldName": "lastCompletedTime",\n        "fieldType": "DATETIME"\n      },\n      "type": "long",\n      "name": "timestampMillis",\n      "doc": "The event timestamp field as epoch at UTC in milli seconds."\n    },\n    {\n      "type": "string",\n      "name": "runId",\n      "doc": " Native (platform-specific) identifier for this run"\n    },\n    {\n      "TimeseriesField": {},\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "asserteeUrn"\n    },\n    {\n      "TimeseriesField": {},\n      "type": {\n        "type": "enum",\n        "symbolDocs": {\n          "COMPLETE": "The Assertion Run has completed"\n        },\n        "name": "AssertionRunStatus",\n        "namespace": "com.linkedin.assertion",\n        "symbols": [\n          "COMPLETE"\n        ],\n        "doc": "The lifecycle status of an assertion run."\n      },\n      "name": "status",\n      "doc": "The status of the assertion run as per this timeseries event."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "AssertionResult",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Searchable": {},\n              "TimeseriesField": {},\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "ERROR": " The Assertion encountered an Error",\n                  "FAILURE": " The Assertion Failed",\n                  "INIT": " The Assertion has not yet been fully evaluated",\n                  "SUCCESS": " The Assertion Succeeded"\n                },\n                "name": "AssertionResultType",\n                "namespace": "com.linkedin.assertion",\n                "symbols": [\n                  "INIT",\n                  "SUCCESS",\n                  "FAILURE",\n                  "ERROR"\n                ],\n                "doc": " The final result of evaluating an assertion, e.g. SUCCESS, FAILURE, or ERROR."\n              },\n              "name": "type",\n              "doc": " The final result, e.g. either SUCCESS, FAILURE, or ERROR."\n            },\n            {\n              "type": [\n                "null",\n                "long"\n              ],\n              "name": "rowCount",\n              "default": null,\n              "doc": "Number of rows for evaluated batch"\n            },\n            {\n              "type": [\n                "null",\n                "long"\n              ],\n              "name": "missingCount",\n              "default": null,\n              "doc": "Number of rows with missing value for evaluated batch"\n            },\n            {\n              "type": [\n                "null",\n                "long"\n              ],\n              "name": "unexpectedCount",\n              "default": null,\n              "doc": "Number of rows with unexpected value for evaluated batch"\n            },\n            {\n              "type": [\n                "null",\n                "float"\n              ],\n              "name": "actualAggValue",\n              "default": null,\n              "doc": "Observed aggregate value for evaluated batch"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "map",\n                  "values": "string"\n                }\n              ],\n              "name": "nativeResults",\n              "default": null,\n              "doc": "Other results of evaluation"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "externalUrl",\n              "default": null,\n              "doc": "External URL where full results are available. Only present when assertion source is not native."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "AssertionResultError",\n                  "namespace": "com.linkedin.assertion",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "enum",\n                        "symbolDocs": {\n                          "CUSTOM_SQL_ERROR": " Error while executing a custom SQL assertion",\n                          "FIELD_ASSERTION_ERROR": " Error while executing a field assertion",\n                          "INSUFFICIENT_DATA": " Insufficient data to evaluate the assertion",\n                          "INVALID_PARAMETERS": " Invalid parameters were detected",\n                          "INVALID_SOURCE_TYPE": " Event type not supported by the specified source",\n                          "SOURCE_CONNECTION_ERROR": " Source is unreachable",\n                          "SOURCE_QUERY_FAILED": " Source query failed to execute",\n                          "UNKNOWN_ERROR": " Unknown error",\n                          "UNSUPPORTED_PLATFORM": " Unsupported platform"\n                        },\n                        "name": "AssertionResultErrorType",\n                        "namespace": "com.linkedin.assertion",\n                        "symbols": [\n                          "SOURCE_CONNECTION_ERROR",\n                          "SOURCE_QUERY_FAILED",\n                          "INSUFFICIENT_DATA",\n                          "INVALID_PARAMETERS",\n                          "INVALID_SOURCE_TYPE",\n                          "UNSUPPORTED_PLATFORM",\n                          "CUSTOM_SQL_ERROR",\n                          "FIELD_ASSERTION_ERROR",\n                          "UNKNOWN_ERROR"\n                        ]\n                      },\n                      "name": "type",\n                      "doc": " The type of error encountered"\n                    },\n                    {\n                      "type": [\n                        "null",\n                        {\n                          "type": "map",\n                          "values": "string"\n                        }\n                      ],\n                      "name": "properties",\n                      "default": null,\n                      "doc": " Additional metadata depending on the type of error"\n                    }\n                  ],\n                  "doc": " An error encountered when evaluating an AssertionResult"\n                }\n              ],\n              "name": "error",\n              "default": null,\n              "doc": " The error object if AssertionResultType is an Error"\n            }\n          ],\n          "doc": "The result of running an assertion"\n        }\n      ],\n      "name": "result",\n      "default": null,\n      "doc": "Results of assertion, present if the status is COMPLETE"\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "map",\n          "values": "string"\n        }\n      ],\n      "name": "runtimeContext",\n      "default": null,\n      "doc": "Runtime parameters of evaluation"\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "BatchSpec",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Searchable": {\n                "/*": {\n                  "fieldType": "TEXT",\n                  "queryByDefault": true\n                }\n              },\n              "type": {\n                "type": "map",\n                "values": "string"\n              },\n              "name": "customProperties",\n              "default": {},\n              "doc": "Custom property bag."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "nativeBatchId",\n              "default": null,\n              "doc": "The native identifier as specified by the system operating on the batch."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "query",\n              "default": null,\n              "doc": "A query that identifies a batch of data"\n            },\n            {\n              "type": [\n                "null",\n                "int"\n              ],\n              "name": "limit",\n              "default": null,\n              "doc": "Any limit to the number of rows in the batch, if applied"\n            }\n          ],\n          "doc": "A batch on which certain operations, e.g. data quality evaluation, is done."\n        }\n      ],\n      "name": "batchSpec",\n      "default": null,\n      "doc": "Specification of the batch which this run is evaluating"\n    },\n    {\n      "TimeseriesField": {},\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "assertionUrn"\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "TimeWindowSize",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "CalendarInterval",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "SECOND",\n                  "MINUTE",\n                  "HOUR",\n                  "DAY",\n                  "WEEK",\n                  "MONTH",\n                  "QUARTER",\n                  "YEAR"\n                ]\n              },\n              "name": "unit",\n              "doc": "Interval unit such as minute/hour/day etc."\n            },\n            {\n              "type": "int",\n              "name": "multiple",\n              "default": 1,\n              "doc": "How many units. Defaults to 1."\n            }\n          ],\n          "doc": "Defines the size of a time window."\n        }\n      ],\n      "name": "eventGranularity",\n      "default": null,\n      "doc": "Granularity of the event if applicable"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "PartitionSpec",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "TimeseriesField": {},\n              "type": "string",\n              "name": "partition",\n              "doc": "A unique id / value for the partition for which statistics were collected,\\ngenerated by applying the key definition to a given row."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "TimeWindow",\n                  "namespace": "com.linkedin.timeseries",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "startTimeMillis",\n                      "doc": "Start time as epoch at UTC."\n                    },\n                    {\n                      "type": "com.linkedin.timeseries.TimeWindowSize",\n                      "name": "length",\n                      "doc": "The length of the window."\n                    }\n                  ]\n                }\n              ],\n              "name": "timePartition",\n              "default": null,\n              "doc": "Time window of the partition, if we are able to extract it from the partition key."\n            },\n            {\n              "deprecated": true,\n              "type": {\n                "type": "enum",\n                "name": "PartitionType",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "FULL_TABLE",\n                  "QUERY",\n                  "PARTITION"\n                ]\n              },\n              "name": "type",\n              "default": "PARTITION",\n              "doc": "Unused!"\n            }\n          ],\n          "doc": "A reference to a specific partition in a dataset."\n        },\n        "null"\n      ],\n      "name": "partitionSpec",\n      "default": {\n        "partition": "FULL_TABLE_SNAPSHOT",\n        "type": "FULL_TABLE",\n        "timePartition": null\n      },\n      "doc": "The optional partition specification."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "messageId",\n      "default": null,\n      "doc": "The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."\n    }\n  ],\n  "doc": "An event representing the current status of evaluating an assertion on a batch.\\nAssertionRunEvent should be used for reporting the status of a run as an assertion evaluation progresses."\n}\n')))),(0,a.yg)("h3",{id:"common-types"},"Common Types"),(0,a.yg)("p",null,"These types are used across multiple aspects in this entity."),(0,a.yg)("h4",{id:"assertionaction"},"AssertionAction"),(0,a.yg)("p",null,"The Actions about an Assertion.\nIn the future, we'll likely extend this model to support additional\nparameters or options related to the assertion actions."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Fields:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"type")," (AssertionActionType): The type of the Action")),(0,a.yg)("h4",{id:"auditstamp"},"AuditStamp"),(0,a.yg)("p",null,"Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Fields:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"time")," (long): When did the resource/association/sub-resource move into the specific lifecyc..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"actor")," (string): The entity (e.g. a member URN) which will be credited for moving the resource..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"impersonator")," (string?): The entity (e.g. a service URN) which performs the change on behalf of the Ac..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"message")," (string?): Additional context around how DataHub was informed of the particular change. ...")),(0,a.yg)("h3",{id:"relationships"},"Relationships"),(0,a.yg)("h4",{id:"outgoing"},"Outgoing"),(0,a.yg)("p",null,"These are the relationships stored in this entity's aspects"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Asserts"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.datasetAssertion.dataset")),(0,a.yg)("li",{parentName:"ul"},"SchemaField via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.datasetAssertion.fields")),(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.freshnessAssertion.entity")),(0,a.yg)("li",{parentName:"ul"},"DataJob via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.freshnessAssertion.entity")),(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.volumeAssertion.entity")),(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.sqlAssertion.entity")),(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.fieldAssertion.entity")),(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.schemaAssertion.entity")),(0,a.yg)("li",{parentName:"ul"},"DataJob via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.schemaAssertion.entity")),(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.customAssertion.entity")),(0,a.yg)("li",{parentName:"ul"},"SchemaField via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.customAssertion.field")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"SchemaFieldTaggedWith"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Tag via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.schemaAssertion.schema.fields.globalTags")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"TaggedWith"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Tag via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.schemaAssertion.schema.fields.globalTags.tags")),(0,a.yg)("li",{parentName:"ul"},"Tag via ",(0,a.yg)("inlineCode",{parentName:"li"},"globalTags.tags")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"SchemaFieldWithGlossaryTerm"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"GlossaryTerm via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.schemaAssertion.schema.fields.glossaryTerms")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"TermedWith"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"GlossaryTerm via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.schemaAssertion.schema.fields.glossaryTerms.terms.urn")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"ForeignKeyTo"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"SchemaField via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.schemaAssertion.schema.foreignKeys.foreignFields")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"ForeignKeyToDataset"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"assertionInfo.schemaAssertion.schema.foreignKeys.foreignDataset"))))),(0,a.yg)("h3",{id:"global-metadata-model"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png"},"Global Metadata Model")),(0,a.yg)("p",null,(0,a.yg)("img",{parentName:"p",src:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png",alt:"Global Graph"})))}g.isMDXComponent=!0}}]);