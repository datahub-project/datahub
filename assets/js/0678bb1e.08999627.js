"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[30150],{15680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>h});var a=n(96540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),g=r,h=d["".concat(l,".").concat(g)]||d[g]||p[g]||i;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},19769:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});n(96540);var a=n(15680);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}const s={title:"Restoring Search and Graph Indices from Local Database",slug:"/how/restore-indices",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/how/restore-indices.md"},l="Restoring Search and Graph Indices from Local Database",c={unversionedId:"docs/how/restore-indices",id:"version-1.1.0/docs/how/restore-indices",title:"Restoring Search and Graph Indices from Local Database",description:"If search infrastructure (Elasticsearch/Opensearch) or graph services (Elasticsearch/Opensearch/Neo4j) become inconsistent,",source:"@site/versioned_docs/version-1.1.0/docs/how/restore-indices.md",sourceDirName:"docs/how",slug:"/how/restore-indices",permalink:"/docs/1.1.0/how/restore-indices",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/how/restore-indices.md",tags:[],version:"1.1.0",frontMatter:{title:"Restoring Search and Graph Indices from Local Database",slug:"/how/restore-indices",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/how/restore-indices.md"},sidebar:"overviewSidebar",previous:{title:"Taking backup of DataHub",permalink:"/docs/1.1.0/how/backup-datahub"},next:{title:"Configuring Database Retention",permalink:"/docs/1.1.0/advanced/db-retention"}},u={},d=[{value:"Configuration",id:"configuration",level:2},{value:"Time-Based Filtering",id:"time-based-filtering",level:3},{value:"Pagination and Performance Options",id:"pagination-and-performance-options",level:3},{value:"Content Filtering",id:"content-filtering",level:3},{value:"Default Aspects",id:"default-aspects",level:3},{value:"Nuclear option",id:"nuclear-option",level:3},{value:"Helm",id:"helm",level:3},{value:"Execution Methods",id:"execution-methods",level:2},{value:"Quickstart",id:"quickstart",level:3},{value:"Docker-compose",id:"docker-compose",level:3},{value:"Kubernetes",id:"kubernetes",level:3},{value:"Through APIs",id:"through-apis",level:3},{value:"OpenAPI",id:"openapi",level:4},{value:"Rest.li",id:"restli",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"K8 Job vs. API",id:"k8-job-vs-api",level:3},{value:"When to Use Kubernetes Jobs",id:"when-to-use-kubernetes-jobs",level:4},{value:"When to Use APIs",id:"when-to-use-apis",level:4},{value:"Targeted Restoration Strategies",id:"targeted-restoration-strategies",level:3},{value:"Entity Type Filtering",id:"entity-type-filtering",level:4},{value:"Single Entity",id:"single-entity",level:4},{value:"Time-Based",id:"time-based",level:4},{value:"Parallel Processing Strategies",id:"parallel-processing-strategies",level:3},{value:"Multiple Parallel Jobs",id:"multiple-parallel-jobs",level:4},{value:"Temporary Workload Reduction",id:"temporary-workload-reduction",level:3},{value:"Infrastructure Tuning",id:"infrastructure-tuning",level:3},{value:"Elasticsearch/Opensearch Optimization",id:"elasticsearchopensearch-optimization",level:4},{value:"Refresh Interval Adjustment:",id:"refresh-interval-adjustment",level:5},{value:"Bulk Processing Improvements:",id:"bulk-processing-improvements",level:5},{value:"Shard Management:",id:"shard-management",level:5},{value:"SQL/Primary Storage",id:"sqlprimary-storage",level:4},{value:"Kafka &amp; Consumers",id:"kafka--consumers",level:4},{value:"Partition Strategy:",id:"partition-strategy",level:5},{value:"Consumer Scaling:",id:"consumer-scaling",level:5},{value:"Monitoring:",id:"monitoring",level:5}],p={toc:d},g="wrapper";function h(e){var{components:t}=e,n=o(e,["components"]);return(0,a.yg)(g,i(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){r(e,t,n[t])}))}return e}({},p,n),{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"restoring-search-and-graph-indices-from-local-database"},"Restoring Search and Graph Indices from Local Database"),(0,a.yg)("p",null,"If search infrastructure (Elasticsearch/Opensearch) or graph services (Elasticsearch/Opensearch/Neo4j) become inconsistent,\nyou can restore them from the aspects stored in the local database."),(0,a.yg)("p",null,"When a new version of the aspect gets ingested, GMS initiates an MCL event for the aspect which is consumed to update\nthe search and graph indices. As such, we can fetch the latest version of each aspect in the local database and produce\nMCL events corresponding to the aspects to restore the search and graph indices."),(0,a.yg)("p",null,"By default, restoring the indices from the local database will not remove any existing documents in\nthe search and graph indices that no longer exist in the local database, potentially leading to inconsistencies\nbetween the search and graph indices and the local database."),(0,a.yg)("h2",{id:"configuration"},"Configuration"),(0,a.yg)("p",null,"The upgrade jobs take arguments as command line args to the job itself rather than environment variables for job specific\nconfiguration. The RestoreIndices job is specified through the ",(0,a.yg)("inlineCode",{parentName:"p"},"-u RestoreIndices")," upgrade ID parameter and then additional\nparameters are specified like ",(0,a.yg)("inlineCode",{parentName:"p"},"-a batchSize=1000"),"."),(0,a.yg)("p",null,"The following configurations are available:"),(0,a.yg)("h3",{id:"time-based-filtering"},"Time-Based Filtering"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"lePitEpochMs"),": Restore records created before this timestamp (in milliseconds)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"gePitEpochMs"),": Restore records created after this timestamp (in milliseconds)")),(0,a.yg)("h3",{id:"pagination-and-performance-options"},"Pagination and Performance Options"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"urnBasedPagination"),": Enable key-based pagination instead of offset-based pagination. Recommended for large datasets as it's typically more efficient."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"startingOffset"),": When using default pagination, start from this offset"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"lastUrn"),": Resume from a specific URN when using URN-based pagination"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"lastAspect"),": Used with lastUrn to resume from a specific aspect, preventing reprocessing"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"numThreads"),": Number of concurrent threads for processing restoration, only used with default offset based paging"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"batchSize"),": Configures the size of each batch as the job pages through rows"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"batchDelayMs"),": Adds a delay in between each batch to avoid overloading backend systems")),(0,a.yg)("h3",{id:"content-filtering"},"Content Filtering"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"aspectNames"),': Comma-separated list of aspects to restore (e.g., "ownership,status")'),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"urnLike"),': SQL LIKE pattern to filter URNs (e.g., "urn:li:dataset%")')),(0,a.yg)("h3",{id:"default-aspects"},"Default Aspects"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"createDefaultAspects"),": Create default aspects in both SQL and ES if missing.")),(0,a.yg)("p",null,"During the restore indices process, it will create default aspects in SQL. While this may be\ndesired in some situations, disabling this feature is required when using a read-only SQL replica."),(0,a.yg)("h3",{id:"nuclear-option"},"Nuclear option"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"clean"),": This option wipes out the current indices by running deletes of all the documents to guarantee a consistent state with SQL. This is generally not recommended unless there is significant data corruption on the instance.")),(0,a.yg)("h3",{id:"helm"},"Helm"),(0,a.yg)("p",null,"These are available in the helm charts as configurations for Kubernetes deployments under the ",(0,a.yg)("inlineCode",{parentName:"p"},"datahubUpgrade.restoreIndices.args")," path which will set them up as args to the pod command."),(0,a.yg)("h2",{id:"execution-methods"},"Execution Methods"),(0,a.yg)("h3",{id:"quickstart"},"Quickstart"),(0,a.yg)("p",null,"If you're using the quickstart images, you can use the ",(0,a.yg)("inlineCode",{parentName:"p"},"datahub")," cli to restore the indices."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-shell"},"datahub docker quickstart --restore-indices\n")),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"Using the ",(0,a.yg)("inlineCode",{parentName:"p"},"datahub")," CLI to restore the indices when using the quickstart images will also clear the search and graph indices before restoring.")),(0,a.yg)("p",null,"See ",(0,a.yg)("a",{parentName:"p",href:"/docs/1.1.0/quickstart#restore-datahub"},"this section")," for more information."),(0,a.yg)("h3",{id:"docker-compose"},"Docker-compose"),(0,a.yg)("p",null,"If you are on a custom docker-compose deployment, run the following command (you need to checkout ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/datahub-project/datahub"},"the source repository"),") from the root of the repo to send MAE for each aspect in the local database."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-shell"},"./docker/datahub-upgrade/datahub-upgrade.sh -u RestoreIndices\n")),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"By default this command will not clear the search and graph indices before restoring, thous potentially leading to inconsistencies between the local database and the indices, in case aspects were previously deleted in the local database but were not removed from the correponding index.")),(0,a.yg)("p",null,"If you need to clear the search and graph indices before restoring, add ",(0,a.yg)("inlineCode",{parentName:"p"},"-a clean")," to the end of the command. Please take note that the search and graph services might not be fully functional during reindexing when the indices are cleared."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-shell"},"./docker/datahub-upgrade/datahub-upgrade.sh -u RestoreIndices -a clean\n")),(0,a.yg)("p",null,"Refer to this ",(0,a.yg)("a",{parentName:"p",href:"/docs/1.1.0/docker/datahub-upgrade#environment-variables"},"doc")," on how to set environment variables\nfor your environment."),(0,a.yg)("h3",{id:"kubernetes"},"Kubernetes"),(0,a.yg)("p",null,"Run ",(0,a.yg)("inlineCode",{parentName:"p"},"kubectl get cronjobs")," to see if the restoration job template has been deployed. If you see results like below, you\nare good to go."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"NAME                                          SCHEDULE    SUSPEND   ACTIVE   LAST SCHEDULE   AGE\ndatahub-datahub-cleanup-job-template          * * * * *   True      0        <none>          2d3h\ndatahub-datahub-restore-indices-job-template  * * * * *   True      0        <none>          2d3h\n")),(0,a.yg)("p",null,"If not, deploy latest helm charts to use this functionality."),(0,a.yg)("p",null,"Once restore indices job template has been deployed, run the following command to start a job that restores indices."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-shell"},"kubectl create job --from=cronjob/datahub-datahub-restore-indices-job-template datahub-restore-indices-adhoc\n")),(0,a.yg)("p",null,"Once the job completes, your indices will have been restored."),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"By default the restore indices job template will not clear the search and graph indices before restoring, thous potentially leading to inconsistencies between the local database and the indices, in case aspects were previously deleted in the local database but were not removed from the correponding index.")),(0,a.yg)("p",null,"If you need to clear the search and graph indices before restoring, modify the ",(0,a.yg)("inlineCode",{parentName:"p"},"values.yaml")," for your deployment and overwrite the default arguments of the restore indices job template to include the ",(0,a.yg)("inlineCode",{parentName:"p"},"-a clean")," argument. Please take note that the search and graph services might not be fully functional during reindexing when the indices are cleared."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-yaml"},'datahubUpgrade:\n  restoreIndices:\n    image:\n      args:\n        - "-u"\n        - "RestoreIndices"\n        - "-a"\n        - "batchSize=1000" # default value of datahubUpgrade.batchSize\n        - "-a"\n        - "batchDelayMs=100" # default value of datahubUpgrade.batchDelayMs\n        - "-a"\n        - "clean"\n')),(0,a.yg)("h3",{id:"through-apis"},"Through APIs"),(0,a.yg)("p",null,"See also the ",(0,a.yg)("a",{parentName:"p",href:"#best-practices"},"Best Practices")," section below, however note that the APIs are able to handle a few thousand\naspects. In this mode one of the GMS instances will perform the required actions, however it is subject to timeout. Use one of the\napproaches above for longer running restoreIndices."),(0,a.yg)("h4",{id:"openapi"},"OpenAPI"),(0,a.yg)("p",null,"There are two primary APIs, one which exposes the common parameters for restoreIndices and another one designed\nto accept a list of URNs where all aspects are to be restored."),(0,a.yg)("p",null,"Full configuration:"),(0,a.yg)("p",{align:"center"},(0,a.yg)("img",{width:"80%",src:"https://github.com/datahub-project/static-assets/blob/main/imgs/how/restore-indices/openapi-restore-indices.png?raw=true"})),(0,a.yg)("p",null,"All Aspects:"),(0,a.yg)("p",{align:"center"},(0,a.yg)("img",{width:"80%",src:"https://github.com/datahub-project/static-assets/blob/main/imgs/how/restore-indices/openapi-restore-indices-urns.png?raw=true"})),(0,a.yg)("h4",{id:"restli"},"Rest.li"),(0,a.yg)("p",null,"For Rest.li, see ",(0,a.yg)("a",{parentName:"p",href:"/docs/1.1.0/api/restli/restore-indices"},"Restore Indices API"),"."),(0,a.yg)("h2",{id:"best-practices"},"Best Practices"),(0,a.yg)("p",null,"In general, this process is not required to run unless there has been a disruption of storage services or infrastructure,\nsuch as Elasticsearch/Opensearch cluster failures, data corruption events, or significant version upgrade inconsistencies\nthat have caused the search and graph indices to become out of sync with the local database."),(0,a.yg)("h3",{id:"k8-job-vs-api"},"K8 Job vs. API"),(0,a.yg)("h4",{id:"when-to-use-kubernetes-jobs"},"When to Use Kubernetes Jobs"),(0,a.yg)("p",null,"For operations affecting 2,000 or more aspects, it's strongly recommended to use the Kubernetes job approach. This job is\ndesigned for long-running processes and provide several advantages:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Won't time out like API calls"),(0,a.yg)("li",{parentName:"ul"},"Can be monitored through Kubernetes logging"),(0,a.yg)("li",{parentName:"ul"},"Won't consume resources from your primary GMS instances"),(0,a.yg)("li",{parentName:"ul"},"Can be scheduled during off-peak hours to minimize system impact")),(0,a.yg)("h4",{id:"when-to-use-apis"},"When to Use APIs"),(0,a.yg)("p",null,"The RestoreIndices APIs (available through both Rest.li and OpenAPI) is best suited for:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Targeted restores affecting fewer than 2,000 aspects"),(0,a.yg)("li",{parentName:"ul"},"Emergencies where you need to quickly restore critical metadata"),(0,a.yg)("li",{parentName:"ul"},"Testing or validating the restore process before running a full-scale job"),(0,a.yg)("li",{parentName:"ul"},"Scenarios where you don't have direct access to the Kubernetes cluster")),(0,a.yg)("p",null,"Remember that API-based restoration runs within one of your GMS instances and is subject to timeouts, which could lead to\nincomplete restorations for larger installations."),(0,a.yg)("h3",{id:"targeted-restoration-strategies"},"Targeted Restoration Strategies"),(0,a.yg)("p",null,"Being selective about what you restore is crucial for efficiency. Combining these filtering strategies can dramatically\nreduce the restoration scope, saving resources and time."),(0,a.yg)("h4",{id:"entity-type-filtering"},"Entity Type Filtering"),(0,a.yg)("p",null,"Entity Type Filtering: Use the ",(0,a.yg)("inlineCode",{parentName:"p"},"urnLike")," parameter to target specific entity types:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"For datasets: ",(0,a.yg)("inlineCode",{parentName:"li"},"urnLike=urn:li:dataset:%")),(0,a.yg)("li",{parentName:"ul"},"For users: ",(0,a.yg)("inlineCode",{parentName:"li"},"urnLike=urn:li:corpuser:%")),(0,a.yg)("li",{parentName:"ul"},"For dashboards: ",(0,a.yg)("inlineCode",{parentName:"li"},"urnLike=urn:li:dashboard:%"))),(0,a.yg)("h4",{id:"single-entity"},"Single Entity"),(0,a.yg)("p",null,"Single Entity Restoration: When only one entity is affected, provide the specific URN to minimize processing overhead.\nAspect-Based Filtering: Use aspectNames to target only the specific aspects that need restoration:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"For ownership inconsistencies: ",(0,a.yg)("inlineCode",{parentName:"li"},"aspectNames=ownership")),(0,a.yg)("li",{parentName:"ul"},"For tag issues: ",(0,a.yg)("inlineCode",{parentName:"li"},"aspectNames=globalTags"))),(0,a.yg)("h4",{id:"time-based"},"Time-Based"),(0,a.yg)("p",null,"Time-Based Recovery: If you know when the inconsistency began, use time-based filtering:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"gePitEpochMs={timestamp} to process only records created after the incident"),(0,a.yg)("li",{parentName:"ul"},"lePitEpochMs={timestamp} to limit processing to records before a certain time")),(0,a.yg)("h3",{id:"parallel-processing-strategies"},"Parallel Processing Strategies"),(0,a.yg)("p",null,"To optimize restoration speed while managing system load:"),(0,a.yg)("h4",{id:"multiple-parallel-jobs"},"Multiple Parallel Jobs"),(0,a.yg)("p",null,"Run several restoreIndices processes simultaneously by:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Work on non-overlapping sets of aspects or entities",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Dividing work by entity type (one job for datasets, another for users, etc.)"),(0,a.yg)("li",{parentName:"ul"},"Splitting aspects among different jobs (one for ownership aspects, another for lineage, etc.)"),(0,a.yg)("li",{parentName:"ul"},"Partitioning large entity types by prefix or time range"))),(0,a.yg)("li",{parentName:"ul"},"Have staggered start times to prevent initial resource contention"),(0,a.yg)("li",{parentName:"ul"},"Monitor system metrics closely during concurrent restoration to ensure you're not overloading your infrastructure.")),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},"Avoid Conflicts: Ensure that concurrent jobs:"),(0,a.yg)("p",{parentName:"admonition"},"Never specify the --clean argument in concurrent jobs")),(0,a.yg)("h3",{id:"temporary-workload-reduction"},"Temporary Workload Reduction"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Pause scheduled ingestion jobs during restoration"),(0,a.yg)("li",{parentName:"ul"},"Temporarily disable or reduce frequency of the datahub-gc job to prevent conflicting deletes"),(0,a.yg)("li",{parentName:"ul"},"Consider pausing automated workflows or integrations that generate metadata events")),(0,a.yg)("h3",{id:"infrastructure-tuning"},"Infrastructure Tuning"),(0,a.yg)("p",null,"Implementing these expanded best practices should help ensure a smoother, more efficient restoration process while\nminimizing impact on your DataHub environment."),(0,a.yg)("p",null,"This operation can be I/O intensive from the read-side from SQL and on the Elasticsearch write side. If you're able to leverage\nprovisioned I/O. or throughput, you might want to monitor your infrastructure for a possible."),(0,a.yg)("h4",{id:"elasticsearchopensearch-optimization"},"Elasticsearch/Opensearch Optimization"),(0,a.yg)("p",null,"To improve write performance during restoration:"),(0,a.yg)("h5",{id:"refresh-interval-adjustment"},"Refresh Interval Adjustment:"),(0,a.yg)("p",null,"Temporarily increase the refresh_interval setting from the default (typically 1s) to something like 30s or 60s.\nRun the system update job with the following environment variable ",(0,a.yg)("inlineCode",{parentName:"p"},"ELASTICSEARCH_INDEX_BUILDER_REFRESH_INTERVAL_SECONDS=60")),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},"Remember to reset this after restoration completes!")),(0,a.yg)("h5",{id:"bulk-processing-improvements"},"Bulk Processing Improvements:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Adjust the Elasticsearch batching parameters to optimize bulk request size (try values between 2000-5000)",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Run your GMS or ",(0,a.yg)("inlineCode",{parentName:"li"},"mae-consumer")," with environment variables",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"ES_BULK_REQUESTS_LIMIT=3000")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"ES_BULK_FLUSH_PERIOD=60")))))),(0,a.yg)("li",{parentName:"ul"},"Configure ",(0,a.yg)("inlineCode",{parentName:"li"},"batchDelayMs")," on restoreIndices to add breathing room between batches if your cluster is struggling")),(0,a.yg)("h5",{id:"shard-management"},"Shard Management:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Ensure your indices have an appropriate number of shards for your cluster size."),(0,a.yg)("li",{parentName:"ul"},"Consider temporarily adding nodes to your search cluster during massive restorations.")),(0,a.yg)("h4",{id:"sqlprimary-storage"},"SQL/Primary Storage"),(0,a.yg)("p",null,"Consider using a read replica as the source of the job's data. If you configure a read-only replica\nyou must also provide the parameter ",(0,a.yg)("inlineCode",{parentName:"p"},"createDefaultAspects=false"),"."),(0,a.yg)("h4",{id:"kafka--consumers"},"Kafka & Consumers"),(0,a.yg)("h5",{id:"partition-strategy"},"Partition Strategy:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Verify that the Kafka Metadata Change Log (MCL) topic have enough partitions to allow for parallel processing."),(0,a.yg)("li",{parentName:"ul"},"Recommended: At least 10-20 partitions for the MCL topic in production environments.")),(0,a.yg)("h5",{id:"consumer-scaling"},"Consumer Scaling:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Temporarily increase the number of ",(0,a.yg)("inlineCode",{parentName:"li"},"mae-consumer")," pods to process the higher event volume."),(0,a.yg)("li",{parentName:"ul"},"Scale GMS instances if they're handling consumer duties.")),(0,a.yg)("h5",{id:"monitoring"},"Monitoring:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Watch consumer lag metrics closely during restoration."),(0,a.yg)("li",{parentName:"ul"},"Be prepared to adjust scaling or batch parameters if consumers fall behind.")))}h.isMDXComponent=!0}}]);