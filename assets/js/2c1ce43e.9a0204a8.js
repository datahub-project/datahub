"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[1961],{15680:(e,t,n)=>{n.d(t,{xA:()=>l,yg:()=>p});var r=n(96540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),c=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(u.Provider,{value:t},e.children)},g="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),g=c(n),d=a,p=g["".concat(u,".").concat(d)]||g[d]||m[d]||i;return n?r.createElement(p,s(s({ref:t},l),{},{components:n})):r.createElement(p,s({ref:t},l))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o[g]="string"==typeof e?e:a,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},53372:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>u,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>g});n(96540);var r=n(15680);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const o={title:"Micrometer Best Practices Guide",slug:"/advanced/micrometer-best-practices",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/advanced/micrometer-best-practices.md"},u="Micrometer Best Practices Guide",c={unversionedId:"docs/advanced/micrometer-best-practices",id:"docs/advanced/micrometer-best-practices",title:"Micrometer Best Practices Guide",description:"This guide provides practical recommendations for using the Micrometer library with Prometheus in production environments, addressing common pitfalls and unclear documentation areas.",source:"@site/genDocs/docs/advanced/micrometer-best-practices.md",sourceDirName:"docs/advanced",slug:"/advanced/micrometer-best-practices",permalink:"/docs/advanced/micrometer-best-practices",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/advanced/micrometer-best-practices.md",tags:[],version:"current",frontMatter:{title:"Micrometer Best Practices Guide",slug:"/advanced/micrometer-best-practices",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/advanced/micrometer-best-practices.md"}},l={},g=[{value:"Metric Types and When to Use Them",id:"metric-types-and-when-to-use-them",level:2},{value:"Counters",id:"counters",level:3},{value:"Gauges",id:"gauges",level:3},{value:"Timers",id:"timers",level:3},{value:"Tags/Labels: The Complete Guide",id:"tagslabels-the-complete-guide",level:2},{value:"Static Tags (Recommended)",id:"static-tags-recommended",level:3},{value:"Dynamic Tags (Use with Extreme Caution)",id:"dynamic-tags-use-with-extreme-caution",level:3},{value:"Tag Value Guidelines",id:"tag-value-guidelines",level:3},{value:"Naming Conventions",id:"naming-conventions",level:2},{value:"Metric Names",id:"metric-names",level:3},{value:"Tag Names",id:"tag-names",level:3},{value:"Common Anti-Patterns and Solutions",id:"common-anti-patterns-and-solutions",level:2},{value:"1. Creating Metrics in Hot Paths",id:"1-creating-metrics-in-hot-paths",level:3},{value:"2. High Cardinality Tags",id:"2-high-cardinality-tags",level:3},{value:"3. Not Using Description",id:"3-not-using-description",level:3},{value:"Memory and Performance Considerations",id:"memory-and-performance-considerations",level:2},{value:"Registry Management",id:"registry-management",level:3}],m={toc:g},d="wrapper";function p(e){var{components:t}=e,n=s(e,["components"]);return(0,r.yg)(d,i(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},r=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),r.forEach((function(t){a(e,t,n[t])}))}return e}({},m,n),{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"micrometer-best-practices-guide"},"Micrometer Best Practices Guide"),(0,r.yg)("p",null,"This guide provides practical recommendations for using the Micrometer library with Prometheus in production environments, addressing common pitfalls and unclear documentation areas."),(0,r.yg)("h2",{id:"metric-types-and-when-to-use-them"},"Metric Types and When to Use Them"),(0,r.yg)("h3",{id:"counters"},"Counters"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Use for:")," Values that only increase (requests processed, errors occurred, bytes sent)"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u2705 Good - Initialize once, reuse everywhere\nprivate final Counter requestCounter = Counter.builder("http_requests_total")\n    .description("Total HTTP requests")\n    .register(meterRegistry);\n\n// Usage\nrequestCounter.increment();\nrequestCounter.increment(5.0);\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Anti-patterns:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Don't use for values that can decrease"),(0,r.yg)("li",{parentName:"ul"},"Don't create new counters for each operation")),(0,r.yg)("h3",{id:"gauges"},"Gauges"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Use for:")," Current state values (active connections, queue size, temperature)"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u2705 Good - Gauge tied to an object\'s state\nprivate final AtomicInteger activeConnections = new AtomicInteger(0);\n\nGauge.builder("active_connections")\n    .description("Number of active database connections")\n    .register(meterRegistry, activeConnections, AtomicInteger::get);\n\n// \u2705 Good - Using a supplier function\nGauge.builder("jvm_memory_used")\n    .register(meterRegistry, this, obj -> Runtime.getRuntime().totalMemory());\n')),(0,r.yg)("h3",{id:"timers"},"Timers"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Use for:")," Measuring duration and frequency of events"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u2705 Good - Initialize once\nprivate final Timer requestTimer = Timer.builder("http_request_duration")\n    .description("HTTP request duration")\n    .register(meterRegistry);\n\n// Usage patterns\nTimer.Sample sample = Timer.start(meterRegistry);\n// ... do work ...\nsample.stop(requestTimer);\n\n// Or using recordCallable\nrequestTimer.recordCallable(() -> {\n    // ... timed operation ...\n    return result;\n});\n')),(0,r.yg)("h2",{id:"tagslabels-the-complete-guide"},"Tags/Labels: The Complete Guide"),(0,r.yg)("h3",{id:"static-tags-recommended"},"Static Tags (Recommended)"),(0,r.yg)("p",null,"Initialize metrics with known, finite tag sets at application startup:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u2705 Excellent - Finite, predictable tag values\nprivate final Counter httpRequestsCounter = Counter.builder("http_requests_total")\n    .description("Total HTTP requests")\n    .tag("method", "GET")\n    .tag("endpoint", "/api/users")\n    .register(meterRegistry);\n\n// \u2705 Good - Create a map for multiple static tag combinations\nprivate final Map<String, Counter> methodCounters = Map.of(\n    "GET", createCounter("GET"),\n    "POST", createCounter("POST"),\n    "PUT", createCounter("PUT")\n);\n')),(0,r.yg)("h3",{id:"dynamic-tags-use-with-extreme-caution"},"Dynamic Tags (Use with Extreme Caution)"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"The Cardinal Sin: Unbounded Dynamic Tags")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u274c NEVER DO THIS - Creates unlimited metrics\nCounter.builder("user_requests")\n    .tag("user_id", userId) // If userId is unbounded, this will cause memory leaks\n    .register(meterRegistry)\n    .increment();\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Why this is problematic:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Each unique tag combination creates a new time series in Prometheus"),(0,r.yg)("li",{parentName:"ul"},"Prometheus performance degrades with high cardinality")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Safe Dynamic Tag Patterns:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u2705 Acceptable - Bounded dynamic tags with known finite values\nprivate final Map<String, Counter> statusCounters = new ConcurrentHashMap<>();\n\npublic void recordHttpResponse(String method, int statusCode) {\n    // Limit to standard HTTP methods and status code ranges\n    String normalizedMethod = normalizeHttpMethod(method);\n    String statusClass = statusCode / 100 + "xx"; // 2xx, 4xx, 5xx\n\n    String key = normalizedMethod + "_" + statusClass;\n    statusCounters.computeIfAbsent(key, k ->\n        Counter.builder("http_responses_total")\n            .tag("method", normalizedMethod)\n            .tag("status_class", statusClass)\n            .register(meterRegistry)\n    ).increment();\n}\n\nprivate String normalizeHttpMethod(String method) {\n    return Set.of("GET", "POST", "PUT", "DELETE", "PATCH")\n        .contains(method.toUpperCase()) ? method.toUpperCase() : "OTHER";\n}\n')),(0,r.yg)("h3",{id:"tag-value-guidelines"},"Tag Value Guidelines"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Keep values short and normalized"),": Long, detailed tag values often indicate high cardinality - normalize them into categories"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Limit cardinality"),": Aim for < 1000 unique combinations per metric"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Use enums when possible"),": Ensures finite, known values")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u2705 Good - Using enums for guaranteed finite values\npublic enum DatabaseOperation {\n    SELECT, INSERT, UPDATE, DELETE\n}\n\nCounter.builder("database_operations_total")\n    .tag("operation", operation.name().toLowerCase())\n    .register(meterRegistry);\n')),(0,r.yg)("h2",{id:"naming-conventions"},"Naming Conventions"),(0,r.yg)("h3",{id:"metric-names"},"Metric Names"),(0,r.yg)("p",null,"Follow Prometheus naming conventions:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u2705 Good metric names\n"http_requests_total"           // Counter: use _total suffix\n"http_request_duration_seconds" // Timer/Histogram: include unit\n"database_connections_active"   // Gauge: describe current state\n"jvm_memory_used_bytes"        // Include units in name\n"cache_hits_total"\n"queue_size_current"\n\n// \u274c Poor metric names\n"httpRequests"                 // Use snake_case, not camelCase\n"requests"                     // Too generic\n"duration"                     // No unit specified\n"count"                        // Not descriptive\n')),(0,r.yg)("h3",{id:"tag-names"},"Tag Names"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u2705 Good tag names\n.tag("method", "GET")          // Clear, standard HTTP concept\n.tag("status_code", "200")     // Standard terminology\n.tag("endpoint", "/api/users") // Clear path identifier\n.tag("service", "user-api")    // Service identification\n\n// \u274c Poor tag names\n.tag("m", "GET")              // Too abbreviated\n.tag("httpMethod", "GET")     // Avoid camelCase\n.tag("path_template", "/api/users/{id}") // Underscores in values OK, not in keys\n')),(0,r.yg)("h2",{id:"common-anti-patterns-and-solutions"},"Common Anti-Patterns and Solutions"),(0,r.yg)("h3",{id:"1-creating-metrics-in-hot-paths"},"1. Creating Metrics in Hot Paths"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Why this is bad:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Warning spam"),": Micrometer logs a warning on first duplicate registration, then debug messages thereafter - problematic if debug logging is enabled"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Performance overhead"),": Registration involves mutex locks and map operations on every request"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Concurrency bugs"),": Race conditions in Micrometer's registration code can cause inconsistent metric state"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Memory leaks"),": High cardinality tags create unbounded metric instances that never get cleaned up")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u274c Bad - Creates metrics repeatedly in request handling\npublic void handleRequest(String userId) {\n    Counter.builder("user_requests")\n        .tag("user", userId)\n        .register(meterRegistry)\n        .increment();\n}\n\n// \u2705 Good - Pre-create metrics outside hot paths\nprivate final Counter requestsCounter = Counter.builder("requests_total")\n    .description("Total requests processed")\n    .register(meterRegistry);\n\npublic void handleRequest(String userId) {\n    requestsCounter.increment();\n\n    // If you need user-specific metrics, use bounded patterns:\n    String userTier = getUserTier(userId); // "free", "premium", "enterprise"\n    getUserTierCounter(userTier).increment();\n}\n')),(0,r.yg)("h3",{id:"2-high-cardinality-tags"},"2. High Cardinality Tags"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u274c Bad - Each user creates new time series\n.tag("user_id", request.getUserId())\n.tag("session_id", request.getSessionId())\n.tag("request_id", request.getRequestId())\n\n// \u2705 Good - Bounded, meaningful dimensions\n.tag("user_tier", getUserTier(request.getUserId()))  // "free", "premium", "enterprise"\n.tag("feature", request.getFeature())               // Limited set of features\n.tag("region", request.getRegion())                 // Limited set of regions\n')),(0,r.yg)("h3",{id:"3-not-using-description"},"3. Not Using Description"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u274c Missing context\nCounter.builder("requests").register(meterRegistry);\n\n// \u2705 Good - Clear description for operators\nCounter.builder("http_requests_total")\n    .description("Total number of HTTP requests processed by the application")\n    .register(meterRegistry);\n')),(0,r.yg)("h2",{id:"memory-and-performance-considerations"},"Memory and Performance Considerations"),(0,r.yg)("h3",{id:"registry-management"},"Registry Management"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'// \u2705 Use a single registry instance across your application\n@Configuration\npublic class MicrometerConfig {\n\n    @Bean\n    @Primary\n    public MeterRegistry meterRegistry() {\n        PrometheusMeterRegistry registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);\n        // Configure common tags that apply to all metrics\n        registry.config().commonTags("application", "datahub", "environment", activeProfile);\n        return registry;\n    }\n}\n')),(0,r.yg)("p",null,"Benefits: simplified configuration, consistent tagging, single endpoint management."))}p.isMDXComponent=!0}}]);