"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[43143],{15680:(e,t,a)=>{a.d(t,{xA:()=>g,yg:()=>d});var n=a(96540);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},g=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,g=s(e,["components","mdxType","originalType","parentName"]),c=p(a),y=i,d=c["".concat(o,".").concat(y)]||c[y]||u[y]||r;return a?n.createElement(d,l(l({ref:t},g),{},{components:a})):n.createElement(d,l({ref:t},g))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=y;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[c]="string"==typeof e?e:i,l[1]=s;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}y.displayName="MDXCreateElement"},14716:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>g,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>p,toc:()=>c});a(96540);var n=a(15680);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})),e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}const s={title:"Design Principles of Java SDK V2",slug:"/metadata-integration/java/docs/sdk-v2/design-principles",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/metadata-integration/java/docs/sdk-v2/design-principles.md"},o="Design Principles of Java SDK V2",p={unversionedId:"metadata-integration/java/docs/sdk-v2/design-principles",id:"metadata-integration/java/docs/sdk-v2/design-principles",title:"Design Principles of Java SDK V2",description:"This document provides an architectural overview of DataHub Java SDK V2, exploring the engineering principles and design patterns that enable its type-safe, efficient metadata management capabilities.",source:"@site/genDocs/metadata-integration/java/docs/sdk-v2/design-principles.md",sourceDirName:"metadata-integration/java/docs/sdk-v2",slug:"/metadata-integration/java/docs/sdk-v2/design-principles",permalink:"/docs/metadata-integration/java/docs/sdk-v2/design-principles",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/metadata-integration/java/docs/sdk-v2/design-principles.md",tags:[],version:"current",frontMatter:{title:"Design Principles of Java SDK V2",slug:"/metadata-integration/java/docs/sdk-v2/design-principles",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/metadata-integration/java/docs/sdk-v2/design-principles.md"},sidebar:"overviewSidebar",previous:{title:"Migration Guide: V1 to V2",permalink:"/docs/metadata-integration/java/docs/sdk-v2/migration-from-v1"},next:{title:"CLI",permalink:"/docs/cli"}},g={},c=[{value:"Architectural Philosophy",id:"architectural-philosophy",level:2},{value:"Core Tenets",id:"core-tenets",level:3},{value:"Layer Architecture",id:"layer-architecture",level:2},{value:"Design Patterns",id:"design-patterns",level:2},{value:"1. Fluent Builder Pattern",id:"1-fluent-builder-pattern",level:3},{value:"2. Patch Accumulation Pattern",id:"2-patch-accumulation-pattern",level:3},{value:"3. Lazy Loading with TTL-Based Caching",id:"3-lazy-loading-with-ttl-based-caching",level:3},{value:"4. Mode-Aware Aspect Selection",id:"4-mode-aware-aspect-selection",level:3},{value:"5. Two Entity Lifecycle Patterns",id:"5-two-entity-lifecycle-patterns",level:3},{value:"<strong>Pattern 1: Builder Construction (New Entities)</strong>",id:"pattern-1-builder-construction-new-entities",level:4},{value:"<strong>Pattern 2: Server Loading (Existing Entities)</strong>",id:"pattern-2-server-loading-existing-entities",level:4},{value:"6. Client Binding for Lazy Loading",id:"6-client-binding-for-lazy-loading",level:3},{value:"Type Safety &amp; Generic Design",id:"type-safety--generic-design",level:2},{value:"Strongly-Typed Aspect Handling",id:"strongly-typed-aspect-handling",level:3},{value:"URN Type Safety",id:"urn-type-safety",level:3},{value:"Integration with Existing Infrastructure",id:"integration-with-existing-infrastructure",level:2},{value:"Reuse of Patch Builders",id:"reuse-of-patch-builders",level:3},{value:"Leverage RestEmitter",id:"leverage-restemitter",level:3},{value:"Resource Management &amp; Efficiency",id:"resource-management--efficiency",level:2},{value:"Batched Emission",id:"batched-emission",level:3},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Graceful Degradation",id:"graceful-degradation",level:3},{value:"Comparison: V1 vs V2 Architecture",id:"comparison-v1-vs-v2-architecture",level:2},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Network Efficiency",id:"network-efficiency",level:3},{value:"Memory Efficiency",id:"memory-efficiency",level:3},{value:"Time Complexity",id:"time-complexity",level:3},{value:"Extension Points",id:"extension-points",level:2},{value:"Summary",id:"summary",level:2}],u={toc:c},y="wrapper";function d(e){var{components:t}=e,a=l(e,["components"]);return(0,n.yg)(y,r(function(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{},n=Object.keys(a);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(a).filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable})))),n.forEach((function(t){i(e,t,a[t])}))}return e}({},u,a),{components:t,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"design-principles-of-java-sdk-v2"},"Design Principles of Java SDK V2"),(0,n.yg)("p",null,"This document provides an architectural overview of DataHub Java SDK V2, exploring the engineering principles and design patterns that enable its type-safe, efficient metadata management capabilities."),(0,n.yg)("h2",{id:"architectural-philosophy"},"Architectural Philosophy"),(0,n.yg)("p",null,"SDK V2 is built on a foundation of ",(0,n.yg)("strong",{parentName:"p"},"pragmatic reuse, intelligent caching, and layered abstractions"),". Rather than reinventing infrastructure, it composes proven components into a coherent, intuitive API while introducing new patterns for efficient metadata operations."),(0,n.yg)("h3",{id:"core-tenets"},"Core Tenets"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Leverage Existing Infrastructure")," - Build atop battle-tested components"),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Type Safety as a First-Class Concern")," - Exploit Java's type system for compile-time correctness"),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Separation of Concerns")," - Clear boundaries between entity, operations, and transport layers"),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Efficiency Through Patches")," - Surgical updates over full replacements"),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Intelligent Resource Management")," - Lazy loading, caching, and batching")),(0,n.yg)("h2",{id:"layer-architecture"},"Layer Architecture"),(0,n.yg)("p",null,"SDK V2 employs a three-layer architecture with clear separation of responsibilities:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre"},"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Entity Layer                              \u2502\n\u2502  (Dataset, Chart, Dashboard - Business Logic)                \u2502\n\u2502  - Fluent builders for entity construction                   \u2502\n\u2502  - Patch accumulation and aspect management                  \u2502\n\u2502  - Mode-aware behavior (SDK vs INGESTION)                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Operations Layer                             \u2502\n\u2502  (EntityClient - CRUD Operations)                            \u2502\n\u2502  - Entity lifecycle management                               \u2502\n\u2502  - Patch vs full aspect emission logic                       \u2502\n\u2502  - Lazy loading coordination                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Transport Layer                             \u2502\n\u2502  (RestEmitter, Patch Builders)                               \u2502\n\u2502  - HTTP communication with DataHub                           \u2502\n\u2502  - MCP serialization and emission                            \u2502\n\u2502  - Patch builder integration                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,n.yg)("h2",{id:"design-patterns"},"Design Patterns"),(0,n.yg)("h3",{id:"1-fluent-builder-pattern"},"1. Fluent Builder Pattern"),(0,n.yg)("p",null,"Entity construction follows a ",(0,n.yg)("strong",{parentName:"p"},"fluent builder pattern")," that guides developers through required fields and provides IDE autocomplete support:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},'Dataset dataset = Dataset.builder()\n    .platform("snowflake")\n    .name("analytics.public.events")\n    .env("PROD")\n    .description("User events")\n    .build();\n')),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Engineering Benefits:")),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Compile-time validation")," - Missing required fields (platform, name) fail at compilation"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Immutable construction")," - Builder accumulates state; ",(0,n.yg)("inlineCode",{parentName:"li"},"build()")," creates immutable entity"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Discoverability")," - IDE autocomplete reveals available methods"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Extensibility")," - New optional parameters added without breaking existing code")),(0,n.yg)("h3",{id:"2-patch-accumulation-pattern"},"2. Patch Accumulation Pattern"),(0,n.yg)("p",null,"Rather than modifying aspects directly, mutations create ",(0,n.yg)("strong",{parentName:"p"},"patch MCPs")," that accumulate in a pending list:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},'dataset.addTag("pii")                          // Creates patch MCP\n       .addOwner("user", TECHNICAL_OWNER)      // Creates patch MCP\n       .addCustomProperty("retention", "90");  // Creates patch MCP\n\nclient.entities().upsert(dataset);  // Emits all patches atomically\n')),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Engineering Benefits:")),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Deferred execution")," - Batches multiple changes into a single network round-trip"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Atomic updates")," - All patches applied together or none"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Efficient transmission")," - Only changed fields sent over wire"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Reuse of proven infrastructure")," - Leverages existing ",(0,n.yg)("inlineCode",{parentName:"li"},"datahub.client.patch")," builders")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Implementation Detail:"),"\nEntity base class maintains multiple change tracking mechanisms:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"// From Entity.java\nprotected final Map<String, RecordTemplate> aspectCache;        // Cached aspects from builder\nprotected final List<MetadataChangeProposalWrapper> pendingMCPs; // Full aspect replacements\nprotected final List<MetadataChangeProposal> pendingPatches;     // Incremental patches\n")),(0,n.yg)("p",null,"Each mutation (addTag, addOwner) creates a patch using existing builders:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"// From Dataset.java\npublic Dataset addTag(@Nonnull String tagUrn) {\n    GlobalTagsPatchBuilder patch = new GlobalTagsPatchBuilder()\n        .urn(getUrn())\n        .addTag(tag, null);\n    addPatchMcp(patch.build());  // Adds to pendingPatches list\n    return this;\n}\n")),(0,n.yg)("p",null,"When ",(0,n.yg)("inlineCode",{parentName:"p"},"EntityClient.upsert()")," is called, it emits ",(0,n.yg)("strong",{parentName:"p"},"everything")," accumulated on the entity in order:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"// From EntityClient.upsert()\n\n// Step 1: Emit cached aspects (from builder)\nif (!entity.toMCPs().isEmpty()) {\n    for (MetadataChangeProposalWrapper mcp : entity.toMCPs()) {\n        emitter.emit(mcp);\n    }\n}\n\n// Step 2: Emit pending full aspect MCPs (from set*() methods)\nif (entity.hasPendingMCPs()) {\n    for (MetadataChangeProposalWrapper mcp : entity.getPendingMCPs()) {\n        emitter.emit(mcp);\n    }\n    entity.clearPendingMCPs();\n}\n\n// Step 3: Emit all pending patches (from add*/remove* methods)\nif (entity.hasPendingPatches()) {\n    for (MetadataChangeProposal patchMcp : entity.getPendingPatches()) {\n        emitter.emit(patchMcp, null);\n    }\n    entity.clearPendingPatches();\n}\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Key insight:")," ",(0,n.yg)("inlineCode",{parentName:"p"},"upsert()")," is not an either/or operation - it emits ",(0,n.yg)("strong",{parentName:"p"},"all")," accumulated changes. What gets sent depends on what you've accumulated on the entity, not which method you call."),(0,n.yg)("h3",{id:"3-lazy-loading-with-ttl-based-caching"},"3. Lazy Loading with TTL-Based Caching"),(0,n.yg)("p",null,"Entities support ",(0,n.yg)("strong",{parentName:"p"},"lazy aspect loading")," to minimize network calls while ensuring data freshness:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"// Entity maintains aspect cache with timestamps\nprotected final Map<String, RecordTemplate> aspectCache;\nprotected final Map<String, Long> aspectTimestamps;\nprotected long cacheTtlMs = 60000;  // 60-second default TTL\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Loading Strategy:")),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Cache-only access")," (",(0,n.yg)("inlineCode",{parentName:"li"},"getAspectCached"),") - Returns cached aspect or null"),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Lazy loading")," (",(0,n.yg)("inlineCode",{parentName:"li"},"getAspectLazy"),") - Checks cache freshness, fetches from server if stale"),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Get-or-create")," (",(0,n.yg)("inlineCode",{parentName:"li"},"getOrCreateAspect"),") - Returns cached or creates new empty aspect locally")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Implementation:")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"protected <T extends RecordTemplate> T getAspectLazy(@Nonnull Class<T> aspectClass) {\n    String aspectName = getAspectName(aspectClass);\n\n    // Check cache freshness\n    if (aspectCache.containsKey(aspectName)) {\n        Long timestamp = aspectTimestamps.get(aspectName);\n        if (timestamp != null && System.currentTimeMillis() - timestamp < cacheTtlMs) {\n            return aspectClass.cast(aspectCache.get(aspectName));\n        }\n    }\n\n    // Fetch from server if client is bound\n    if (client != null) {\n        T aspect = client.getAspect(urn, aspectClass);\n        if (aspect != null) {\n            aspectCache.put(aspectName, aspect);\n            aspectTimestamps.put(aspectName, System.currentTimeMillis());\n        }\n        return aspect;\n    }\n\n    return null;\n}\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Engineering Benefits:")),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Network efficiency")," - Reduces redundant server calls"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Freshness guarantee")," - Configurable TTL ensures data isn't stale"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Transparent to caller")," - Complexity hidden behind simple getter"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Client binding")," - Entities bound to EntityClient enable lazy loading")),(0,n.yg)("h3",{id:"4-mode-aware-aspect-selection"},"4. Mode-Aware Aspect Selection"),(0,n.yg)("p",null,"SDK V2 distinguishes between ",(0,n.yg)("strong",{parentName:"p"},"user-initiated edits")," (SDK mode) and ",(0,n.yg)("strong",{parentName:"p"},"system/pipeline writes")," (INGESTION mode):"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"public enum OperationMode {\n    SDK,        // Interactive use - writes to editable aspects\n    INGESTION   // ETL pipelines - writes to system aspects\n}\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Aspect Routing:")),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"SDK Mode")," \u2192 ",(0,n.yg)("inlineCode",{parentName:"li"},"editableDatasetProperties"),", ",(0,n.yg)("inlineCode",{parentName:"li"},"editableSchemaMetadata")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"INGESTION Mode")," \u2192 ",(0,n.yg)("inlineCode",{parentName:"li"},"datasetProperties"),", ",(0,n.yg)("inlineCode",{parentName:"li"},"schemaMetadata"))),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Implementation:")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"public Dataset setDescription(@Nonnull String description) {\n    if (isIngestionMode()) {\n        return setSystemDescription(description);  // datasetProperties\n    } else {\n        return setEditableDescription(description); // editableDatasetProperties\n    }\n}\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Engineering Benefits:")),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Clear provenance")," - Distinguishes human vs machine edits"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"UI consistency")," - DataHub UI shows editable aspects as user overrides"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Non-destructive")," - System data preserved even when users add documentation"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Lineage preservation")," - Ingestion pipelines can refresh system data without clobbering user edits")),(0,n.yg)("h3",{id:"5-two-entity-lifecycle-patterns"},"5. Two Entity Lifecycle Patterns"),(0,n.yg)("p",null,"Entities can be instantiated in two ways, each with distinct semantics:"),(0,n.yg)("h4",{id:"pattern-1-builder-construction-new-entities"},(0,n.yg)("strong",{parentName:"h4"},"Pattern 1: Builder Construction (New Entities)")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},'Dataset dataset = Dataset.builder()\n    .platform("snowflake")\n    .name("my_table")\n    .build();\n// aspectCache populated with builder-provided aspects\n// aspectTimestamps empty - indicates new entity\n')),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Use case:")," Creating new entities from scratch"),(0,n.yg)("h4",{id:"pattern-2-server-loading-existing-entities"},(0,n.yg)("strong",{parentName:"h4"},"Pattern 2: Server Loading (Existing Entities)")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"Dataset dataset = client.entities().get(urn);\n// aspectCache populated with server aspects\n// aspectTimestamps records fetch time for each aspect\n// Entity automatically bound to client for lazy loading\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Use case:")," Modifying existing entities with current server state. When you access aspects not already cached, the entity will automatically fetch them from the server (lazy loading)."),(0,n.yg)("h3",{id:"6-client-binding-for-lazy-loading"},"6. Client Binding for Lazy Loading"),(0,n.yg)("p",null,"Entities are ",(0,n.yg)("strong",{parentName:"p"},"automatically bound to an EntityClient")," when loaded from the server or during ",(0,n.yg)("inlineCode",{parentName:"p"},"upsert()")," to enable lazy aspect fetching:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"public void bindToClient(@Nonnull EntityClient client,\n                        @Nonnull OperationMode mode) {\n    if (this.client == null) {\n        this.client = client;\n    }\n    if (this.mode == null) {\n        this.mode = mode;\n    }\n}\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Binding occurs automatically")," during ",(0,n.yg)("inlineCode",{parentName:"p"},"upsert()"),":"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"// From EntityClient.upsert()\nentity.bindToClient(this, config.getMode());\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Engineering Benefits:")),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Transparent lazy loading")," - Aspects fetched on first access if not cached"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Automatic binding")," - Entities bound to client during ",(0,n.yg)("inlineCode",{parentName:"li"},"get()")," or ",(0,n.yg)("inlineCode",{parentName:"li"},"upsert()")," operations"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Mode propagation")," - Client mode automatically applied to entity")),(0,n.yg)("h2",{id:"type-safety--generic-design"},"Type Safety & Generic Design"),(0,n.yg)("h3",{id:"strongly-typed-aspect-handling"},"Strongly-Typed Aspect Handling"),(0,n.yg)("p",null,"SDK V2 leverages Java generics to provide compile-time type safety for aspects:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"// Type-safe aspect retrieval\nprotected <T extends RecordTemplate> T getAspectLazy(@Nonnull Class<T> aspectClass) {\n    String aspectName = getAspectName(aspectClass);\n    RecordTemplate aspect = aspectCache.get(aspectName);\n    return aspectClass.cast(aspect);\n}\n\n// Usage - compiler enforces type correctness\nDatasetProperties props = dataset.getAspectLazy(DatasetProperties.class);\n")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Engineering Benefits:")),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Compile-time checking")," - Type mismatches caught before runtime"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Refactoring safety")," - IDE can trace aspect usages across codebase"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Autocomplete support")," - IDE suggests available aspects"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Runtime safety")," - ",(0,n.yg)("inlineCode",{parentName:"li"},"ClassCastException")," impossible with correct usage")),(0,n.yg)("h3",{id:"urn-type-safety"},"URN Type Safety"),(0,n.yg)("p",null,"Entity-specific URN types prevent incorrect URN usage:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"public class Dataset extends Entity {\n    public DatasetUrn getDatasetUrn() {\n        return (DatasetUrn) urn;\n    }\n}\n\n// Compile-time enforcement\nDatasetUrn urn = dataset.getDatasetUrn();  // Type-safe\nUrn genericUrn = dataset.getUrn();         // Also available\n")),(0,n.yg)("h2",{id:"integration-with-existing-infrastructure"},"Integration with Existing Infrastructure"),(0,n.yg)("h3",{id:"reuse-of-patch-builders"},"Reuse of Patch Builders"),(0,n.yg)("p",null,"SDK V2 ",(0,n.yg)("strong",{parentName:"p"},"reuses existing patch builders")," from ",(0,n.yg)("inlineCode",{parentName:"p"},"datahub.client.patch")," rather than creating new implementations:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"OwnershipPatchBuilder")," - Owner additions/removals"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"GlobalTagsPatchBuilder")," - Tag management"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"GlossaryTermsPatchBuilder")," - Term associations"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"DomainsPatchBuilder")," - Domain assignment"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"DatasetPropertiesPatchBuilder")," - Property updates"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"EditableDatasetPropertiesPatchBuilder")," - Editable property updates")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Engineering Benefits:")),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Battle-tested logic")," - Patch builders used in production by Python SDK"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Consistency")," - Same patch semantics across language SDKs"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Maintainability")," - Single implementation to maintain"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Correctness")," - Complex JSON Patch logic already validated")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Example Integration:")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},"public Dataset addOwner(@Nonnull String ownerUrn, @Nonnull OwnershipType type) {\n    Urn owner = Urn.createFromString(ownerUrn);\n    OwnershipPatchBuilder patch = new OwnershipPatchBuilder()\n        .urn(getUrn())\n        .addOwner(owner, type);\n    addPatchMcp(patch.build());  // Stores patch MCP\n    return this;\n}\n")),(0,n.yg)("h3",{id:"leverage-restemitter"},"Leverage RestEmitter"),(0,n.yg)("p",null,"Transport layer reuses ",(0,n.yg)("inlineCode",{parentName:"p"},"RestEmitter")," for HTTP communication:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Non-blocking emission with futures"),(0,n.yg)("li",{parentName:"ul"},"Configurable retries and timeouts"),(0,n.yg)("li",{parentName:"ul"},"Token-based authentication"),(0,n.yg)("li",{parentName:"ul"},"Async HTTP client pooling")),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"No changes to RestEmitter")," - SDK V2 is purely additive."),(0,n.yg)("h2",{id:"resource-management--efficiency"},"Resource Management & Efficiency"),(0,n.yg)("h3",{id:"batched-emission"},"Batched Emission"),(0,n.yg)("p",null,"Multiple patches accumulated and emitted atomically:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},'dataset.addTag("tag1").addTag("tag2").addOwner("user1", OWNER);\nclient.entities().upsert(dataset);  // Single network call, 3 patches\n')),(0,n.yg)("h3",{id:"connection-pooling"},"Connection Pooling"),(0,n.yg)("p",null,"RestEmitter uses ",(0,n.yg)("inlineCode",{parentName:"p"},"CloseableHttpAsyncClient")," with connection pooling for efficient HTTP reuse."),(0,n.yg)("h3",{id:"graceful-degradation"},"Graceful Degradation"),(0,n.yg)("p",null,"Lazy loading failures logged but don't crash:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-java"},'catch (Exception e) {\n    log.warn("Failed to lazy-load aspect {}: {}", aspectName, e.getMessage());\n    return null;  // Graceful degradation\n}\n')),(0,n.yg)("h2",{id:"comparison-v1-vs-v2-architecture"},"Comparison: V1 vs V2 Architecture"),(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Aspect"),(0,n.yg)("th",{parentName:"tr",align:null},"V1 (RestEmitter)"),(0,n.yg)("th",{parentName:"tr",align:null},"V2 (DataHubClientV2)"))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("strong",{parentName:"td"},"Abstraction Level")),(0,n.yg)("td",{parentName:"tr",align:null},"Low - MCPs"),(0,n.yg)("td",{parentName:"tr",align:null},"High - Entities")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("strong",{parentName:"td"},"URN Construction")),(0,n.yg)("td",{parentName:"tr",align:null},"Manual strings"),(0,n.yg)("td",{parentName:"tr",align:null},"Automatic from builder")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("strong",{parentName:"td"},"Aspect Wiring")),(0,n.yg)("td",{parentName:"tr",align:null},"Manual MCP building"),(0,n.yg)("td",{parentName:"tr",align:null},"Hidden in entity methods")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("strong",{parentName:"td"},"Updates")),(0,n.yg)("td",{parentName:"tr",align:null},"Full aspect replacement"),(0,n.yg)("td",{parentName:"tr",align:null},"Patch-based incremental")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("strong",{parentName:"td"},"Type Safety")),(0,n.yg)("td",{parentName:"tr",align:null},"Minimal - generic MCPs"),(0,n.yg)("td",{parentName:"tr",align:null},"Strong - typed entities")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("strong",{parentName:"td"},"Lazy Loading")),(0,n.yg)("td",{parentName:"tr",align:null},"Not supported"),(0,n.yg)("td",{parentName:"tr",align:null},"TTL-based caching")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("strong",{parentName:"td"},"Mode Awareness")),(0,n.yg)("td",{parentName:"tr",align:null},"Not supported"),(0,n.yg)("td",{parentName:"tr",align:null},"SDK vs INGESTION modes")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("strong",{parentName:"td"},"Learning Curve")),(0,n.yg)("td",{parentName:"tr",align:null},"Steep - requires MCP knowledge"),(0,n.yg)("td",{parentName:"tr",align:null},"Gentle - intuitive builders")))),(0,n.yg)("h2",{id:"performance-characteristics"},"Performance Characteristics"),(0,n.yg)("h3",{id:"network-efficiency"},"Network Efficiency"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Patch-based updates"),": O(changed_fields) vs O(all_fields)"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Lazy loading"),": Aspects fetched only when accessed"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Batch emission"),": Multiple patches sent in single flush"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Connection reuse"),": HTTP client pooling")),(0,n.yg)("h3",{id:"memory-efficiency"},"Memory Efficiency"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Aspect caching"),": Only fetched aspects stored"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"TTL expiration"),": Stale aspects eligible for GC"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Lazy instantiation"),": Aspects created on-demand")),(0,n.yg)("h3",{id:"time-complexity"},"Time Complexity"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Entity creation"),": O(1) - builder accumulation"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Patch addition"),": O(1) - append to list"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Upsert operation"),": O(n) where n = pending patches or cached aspects"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Lazy fetch"),": O(1) cache lookup + O(1) network if miss")),(0,n.yg)("h2",{id:"extension-points"},"Extension Points"),(0,n.yg)("p",null,"SDK V2 designed for extensibility:"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"New entity types")," - Extend ",(0,n.yg)("inlineCode",{parentName:"li"},"Entity")," base class"),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Custom aspects")," - Use ",(0,n.yg)("inlineCode",{parentName:"li"},"getAspectLazy")," / ",(0,n.yg)("inlineCode",{parentName:"li"},"getOrCreateAspect")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"New patch types")," - Leverage existing patch builders"),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Custom caching")," - Override ",(0,n.yg)("inlineCode",{parentName:"li"},"cacheTtlMs")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("strong",{parentName:"li"},"Transport customization")," - Customize RestEmitter via builder")),(0,n.yg)("h2",{id:"summary"},"Summary"),(0,n.yg)("p",null,"Java SDK V2 achieves its goals through principled design:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Reuse over reinvention")," - Leverages existing patch builders and RestEmitter"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Patches over replacements")," - Efficient incremental updates"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Lazy over eager")," - Aspects fetched on-demand with caching"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Type safety over convenience")," - Strong typing throughout"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Layers over monoliths")," - Clear separation of entity, operations, transport"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Pragmatism over purity")," - Mode-aware behavior matches real-world usage")),(0,n.yg)("p",null,"The result is an SDK that feels natural to Java developers while providing the efficiency and correctness required for production metadata management at scale."))}d.isMDXComponent=!0}}]);