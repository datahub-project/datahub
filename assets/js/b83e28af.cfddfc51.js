"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[20190],{15873:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>g,default:()=>h,frontMatter:()=>u,metadata:()=>d,toc:()=>m});n(96540);var a=n(15680),r=n(53720),i=n(5400);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}const u={sidebar_position:32,title:"Query",slug:"/generated/metamodel/entities/query",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/query.md"},g="Query",d={unversionedId:"docs/generated/metamodel/entities/query",id:"docs/generated/metamodel/entities/query",title:"Query",description:"The query entity represents SQL queries (or queries in other languages) that have been executed against one or more data assets such as datasets, tables, or views. Query entities capture both manually created queries and queries discovered through automated crawling of query logs from data platforms like BigQuery, Snowflake, Redshift, and others.",source:"@site/genDocs/docs/generated/metamodel/entities/query.md",sourceDirName:"docs/generated/metamodel/entities",slug:"/generated/metamodel/entities/query",permalink:"/docs/generated/metamodel/entities/query",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/query.md",tags:[],version:"current",sidebarPosition:32,frontMatter:{sidebar_position:32,title:"Query",slug:"/generated/metamodel/entities/query",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/query.md"},sidebar:"overviewSidebar",previous:{title:"ER Model Relationship",permalink:"/docs/generated/metamodel/entities/ermodelrelationship"},next:{title:"Data Product",permalink:"/docs/generated/metamodel/entities/dataproduct"}},p={},m=[{value:"Identity",id:"identity",level:2},{value:"Important Capabilities",id:"important-capabilities",level:2},{value:"Query Properties",id:"query-properties",level:3},{value:"Query Subjects",id:"query-subjects",level:3},{value:"Query Usage Statistics",id:"query-usage-statistics",level:3},{value:"Tags and Glossary Terms",id:"tags-and-glossary-terms",level:3},{value:"Adding Tags to a Query",id:"adding-tags-to-a-query",level:4},{value:"Adding Glossary Terms to a Query",id:"adding-glossary-terms-to-a-query",level:4},{value:"Ownership",id:"ownership",level:3},{value:"Platform Instance",id:"platform-instance",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"Relationship with Datasets",id:"relationship-with-datasets",level:3},{value:"Lineage Integration",id:"lineage-integration",level:3},{value:"Ingestion Sources",id:"ingestion-sources",level:3},{value:"GraphQL API",id:"graphql-api",level:3},{value:"Usage Analytics",id:"usage-analytics",level:3},{value:"Notable Exceptions",id:"notable-exceptions",level:2},{value:"Query Deduplication",id:"query-deduplication",level:3},{value:"Temporary Tables",id:"temporary-tables",level:3},{value:"Query Size Limits",id:"query-size-limits",level:3},{value:"Language Support",id:"language-support",level:3},{value:"Manual vs System Queries",id:"manual-vs-system-queries",level:3},{value:"Technical Reference Guide",id:"technical-reference-guide",level:2},{value:"Reading the Field Tables",id:"reading-the-field-tables",level:3},{value:"Aspects",id:"aspects",level:3},{value:"queryProperties",id:"queryproperties",level:4},{value:"querySubjects",id:"querysubjects",level:4},{value:"status",id:"status",level:4},{value:"dataPlatformInstance",id:"dataplatforminstance",level:4},{value:"subTypes",id:"subtypes",level:4},{value:"queryUsageStatistics (Timeseries)",id:"queryusagestatistics-timeseries",level:4},{value:"Common Types",id:"common-types",level:3},{value:"AuditStamp",id:"auditstamp",level:4},{value:"Relationships",id:"relationships",level:3},{value:"Global Metadata Model",id:"global-metadata-model",level:3}],y={toc:m},c="wrapper";function h(e){var{components:t}=e,n=o(e,["components"]);return(0,a.yg)(c,s(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){l(e,t,n[t])}))}return e}({},y,n),{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"query"},"Query"),(0,a.yg)("p",null,"The query entity represents SQL queries (or queries in other languages) that have been executed against one or more data assets such as datasets, tables, or views. Query entities capture both manually created queries and queries discovered through automated crawling of query logs from data platforms like BigQuery, Snowflake, Redshift, and others."),(0,a.yg)("p",null,"Queries are powerful building blocks for understanding data lineage, usage patterns, and relationships between datasets. When DataHub ingests query logs from data warehouses, it automatically creates query entities that capture the SQL statements, the datasets they reference, execution statistics, and usage patterns over time."),(0,a.yg)("h2",{id:"identity"},"Identity"),(0,a.yg)("p",null,"Query entities are identified by a single piece of information:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"A unique identifier (",(0,a.yg)("inlineCode",{parentName:"li"},"id"),") that serves as the key for the query entity. This identifier is typically generated as a hash of the normalized query text, ensuring that identical queries are deduplicated and treated as the same entity.")),(0,a.yg)("p",null,"An example of a query identifier is ",(0,a.yg)("inlineCode",{parentName:"p"},"urn:li:query:3b8d7b8c7e4e8b4e3c2e1a5c6d7e8f9a"),". The identifier is a unique string that can be generated through various means:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"A hash of the normalized SQL query text (common for system-discovered queries)"),(0,a.yg)("li",{parentName:"ul"},"A user-provided identifier (for manually created queries)"),(0,a.yg)("li",{parentName:"ul"},"A platform-specific query identifier")),(0,a.yg)("h2",{id:"important-capabilities"},"Important Capabilities"),(0,a.yg)("h3",{id:"query-properties"},"Query Properties"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"queryProperties")," aspect contains the core information about a query:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Statement"),": The actual query text and its language (SQL, or UNKNOWN)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Source"),": How the query was discovered (",(0,a.yg)("inlineCode",{parentName:"li"},"MANUAL")," for user-entered queries via UI, or ",(0,a.yg)("inlineCode",{parentName:"li"},"SYSTEM")," for queries discovered by crawlers)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Name"),": Optional display name to identify the query in a human-readable way"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Description"),": Optional description providing context about what the query does"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Created/Modified"),": Audit stamps tracking who created and last modified the query, along with timestamps"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Origin"),": The source entity that this query came from (e.g., a View, Stored Procedure, dbt Model, etc.)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Custom Properties"),": Additional key-value pairs for platform-specific metadata")),(0,a.yg)("p",null,"The following code snippet shows you how to create a query entity with properties."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Create a query with properties"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/query_create.py\n# metadata-ingestion/examples/library/query_create.py\nimport logging\nimport os\nimport time\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    QueryLanguageClass,\n    QueryPropertiesClass,\n    QuerySourceClass,\n    QueryStatementClass,\n    QuerySubjectClass,\n    QuerySubjectsClass,\n)\nfrom datahub.metadata.urns import CorpUserUrn, DatasetUrn, QueryUrn\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\nquery_id = "my-unique-query-id"\nquery_urn = QueryUrn(query_id)\n\ncurrent_timestamp = int(time.time() * 1000)\nactor_urn = CorpUserUrn("datahub")\n\nquery_properties = QueryPropertiesClass(\n    statement=QueryStatementClass(\n        value="SELECT customer_id, order_total FROM orders WHERE order_date >= \'2024-01-01\'",\n        language=QueryLanguageClass.SQL,\n    ),\n    source=QuerySourceClass.MANUAL,\n    name="Customer Orders Q1 2024",\n    description="Query to retrieve all customer orders from Q1 2024 for reporting",\n    created=AuditStampClass(time=current_timestamp, actor=actor_urn.urn()),\n    lastModified=AuditStampClass(time=current_timestamp, actor=actor_urn.urn()),\n)\n\ndataset_urn = DatasetUrn.from_string(\n    "urn:li:dataset:(urn:li:dataPlatform:postgres,public.orders,PROD)"\n)\nquery_subjects = QuerySubjectsClass(\n    subjects=[\n        QuerySubjectClass(entity=dataset_urn.urn()),\n    ]\n)\n\ngms_server = os.getenv("DATAHUB_GMS_URL", "http://localhost:8080")\ntoken = os.getenv("DATAHUB_GMS_TOKEN")\nrest_emitter = DatahubRestEmitter(gms_server=gms_server, token=token)\n\nmcpw_properties = MetadataChangeProposalWrapper(\n    entityUrn=query_urn.urn(),\n    aspect=query_properties,\n)\nrest_emitter.emit(mcpw_properties)\n\nmcpw_subjects = MetadataChangeProposalWrapper(\n    entityUrn=query_urn.urn(),\n    aspect=query_subjects,\n)\nrest_emitter.emit(mcpw_subjects)\n\nlog.info(f"Created query {query_urn}")\n\n'))),(0,a.yg)("p",null,"You can also update specific properties of an existing query:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Update query properties"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/query_update_properties.py\n# metadata-ingestion/examples/library/query_update_properties.py\nimport logging\nimport time\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DataHubGraph, DataHubGraphConfig\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    QueryPropertiesClass,\n)\nfrom datahub.metadata.urns import CorpUserUrn, QueryUrn\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\nquery_urn = QueryUrn("my-unique-query-id")\n\ngraph = DataHubGraph(DataHubGraphConfig(server="http://localhost:8080"))\nemitter = DatahubRestEmitter(gms_server="http://localhost:8080")\n\nexisting_properties = graph.get_aspect(\n    entity_urn=query_urn.urn(),\n    aspect_type=QueryPropertiesClass,\n)\n\nif not existing_properties:\n    log.error(f"Query {query_urn} does not exist or has no properties")\n    exit(1)\n\ncurrent_timestamp = int(time.time() * 1000)\nactor_urn = CorpUserUrn("datahub")\n\nexisting_properties.name = "Updated Query Name"\nexisting_properties.description = "This query has been updated with new documentation"\nexisting_properties.lastModified = AuditStampClass(\n    time=current_timestamp, actor=actor_urn.urn()\n)\n\nevent = MetadataChangeProposalWrapper(\n    entityUrn=query_urn.urn(),\n    aspect=existing_properties,\n)\n\nemitter.emit(event)\nlog.info(f"Updated properties for query {query_urn}")\n\n'))),(0,a.yg)("h3",{id:"query-subjects"},"Query Subjects"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"querySubjects")," aspect captures the data assets that are referenced by a query. These are the datasets, tables, views, or other entities that the query reads from or writes to."),(0,a.yg)("p",null,"In single-asset queries (e.g., ",(0,a.yg)("inlineCode",{parentName:"p"},"SELECT * FROM table"),"), the subjects will contain a single table reference. In multi-asset queries (e.g., joins across multiple tables), the subjects may contain multiple table references."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add subjects to a query"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/query_add_subjects.py\n# metadata-ingestion/examples/library/query_add_subjects.py\nimport logging\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DataHubGraph, DataHubGraphConfig\nfrom datahub.metadata.schema_classes import QuerySubjectClass, QuerySubjectsClass\nfrom datahub.metadata.urns import DatasetUrn, QueryUrn\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\nquery_urn = QueryUrn("my-unique-query-id")\n\ngraph = DataHubGraph(DataHubGraphConfig(server="http://localhost:8080"))\nemitter = DatahubRestEmitter(gms_server="http://localhost:8080")\n\nexisting_subjects = graph.get_aspect(\n    entity_urn=query_urn.urn(),\n    aspect_type=QuerySubjectsClass,\n)\n\nsubjects = existing_subjects.subjects if existing_subjects else []\n\nnew_dataset_urn = DatasetUrn.from_string(\n    "urn:li:dataset:(urn:li:dataPlatform:postgres,public.customers,PROD)"\n)\nnew_subject = QuerySubjectClass(entity=new_dataset_urn.urn())\n\nif new_subject not in subjects:\n    subjects.append(new_subject)\n\nquery_subjects_aspect = QuerySubjectsClass(subjects=subjects)\n\nevent = MetadataChangeProposalWrapper(\n    entityUrn=query_urn.urn(),\n    aspect=query_subjects_aspect,\n)\n\nemitter.emit(event)\nlog.info(f"Added subject to query {query_urn}")\n\n'))),(0,a.yg)("h3",{id:"query-usage-statistics"},"Query Usage Statistics"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"queryUsageStatistics")," aspect is a timeseries aspect that tracks execution statistics and usage patterns for queries over time. This includes:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Query Count"),": Total number of times the query was executed in a time bucket"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Query Cost"),": The compute cost associated with executing the query (platform-specific)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Last Executed At"),": Timestamp of the most recent execution"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Unique User Count"),": Number of distinct users who executed the query"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"User Counts"),": Breakdown of execution counts by individual users")),(0,a.yg)("p",null,"This aspect is typically populated automatically by ingestion connectors that process query logs from data platforms. The timeseries nature allows for tracking trends and patterns in query usage over time."),(0,a.yg)("h3",{id:"tags-and-glossary-terms"},"Tags and Glossary Terms"),(0,a.yg)("p",null,'Like other DataHub entities, queries can have Tags or Terms attached to them. Tags are informal labels for categorizing queries (e.g., "production", "experimental", "deprecated"), while Terms are formal vocabulary from a business glossary (e.g., "Customer Data", "Financial Reporting").'),(0,a.yg)("h4",{id:"adding-tags-to-a-query"},"Adding Tags to a Query"),(0,a.yg)("p",null,"Tags are added to queries using the ",(0,a.yg)("inlineCode",{parentName:"p"},"globalTags")," aspect."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add a tag to a query"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/query_add_tag.py\n# metadata-ingestion/examples/library/query_add_tag.py\nimport logging\n\nfrom datahub.emitter.mce_builder import make_tag_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DataHubGraph, DataHubGraphConfig\nfrom datahub.metadata.schema_classes import GlobalTagsClass, TagAssociationClass\nfrom datahub.metadata.urns import QueryUrn\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\nquery_urn = QueryUrn("my-unique-query-id")\n\ngraph = DataHubGraph(DataHubGraphConfig(server="http://localhost:8080"))\nemitter = DatahubRestEmitter(gms_server="http://localhost:8080")\n\nexisting_tags = graph.get_aspect(\n    entity_urn=query_urn.urn(),\n    aspect_type=GlobalTagsClass,\n)\n\ntags_to_add = existing_tags.tags if existing_tags else []\n\ntags_to_add.append(\n    TagAssociationClass(tag=make_tag_urn("production"), context="Query categorization")\n)\n\nglobal_tags_aspect = GlobalTagsClass(tags=tags_to_add)\n\nevent = MetadataChangeProposalWrapper(\n    entityUrn=query_urn.urn(),\n    aspect=global_tags_aspect,\n)\n\nemitter.emit(event)\nlog.info(f"Added tag to query {query_urn}")\n\n'))),(0,a.yg)("h4",{id:"adding-glossary-terms-to-a-query"},"Adding Glossary Terms to a Query"),(0,a.yg)("p",null,"Terms are added using the ",(0,a.yg)("inlineCode",{parentName:"p"},"glossaryTerms")," aspect."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add a term to a query"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/query_add_term.py\n# metadata-ingestion/examples/library/query_add_term.py\nimport logging\n\nfrom datahub.emitter.mce_builder import make_term_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DataHubGraph, DataHubGraphConfig\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    GlossaryTermAssociationClass,\n    GlossaryTermsClass,\n)\nfrom datahub.metadata.urns import QueryUrn\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\nquery_urn = QueryUrn("my-unique-query-id")\n\ngraph = DataHubGraph(DataHubGraphConfig(server="http://localhost:8080"))\nemitter = DatahubRestEmitter(gms_server="http://localhost:8080")\n\nexisting_terms = graph.get_aspect(\n    entity_urn=query_urn.urn(),\n    aspect_type=GlossaryTermsClass,\n)\n\nterms_to_add = existing_terms.terms if existing_terms else []\n\nterms_to_add.append(\n    GlossaryTermAssociationClass(\n        urn=make_term_urn("CustomerData"), context="Query subject area"\n    )\n)\n\nglossary_terms_aspect = GlossaryTermsClass(\n    terms=terms_to_add,\n    auditStamp=AuditStampClass(time=0, actor="urn:li:corpuser:datahub"),\n)\n\nevent = MetadataChangeProposalWrapper(\n    entityUrn=query_urn.urn(),\n    aspect=glossary_terms_aspect,\n)\n\nemitter.emit(event)\nlog.info(f"Added glossary term to query {query_urn}")\n\n'))),(0,a.yg)("h3",{id:"ownership"},"Ownership"),(0,a.yg)("p",null,"Ownership is associated to a query using the ",(0,a.yg)("inlineCode",{parentName:"p"},"ownership")," aspect. Owners can be of different types such as ",(0,a.yg)("inlineCode",{parentName:"p"},"TECHNICAL_OWNER"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"BUSINESS_OWNER"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"DATA_STEWARD"),", etc. Ownership helps identify who is responsible for maintaining and understanding specific queries."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add an owner to a query"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/query_add_owner.py\n# metadata-ingestion/examples/library/query_add_owner.py\nimport logging\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DataHubGraph, DataHubGraphConfig\nfrom datahub.metadata.schema_classes import (\n    OwnerClass,\n    OwnershipClass,\n    OwnershipTypeClass,\n)\nfrom datahub.metadata.urns import CorpUserUrn, QueryUrn\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\nquery_urn = QueryUrn("my-unique-query-id")\n\ngraph = DataHubGraph(DataHubGraphConfig(server="http://localhost:8080"))\nemitter = DatahubRestEmitter(gms_server="http://localhost:8080")\n\nexisting_ownership = graph.get_aspect(\n    entity_urn=query_urn.urn(),\n    aspect_type=OwnershipClass,\n)\n\nowners = existing_ownership.owners if existing_ownership else []\n\nnew_owner = OwnerClass(\n    owner=CorpUserUrn("jdoe").urn(),\n    type=OwnershipTypeClass.TECHNICAL_OWNER,\n)\n\nif new_owner not in owners:\n    owners.append(new_owner)\n\nownership_aspect = OwnershipClass(\n    owners=owners,\n)\n\nevent = MetadataChangeProposalWrapper(\n    entityUrn=query_urn.urn(),\n    aspect=ownership_aspect,\n)\n\nemitter.emit(event)\nlog.info(f"Added owner to query {query_urn}")\n\n'))),(0,a.yg)("h3",{id:"platform-instance"},"Platform Instance"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"dataPlatformInstance")," aspect allows you to specify which specific instance of a data platform the query is associated with. This is useful when you have multiple instances of the same platform (e.g., multiple Snowflake accounts or BigQuery projects)."),(0,a.yg)("h2",{id:"integration-points"},"Integration Points"),(0,a.yg)("h3",{id:"relationship-with-datasets"},"Relationship with Datasets"),(0,a.yg)("p",null,"Queries have a fundamental relationship with dataset entities through the ",(0,a.yg)("inlineCode",{parentName:"p"},"querySubjects")," aspect. Each subject in a query references a dataset URN, creating a bidirectional relationship that allows you to:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Navigate from a query to the datasets it references"),(0,a.yg)("li",{parentName:"ul"},"Navigate from a dataset to all queries that reference it")),(0,a.yg)("p",null,"This relationship is crucial for understanding dataset usage and query-based lineage."),(0,a.yg)("h3",{id:"lineage-integration"},"Lineage Integration"),(0,a.yg)("p",null,"Queries play a central role in DataHub's lineage capabilities:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Query-based Lineage"),": When DataHub processes SQL queries (either from query logs or manually provided), it performs SQL parsing to extract column-level lineage information. This lineage is then attached to datasets, showing how data flows from source columns to destination columns through SQL transformations.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Fine-grained Lineage"),": Queries can be referenced in fine-grained lineage edges on datasets, providing the SQL context for how specific columns are derived. The query URN is stored in the ",(0,a.yg)("inlineCode",{parentName:"p"},"query")," field of fine-grained lineage information.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Origin Tracking"),": Queries can have an ",(0,a.yg)("inlineCode",{parentName:"p"},"origin")," field pointing to the entity they came from (e.g., a View or Stored Procedure), creating a traceable chain from the query execution back to its source definition."))),(0,a.yg)("h3",{id:"ingestion-sources"},"Ingestion Sources"),(0,a.yg)("p",null,"Several DataHub ingestion connectors automatically discover and create query entities:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"BigQuery"),": Extracts queries from audit logs and information schema"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Snowflake"),": Processes query history from account usage views"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Redshift"),": Reads from system tables like ",(0,a.yg)("inlineCode",{parentName:"li"},"STL_QUERY")," and ",(0,a.yg)("inlineCode",{parentName:"li"},"SVL_QUERY")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"SQL Queries Source"),": A generic connector that can process query logs from any SQL database"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Mode"),": Extracts queries from Mode reports and analyses"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Hex"),": Discovers queries from Hex notebook cells")),(0,a.yg)("p",null,"These connectors typically:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Fetch query logs with SQL statements and metadata"),(0,a.yg)("li",{parentName:"ol"},"Parse the SQL to identify referenced tables"),(0,a.yg)("li",{parentName:"ol"},"Create query entities with appropriate properties and subjects"),(0,a.yg)("li",{parentName:"ol"},"Generate usage statistics as timeseries data"),(0,a.yg)("li",{parentName:"ol"},"Emit column-level lineage derived from SQL parsing")),(0,a.yg)("h3",{id:"graphql-api"},"GraphQL API"),(0,a.yg)("p",null,"Queries can be created, updated, and deleted through the DataHub GraphQL API:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"createQuery"),": Creates a new query with specified properties and subjects"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"updateQuery"),": Updates an existing query's name, description, or statement"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"deleteQuery"),": Soft-deletes a query entity")),(0,a.yg)("p",null,"These mutations are available through the GraphQL endpoint and are used by the DataHub UI for manual query management."),(0,a.yg)("h3",{id:"usage-analytics"},"Usage Analytics"),(0,a.yg)("p",null,"Query entities contribute to dataset usage analytics. When query usage statistics are ingested, they:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Increment the dataset's usage counts"),(0,a.yg)("li",{parentName:"ul"},"Track which users are querying which datasets"),(0,a.yg)("li",{parentName:"ul"},"Provide insights into query patterns and frequency"),(0,a.yg)("li",{parentName:"ul"},"Help identify high-value datasets based on query activity")),(0,a.yg)("h2",{id:"notable-exceptions"},"Notable Exceptions"),(0,a.yg)("h3",{id:"query-deduplication"},"Query Deduplication"),(0,a.yg)("p",null,"Queries are automatically deduplicated based on their normalized query text. This means that:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Whitespace differences are ignored"),(0,a.yg)("li",{parentName:"ul"},"Comments are typically removed during normalization"),(0,a.yg)("li",{parentName:"ul"},"Identical queries from different users or time periods are merged into a single query entity"),(0,a.yg)("li",{parentName:"ul"},"Usage statistics are aggregated across all executions of the same normalized query")),(0,a.yg)("p",null,"This deduplication is essential for managing the volume of queries in large-scale deployments."),(0,a.yg)("h3",{id:"temporary-tables"},"Temporary Tables"),(0,a.yg)("p",null,"When processing queries that involve temporary tables, the SQL parsing aggregator maintains session context to:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Track temporary table creation and usage within a session"),(0,a.yg)("li",{parentName:"ul"},"Resolve lineage through temporary tables to underlying permanent tables"),(0,a.yg)("li",{parentName:"ul"},"Avoid creating query subjects that reference ephemeral temporary tables")),(0,a.yg)("p",null,"This ensures that query lineage reflects the actual data dependencies rather than intermediate temporary structures."),(0,a.yg)("h3",{id:"query-size-limits"},"Query Size Limits"),(0,a.yg)("p",null,"Very large query statements (e.g., generated queries with thousands of lines) may be truncated or rejected to maintain system performance. The exact limits depend on the backend configuration and the storage layer."),(0,a.yg)("h3",{id:"language-support"},"Language Support"),(0,a.yg)("p",null,"Currently, query entities primarily support SQL as the query language. While there is an ",(0,a.yg)("inlineCode",{parentName:"p"},"UNKNOWN")," language option, DataHub's SQL parsing and lineage extraction capabilities are specifically designed for SQL dialects. Other query languages (e.g., Cypher, SPARQL, or proprietary query languages) can be stored but will not benefit from automatic lineage extraction."),(0,a.yg)("h3",{id:"manual-vs-system-queries"},"Manual vs System Queries"),(0,a.yg)("p",null,"Queries can have two sources:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"MANUAL"),": Queries created by users through the DataHub UI or API"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"SYSTEM"),": Queries discovered automatically by ingestion connectors")),(0,a.yg)("p",null,"This distinction helps differentiate between user-curated queries (which might be documented and named) and the potentially large volume of queries automatically discovered from query logs."),(0,a.yg)("h2",{id:"technical-reference-guide"},"Technical Reference Guide"),(0,a.yg)("p",null,"The sections above provide an overview of how to use this entity. The following sections provide detailed technical information about how metadata is stored and represented in DataHub."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Aspects")," are the individual pieces of metadata that can be attached to an entity. Each aspect contains specific information (like ownership, tags, or properties) and is stored as a separate record, allowing for flexible and incremental metadata updates."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Relationships")," show how this entity connects to other entities in the metadata graph. These connections are derived from the fields within each aspect and form the foundation of DataHub's knowledge graph."),(0,a.yg)("h3",{id:"reading-the-field-tables"},"Reading the Field Tables"),(0,a.yg)("p",null,"Each aspect's field table includes an ",(0,a.yg)("strong",{parentName:"p"},"Annotations")," column that provides additional metadata about how fields are used:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"\u26a0\ufe0f Deprecated"),": This field is deprecated and may be removed in a future version. Check the description for the recommended alternative"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Searchable"),": This field is indexed and can be searched in DataHub's search interface"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Searchable (fieldname)"),": When the field name in parentheses is shown, it indicates the field is indexed under a different name in the search index. For example, ",(0,a.yg)("inlineCode",{parentName:"li"},"dashboardTool")," is indexed as ",(0,a.yg)("inlineCode",{parentName:"li"},"tool")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"\u2192 RelationshipName"),": This field creates a relationship to another entity. The arrow indicates this field contains a reference (URN) to another entity, and the name indicates the type of relationship (e.g., ",(0,a.yg)("inlineCode",{parentName:"li"},"\u2192 Contains"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"\u2192 OwnedBy"),")")),(0,a.yg)("p",null,"Fields with complex types (like ",(0,a.yg)("inlineCode",{parentName:"p"},"Edge"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"AuditStamp"),") link to their definitions in the ",(0,a.yg)("a",{parentName:"p",href:"#common-types"},"Common Types")," section below."),(0,a.yg)("h3",{id:"aspects"},"Aspects"),(0,a.yg)("h4",{id:"queryproperties"},"queryProperties"),(0,a.yg)("p",null,"Information about a Query against one or more data assets (e.g. Tables or Views)."),(0,a.yg)(r.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"customProperties"),(0,a.yg)("td",{parentName:"tr",align:null},"map"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Custom property bag."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"statement"),(0,a.yg)("td",{parentName:"tr",align:null},"QueryStatement"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"The Query Statement."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"source"),(0,a.yg)("td",{parentName:"tr",align:null},"QuerySource"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"The source of the Query"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"name"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Optional display name to identify the query."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"description"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"The Query description."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"created"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Audit stamp capturing the time and actor who created the Query."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"lastModified"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Audit stamp capturing the time and actor who last modified the Query."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"origin"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"The origin of the Query. This is the source of the Query (e.g. a View, Stored Procedure, dbt Mode..."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "queryProperties"\n  },\n  "name": "QueryProperties",\n  "namespace": "com.linkedin.query",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "fieldType": "TEXT",\n          "queryByDefault": true\n        }\n      },\n      "type": {\n        "type": "map",\n        "values": "string"\n      },\n      "name": "customProperties",\n      "default": {},\n      "doc": "Custom property bag."\n    },\n    {\n      "type": {\n        "type": "record",\n        "name": "QueryStatement",\n        "namespace": "com.linkedin.query",\n        "fields": [\n          {\n            "type": "string",\n            "name": "value",\n            "doc": "The query text"\n          },\n          {\n            "type": {\n              "type": "enum",\n              "symbolDocs": {\n                "SQL": "A SQL Query",\n                "UNKNOWN": "Unknown query language"\n              },\n              "name": "QueryLanguage",\n              "namespace": "com.linkedin.query",\n              "symbols": [\n                "SQL",\n                "UNKNOWN"\n              ]\n            },\n            "name": "language",\n            "default": "SQL",\n            "doc": "The language of the Query, e.g. SQL."\n          }\n        ],\n        "doc": "A query statement against one or more data assets."\n      },\n      "name": "statement",\n      "doc": "The Query Statement."\n    },\n    {\n      "Searchable": {},\n      "type": {\n        "type": "enum",\n        "symbolDocs": {\n          "MANUAL": "The query was entered manually by a user (via the UI).",\n          "SYSTEM": "The query was discovered by a crawler."\n        },\n        "name": "QuerySource",\n        "namespace": "com.linkedin.query",\n        "symbols": [\n          "MANUAL",\n          "SYSTEM"\n        ]\n      },\n      "name": "source",\n      "doc": "The source of the Query"\n    },\n    {\n      "Searchable": {\n        "boostScore": 10.0,\n        "enableAutocomplete": true,\n        "fieldType": "WORD_GRAM"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "name",\n      "default": null,\n      "doc": "Optional display name to identify the query."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "description",\n      "default": null,\n      "doc": "The Query description."\n    },\n    {\n      "Searchable": {\n        "/actor": {\n          "fieldName": "createdBy",\n          "fieldType": "URN"\n        },\n        "/time": {\n          "fieldName": "createdAt",\n          "fieldType": "DATETIME"\n        }\n      },\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          },\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "message",\n            "default": null,\n            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "created",\n      "doc": "Audit stamp capturing the time and actor who created the Query."\n    },\n    {\n      "Searchable": {\n        "/actor": {\n          "fieldName": "lastModifiedBy",\n          "fieldType": "URN"\n        },\n        "/time": {\n          "fieldName": "lastModifiedAt",\n          "fieldType": "DATETIME"\n        }\n      },\n      "type": "com.linkedin.common.AuditStamp",\n      "name": "lastModified",\n      "doc": "Audit stamp capturing the time and actor who last modified the Query."\n    },\n    {\n      "Searchable": {\n        "addToFilters": false,\n        "fieldType": "URN",\n        "queryByDefault": false\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "origin",\n      "default": null,\n      "doc": "The origin of the Query.\\nThis is the source of the Query (e.g. a View, Stored Procedure, dbt Model, etc.) that the Query was created from."\n    }\n  ],\n  "doc": "Information about a Query against one or more data assets (e.g. Tables or Views)."\n}\n')))),(0,a.yg)("h4",{id:"querysubjects"},"querySubjects"),(0,a.yg)("p",null,"Information about the subjects of a particular Query, i.e. the assets\nbeing queried."),(0,a.yg)(r.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"subjects"),(0,a.yg)("td",{parentName:"tr",align:null},"QuerySubject[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"One or more subjects of the query.  In single-asset queries (e.g. table select), this will contai..."),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "querySubjects"\n  },\n  "name": "QuerySubjects",\n  "namespace": "com.linkedin.query",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "QuerySubject",\n          "namespace": "com.linkedin.query",\n          "fields": [\n            {\n              "Searchable": {\n                "fieldName": "entities",\n                "fieldType": "KEYWORD"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "entity",\n              "doc": "An entity which is the subject of a query."\n            }\n          ],\n          "doc": "A single subject of a particular query.\\nIn the future, we may evolve this model to include richer details\\nabout the Query Subject in relation to the query."\n        }\n      },\n      "name": "subjects",\n      "doc": "One or more subjects of the query.\\n\\nIn single-asset queries (e.g. table select), this will contain the Table reference\\nand optionally schema field references.\\n\\nIn multi-asset queries (e.g. table joins), this may contain multiple Table references\\nand optionally schema field references."\n    }\n  ],\n  "doc": "Information about the subjects of a particular Query, i.e. the assets\\nbeing queried."\n}\n')))),(0,a.yg)("h4",{id:"status"},"status"),(0,a.yg)("p",null,"The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\nThis aspect is used to represent soft deletes conventionally."),(0,a.yg)(r.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"removed"),(0,a.yg)("td",{parentName:"tr",align:null},"boolean"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Whether the entity has been removed (soft-deleted)."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "status"\n  },\n  "name": "Status",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN"\n      },\n      "type": "boolean",\n      "name": "removed",\n      "default": false,\n      "doc": "Whether the entity has been removed (soft-deleted)."\n    }\n  ],\n  "doc": "The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\\nThis aspect is used to represent soft deletes conventionally."\n}\n')))),(0,a.yg)("h4",{id:"dataplatforminstance"},"dataPlatformInstance"),(0,a.yg)("p",null,"The specific instance of the data platform that this entity belongs to"),(0,a.yg)(r.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"platform"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Data Platform"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"instance"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Instance of the data platform (e.g. db instance)"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable (platformInstance)"))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "dataPlatformInstance"\n  },\n  "name": "DataPlatformInstance",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldType": "URN",\n        "filterNameOverride": "Platform"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "platform",\n      "doc": "Data Platform"\n    },\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldName": "platformInstance",\n        "fieldType": "URN",\n        "filterNameOverride": "Platform Instance"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "instance",\n      "default": null,\n      "doc": "Instance of the data platform (e.g. db instance)"\n    }\n  ],\n  "doc": "The specific instance of the data platform that this entity belongs to"\n}\n')))),(0,a.yg)("h4",{id:"subtypes"},"subTypes"),(0,a.yg)("p",null,"Sub Types. Use this aspect to specialize a generic Entity\ne.g. Making a Dataset also be a View or also be a LookerExplore"),(0,a.yg)(r.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"typeNames"),(0,a.yg)("td",{parentName:"tr",align:null},"string[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"The names of the specific types."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "subTypes"\n  },\n  "name": "SubTypes",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "addToFilters": true,\n          "fieldType": "KEYWORD",\n          "filterNameOverride": "Sub Type",\n          "queryByDefault": false\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "typeNames",\n      "doc": "The names of the specific types."\n    }\n  ],\n  "doc": "Sub Types. Use this aspect to specialize a generic Entity\\ne.g. Making a Dataset also be a View or also be a LookerExplore"\n}\n')))),(0,a.yg)("h4",{id:"queryusagestatistics-timeseries"},"queryUsageStatistics (Timeseries)"),(0,a.yg)("p",null,"Stats corresponding to dataset's usage."),(0,a.yg)(r.A,{mdxType:"Tabs"},(0,a.yg)(i.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"timestampMillis"),(0,a.yg)("td",{parentName:"tr",align:null},"long"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"The event timestamp field as epoch at UTC in milli seconds."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"eventGranularity"),(0,a.yg)("td",{parentName:"tr",align:null},"TimeWindowSize"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Granularity of the event if applicable"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"partitionSpec"),(0,a.yg)("td",{parentName:"tr",align:null},"PartitionSpec"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"The optional partition specification."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"messageId"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"The optional messageId, if provided serves as a custom user-defined unique identifier for an aspe..."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"queryCount"),(0,a.yg)("td",{parentName:"tr",align:null},"int"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Total query count in this bucket"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"queryCost"),(0,a.yg)("td",{parentName:"tr",align:null},"double"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Query cost for this query and bucket"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"lastExecutedAt"),(0,a.yg)("td",{parentName:"tr",align:null},"long"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Last executed timestamp"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"uniqueUserCount"),(0,a.yg)("td",{parentName:"tr",align:null},"int"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Unique user count"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"userCounts"),(0,a.yg)("td",{parentName:"tr",align:null},"DatasetUserUsageCounts[]"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Users within this bucket, with frequency counts"),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(i.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "queryUsageStatistics",\n    "type": "timeseries"\n  },\n  "name": "QueryUsageStatistics",\n  "namespace": "com.linkedin.query",\n  "fields": [\n    {\n      "type": "long",\n      "name": "timestampMillis",\n      "doc": "The event timestamp field as epoch at UTC in milli seconds."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "TimeWindowSize",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "CalendarInterval",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "SECOND",\n                  "MINUTE",\n                  "HOUR",\n                  "DAY",\n                  "WEEK",\n                  "MONTH",\n                  "QUARTER",\n                  "YEAR"\n                ]\n              },\n              "name": "unit",\n              "doc": "Interval unit such as minute/hour/day etc."\n            },\n            {\n              "type": "int",\n              "name": "multiple",\n              "default": 1,\n              "doc": "How many units. Defaults to 1."\n            }\n          ],\n          "doc": "Defines the size of a time window."\n        }\n      ],\n      "name": "eventGranularity",\n      "default": null,\n      "doc": "Granularity of the event if applicable"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "PartitionSpec",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "TimeseriesField": {},\n              "type": "string",\n              "name": "partition",\n              "doc": "A unique id / value for the partition for which statistics were collected,\\ngenerated by applying the key definition to a given row."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "TimeWindow",\n                  "namespace": "com.linkedin.timeseries",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "startTimeMillis",\n                      "doc": "Start time as epoch at UTC."\n                    },\n                    {\n                      "type": "com.linkedin.timeseries.TimeWindowSize",\n                      "name": "length",\n                      "doc": "The length of the window."\n                    }\n                  ]\n                }\n              ],\n              "name": "timePartition",\n              "default": null,\n              "doc": "Time window of the partition, if we are able to extract it from the partition key."\n            },\n            {\n              "deprecated": true,\n              "type": {\n                "type": "enum",\n                "name": "PartitionType",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "FULL_TABLE",\n                  "QUERY",\n                  "PARTITION"\n                ]\n              },\n              "name": "type",\n              "default": "PARTITION",\n              "doc": "Unused!"\n            }\n          ],\n          "doc": "A reference to a specific partition in a dataset."\n        },\n        "null"\n      ],\n      "name": "partitionSpec",\n      "default": {\n        "partition": "FULL_TABLE_SNAPSHOT",\n        "type": "FULL_TABLE",\n        "timePartition": null\n      },\n      "doc": "The optional partition specification."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "messageId",\n      "default": null,\n      "doc": "The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "int"\n      ],\n      "name": "queryCount",\n      "default": null,\n      "doc": "Total query count in this bucket"\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "double"\n      ],\n      "name": "queryCost",\n      "default": null,\n      "doc": "Query cost for this query and bucket"\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "lastExecutedAt",\n      "default": null,\n      "doc": "Last executed timestamp"\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "int"\n      ],\n      "name": "uniqueUserCount",\n      "default": null,\n      "doc": "Unique user count"\n    },\n    {\n      "TimeseriesFieldCollection": {\n        "key": "user"\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "DatasetUserUsageCounts",\n            "namespace": "com.linkedin.dataset",\n            "fields": [\n              {\n                "java": {\n                  "class": "com.linkedin.common.urn.Urn"\n                },\n                "type": "string",\n                "name": "user",\n                "doc": "The unique id of the user."\n              },\n              {\n                "TimeseriesField": {},\n                "type": "int",\n                "name": "count",\n                "doc": "Number of times the dataset has been used by the user."\n              },\n              {\n                "TimeseriesField": {},\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "userEmail",\n                "default": null,\n                "doc": "If user_email is set, we attempt to resolve the user\'s urn upon ingest"\n              }\n            ],\n            "doc": "Records a single user\'s usage counts for a given resource"\n          }\n        }\n      ],\n      "name": "userCounts",\n      "default": null,\n      "doc": "Users within this bucket, with frequency counts"\n    }\n  ],\n  "doc": "Stats corresponding to dataset\'s usage."\n}\n')))),(0,a.yg)("h3",{id:"common-types"},"Common Types"),(0,a.yg)("p",null,"These types are used across multiple aspects in this entity."),(0,a.yg)("h4",{id:"auditstamp"},"AuditStamp"),(0,a.yg)("p",null,"Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Fields:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"time")," (long): When did the resource/association/sub-resource move into the specific lifecyc..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"actor")," (string): The entity (e.g. a member URN) which will be credited for moving the resource..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"impersonator")," (string?): The entity (e.g. a service URN) which performs the change on behalf of the Ac..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"message")," (string?): Additional context around how DataHub was informed of the particular change. ...")),(0,a.yg)("h3",{id:"relationships"},"Relationships"),(0,a.yg)("h3",{id:"global-metadata-model"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png"},"Global Metadata Model")),(0,a.yg)("p",null,(0,a.yg)("img",{parentName:"p",src:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png",alt:"Global Graph"})))}h.isMDXComponent=!0}}]);