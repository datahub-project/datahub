"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[52021],{31539:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>p,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>u,toc:()=>m});a(96540);var n=a(15680),r=a(53720),s=a(5400);function i(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function o(t,e){return e=null!=e?e:{},Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):function(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}(Object(e)).forEach((function(a){Object.defineProperty(t,a,Object.getOwnPropertyDescriptor(e,a))})),t}function l(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},s=Object.keys(t);for(n=0;n<s.length;n++)a=s[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(n=0;n<s.length;n++)a=s[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}const c={sidebar_position:37,title:"Data Contract",slug:"/generated/metamodel/entities/datacontract",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/dataContract.md"},d="Data Contract",u={unversionedId:"docs/generated/metamodel/entities/dataContract",id:"docs/generated/metamodel/entities/dataContract",title:"Data Contract",description:"A Data Contract is an agreement between a data asset's producer and consumer that defines expectations and guarantees about the quality, structure, and operational characteristics of data. Data Contracts serve as formal commitments that help establish trust and reliability in data pipelines by making explicit what data consumers can expect from data producers.",source:"@site/genDocs/docs/generated/metamodel/entities/dataContract.md",sourceDirName:"docs/generated/metamodel/entities",slug:"/generated/metamodel/entities/datacontract",permalink:"/docs/generated/metamodel/entities/datacontract",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/dataContract.md",tags:[],version:"current",sidebarPosition:37,frontMatter:{sidebar_position:37,title:"Data Contract",slug:"/generated/metamodel/entities/datacontract",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/dataContract.md"},sidebar:"overviewSidebar",previous:{title:"BusinessAttribute",permalink:"/docs/generated/metamodel/entities/businessattribute"},next:{title:"EntityType",permalink:"/docs/generated/metamodel/entities/entitytype"}},p={},m=[{value:"Identity",id:"identity",level:2},{value:"Important Capabilities",id:"important-capabilities",level:2},{value:"Contract Properties",id:"contract-properties",level:3},{value:"Schema Contracts",id:"schema-contracts",level:3},{value:"Freshness Contracts",id:"freshness-contracts",level:3},{value:"Data Quality Contracts",id:"data-quality-contracts",level:3},{value:"Contract Status",id:"contract-status",level:3},{value:"Tags and Glossary Terms",id:"tags-and-glossary-terms",level:3},{value:"Structured Properties",id:"structured-properties",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"Relationship to Assertions",id:"relationship-to-assertions",level:3},{value:"Relationship to Datasets",id:"relationship-to-datasets",level:3},{value:"Integration with Data Quality Tools",id:"integration-with-data-quality-tools",level:3},{value:"GraphQL API",id:"graphql-api",level:3},{value:"REST API",id:"rest-api",level:3},{value:"Notable Exceptions",id:"notable-exceptions",level:2},{value:"Producer vs Consumer Orientation",id:"producer-vs-consumer-orientation",level:3},{value:"Contract Enforcement",id:"contract-enforcement",level:3},{value:"Assertion Lifecycle",id:"assertion-lifecycle",level:3},{value:"YAML-Based Contract Definitions",id:"yaml-based-contract-definitions",level:3},{value:"Technical Reference Guide",id:"technical-reference-guide",level:2},{value:"Reading the Field Tables",id:"reading-the-field-tables",level:3},{value:"Aspects",id:"aspects",level:3},{value:"dataContractProperties",id:"datacontractproperties",level:4},{value:"dataContractStatus",id:"datacontractstatus",level:4},{value:"status",id:"status",level:4},{value:"structuredProperties",id:"structuredproperties",level:4},{value:"Relationships",id:"relationships",level:3},{value:"Outgoing",id:"outgoing",level:4},{value:"Global Metadata Model",id:"global-metadata-model",level:3}],g={toc:m},y="wrapper";function h(t){var{components:e}=t,a=l(t,["components"]);return(0,n.yg)(y,o(function(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{},n=Object.keys(a);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(a).filter((function(t){return Object.getOwnPropertyDescriptor(a,t).enumerable})))),n.forEach((function(e){i(t,e,a[e])}))}return t}({},g,a),{components:e,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"data-contract"},"Data Contract"),(0,n.yg)("p",null,"A Data Contract is an agreement between a data asset's producer and consumer that defines expectations and guarantees about the quality, structure, and operational characteristics of data. Data Contracts serve as formal commitments that help establish trust and reliability in data pipelines by making explicit what data consumers can expect from data producers."),(0,n.yg)("p",null,"Data Contracts in DataHub are built on top of ",(0,n.yg)("a",{parentName:"p",href:"/docs/generated/metamodel/entities/assertion"},"assertions")," and represent a curated set of verifiable guarantees about a physical data asset. They are producer-oriented, meaning each physical data asset has one contract owned by its producer, which declares the standards and SLAs that consumers can rely on."),(0,n.yg)("h2",{id:"identity"},"Identity"),(0,n.yg)("p",null,"Data Contracts are identified by a single unique string identifier:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"The unique contract id: A string identifier that uniquely identifies the contract. This can be any string value and is often auto-generated based on the entity being contracted.")),(0,n.yg)("p",null,"The URN structure for a Data Contract is: ",(0,n.yg)("inlineCode",{parentName:"p"},"urn:li:dataContract:<contract-id>")),(0,n.yg)("p",null,"Example URNs:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"urn:li:dataContract:my-critical-dataset-contract")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"urn:li:dataContract:a1b2c3d4-e5f6-7890-abcd-ef1234567890"))),(0,n.yg)("p",null,"When creating Data Contracts programmatically, the contract ID can be explicitly specified, or it can be auto-generated based on the entity being contracted. The auto-generation creates a stable, deterministic ID using a GUID derived from the entity URN, ensuring that contracts are reproducible across multiple runs."),(0,n.yg)("h2",{id:"important-capabilities"},"Important Capabilities"),(0,n.yg)("p",null,"Data Contracts provide three main types of guarantees through assertions:"),(0,n.yg)("h3",{id:"contract-properties"},"Contract Properties"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"dataContractProperties")," aspect defines the core characteristics of a contract, including:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Entity Association"),": The URN of the entity (typically a dataset) that this contract applies to. Currently, DataHub supports contracts for datasets, with future support planned for data products and other entity types."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Schema Contracts"),": Assertions that define expectations about the logical schema of the data asset. Schema contracts ensure that the structure of your data remains consistent and matches what consumers expect."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Freshness Contracts"),": Assertions that define operational SLAs for data freshness. These contracts specify how up-to-date the data should be, helping consumers understand the recency guarantees they can rely on."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Data Quality Contracts"),": Assertions that define quality expectations at the table or column level. These include constraints on data completeness, accuracy, validity, and custom quality checks."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Raw Contract"),": An optional YAML-formatted string representation of the contract definition, useful for storing the original contract specification.")),(0,n.yg)("p",null,"Each contract type (schema, freshness, data quality) contains references to assertion entities, which define the actual validation logic and evaluation criteria."),(0,n.yg)("p",null,"The following code snippet shows how to create a basic Data Contract with schema, freshness, and data quality assertions."),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Create a Data Contract"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/datacontract_create_basic.py\n# metadata-ingestion/examples/library/datacontract_create_basic.py\nimport logging\nimport os\n\nfrom datahub.emitter.mce_builder import make_assertion_urn, make_dataset_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    DataContractPropertiesClass,\n    DataContractStateClass,\n    DataContractStatusClass,\n    DataQualityContractClass,\n    FreshnessContractClass,\n    SchemaContractClass,\n    StatusClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\ndataset_urn = make_dataset_urn(platform="snowflake", name="purchases", env="PROD")\n\nschema_assertion_urn = make_assertion_urn("schema-assertion-for-purchases")\nfreshness_assertion_urn = make_assertion_urn("freshness-assertion-for-purchases")\nquality_assertion_urn_1 = make_assertion_urn("quality-assertion-for-purchases-1")\nquality_assertion_urn_2 = make_assertion_urn("quality-assertion-for-purchases-2")\n\ncontract_urn = "urn:li:dataContract:purchases-contract"\n\nproperties_aspect = DataContractPropertiesClass(\n    entity=dataset_urn,\n    schema=[SchemaContractClass(assertion=schema_assertion_urn)],\n    freshness=[FreshnessContractClass(assertion=freshness_assertion_urn)],\n    dataQuality=[\n        DataQualityContractClass(assertion=quality_assertion_urn_1),\n        DataQualityContractClass(assertion=quality_assertion_urn_2),\n    ],\n)\n\nstatus_aspect = StatusClass(removed=False)\n\ncontract_status_aspect = DataContractStatusClass(state=DataContractStateClass.ACTIVE)\n\nrest_emitter = DatahubRestEmitter(\n    gms_server=os.getenv("DATAHUB_GMS_URL", "http://localhost:8080"),\n    token=os.getenv("DATAHUB_GMS_TOKEN"),\n)\n\nfor event in MetadataChangeProposalWrapper.construct_many(\n    entityUrn=contract_urn,\n    aspects=[\n        properties_aspect,\n        status_aspect,\n        contract_status_aspect,\n    ],\n):\n    rest_emitter.emit(event)\n\nlog.info(f"Created data contract {contract_urn}")\n\n'))),(0,n.yg)("h3",{id:"schema-contracts"},"Schema Contracts"),(0,n.yg)("p",null,"Schema contracts ensure that the structure of your data asset matches expectations. They are particularly important for:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Preventing breaking changes in data pipelines"),(0,n.yg)("li",{parentName:"ul"},"Ensuring backward compatibility for downstream consumers"),(0,n.yg)("li",{parentName:"ul"},"Documenting the expected structure of data assets"),(0,n.yg)("li",{parentName:"ul"},"Validating that schema changes are intentional and controlled")),(0,n.yg)("p",null,"A schema contract references a schema assertion entity, which contains the actual schema specification and validation logic. The assertion can be created using DataHub's built-in assertion framework or by integrating with external tools like dbt or Great Expectations."),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Add a schema contract to an existing Data Contract"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/datacontract_add_schema_contract.py\n# metadata-ingestion/examples/library/datacontract_add_schema_contract.py\nimport logging\n\nfrom datahub.emitter.mce_builder import make_assertion_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\nfrom datahub.metadata.schema_classes import (\n    DataContractPropertiesClass,\n    SchemaContractClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\ncontract_urn = "urn:li:dataContract:purchases-contract"\n\ngraph = DataHubGraph(config=DatahubClientConfig(server="http://localhost:8080"))\n\ncontract_properties = graph.get_aspect(\n    entity_urn=contract_urn,\n    aspect_type=DataContractPropertiesClass,\n)\n\nif not contract_properties:\n    log.error(f"Contract {contract_urn} not found")\n    exit(1)\n\nnew_schema_assertion_urn = make_assertion_urn("new-schema-assertion")\n\nexisting_schema = contract_properties.schema or []\nexisting_schema.append(SchemaContractClass(assertion=new_schema_assertion_urn))\n\ncontract_properties.schema = existing_schema\n\nevent = MetadataChangeProposalWrapper(\n    entityUrn=contract_urn,\n    aspect=contract_properties,\n)\n\nrest_emitter = DatahubRestEmitter(gms_server="http://localhost:8080")\nrest_emitter.emit(event)\n\nlog.info(f"Added schema contract to {contract_urn}")\n\n'))),(0,n.yg)("h3",{id:"freshness-contracts"},"Freshness Contracts"),(0,n.yg)("p",null,"Freshness contracts define SLAs for how recent data should be. They help answer questions like:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"How often should this dataset be updated?"),(0,n.yg)("li",{parentName:"ul"},"What is the maximum acceptable data staleness?"),(0,n.yg)("li",{parentName:"ul"},"When can consumers expect new data to arrive?")),(0,n.yg)("p",null,'Freshness contracts are critical for time-sensitive applications where stale data can lead to incorrect decisions or missed opportunities. They typically specify thresholds like "data should be no more than 2 hours old" or "data should be updated at least once per day."'),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Add a freshness contract to an existing Data Contract"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/datacontract_add_freshness_contract.py\n# metadata-ingestion/examples/library/datacontract_add_freshness_contract.py\nimport logging\n\nfrom datahub.emitter.mce_builder import make_assertion_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\nfrom datahub.metadata.schema_classes import (\n    DataContractPropertiesClass,\n    FreshnessContractClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\ncontract_urn = "urn:li:dataContract:purchases-contract"\n\ngraph = DataHubGraph(config=DatahubClientConfig(server="http://localhost:8080"))\n\ncontract_properties = graph.get_aspect(\n    entity_urn=contract_urn,\n    aspect_type=DataContractPropertiesClass,\n)\n\nif not contract_properties:\n    log.error(f"Contract {contract_urn} not found")\n    exit(1)\n\nnew_freshness_assertion_urn = make_assertion_urn("new-freshness-assertion")\n\nexisting_freshness = contract_properties.freshness or []\nexisting_freshness.append(FreshnessContractClass(assertion=new_freshness_assertion_urn))\n\ncontract_properties.freshness = existing_freshness\n\nevent = MetadataChangeProposalWrapper(\n    entityUrn=contract_urn,\n    aspect=contract_properties,\n)\n\nrest_emitter = DatahubRestEmitter(gms_server="http://localhost:8080")\nrest_emitter.emit(event)\n\nlog.info(f"Added freshness contract to {contract_urn}")\n\n'))),(0,n.yg)("h3",{id:"data-quality-contracts"},"Data Quality Contracts"),(0,n.yg)("p",null,"Data quality contracts define expectations about the quality characteristics of your data. These can include:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Completeness"),": No null values in critical columns, or null percentage below a threshold"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Validity"),": Values match expected formats, ranges, or patterns"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Accuracy"),": Values meet business rules and constraints"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Consistency"),": Relationships between columns are maintained"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Custom checks"),": Business-specific validation logic")),(0,n.yg)("p",null,"Unlike schema and freshness contracts (which are typically singular per dataset), a Data Contract can contain multiple data quality assertions, each targeting different aspects of data quality."),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Add data quality contracts to an existing Data Contract"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/datacontract_add_quality_contract.py\n# metadata-ingestion/examples/library/datacontract_add_quality_contract.py\nimport logging\n\nfrom datahub.emitter.mce_builder import make_assertion_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\nfrom datahub.metadata.schema_classes import (\n    DataContractPropertiesClass,\n    DataQualityContractClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\ncontract_urn = "urn:li:dataContract:purchases-contract"\n\ngraph = DataHubGraph(config=DatahubClientConfig(server="http://localhost:8080"))\n\ncontract_properties = graph.get_aspect(\n    entity_urn=contract_urn,\n    aspect_type=DataContractPropertiesClass,\n)\n\nif not contract_properties:\n    log.error(f"Contract {contract_urn} not found")\n    exit(1)\n\nnew_quality_assertion_urn_1 = make_assertion_urn("completeness-check-user-id")\nnew_quality_assertion_urn_2 = make_assertion_urn("validity-check-email-format")\n\nexisting_quality = contract_properties.dataQuality or []\nexisting_quality.extend(\n    [\n        DataQualityContractClass(assertion=new_quality_assertion_urn_1),\n        DataQualityContractClass(assertion=new_quality_assertion_urn_2),\n    ]\n)\n\ncontract_properties.dataQuality = existing_quality\n\nevent = MetadataChangeProposalWrapper(\n    entityUrn=contract_urn,\n    aspect=contract_properties,\n)\n\nrest_emitter = DatahubRestEmitter(gms_server="http://localhost:8080")\nrest_emitter.emit(event)\n\nlog.info(f"Added data quality contracts to {contract_urn}")\n\n'))),(0,n.yg)("h3",{id:"contract-status"},"Contract Status"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"dataContractStatus")," aspect tracks the current state of the contract. A contract can be in one of two states:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"ACTIVE"),": The contract is active and enforced. Violations should trigger alerts or block data pipelines."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"PENDING"),": The contract is pending implementation. It may be used for visibility or planning purposes but is not yet enforced.")),(0,n.yg)("p",null,"The contract status can also include custom properties for additional metadata about the contract's state."),(0,n.yg)("details",null,(0,n.yg)("summary",null,"Python SDK: Update the status of a Data Contract"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/datacontract_update_status.py\n# metadata-ingestion/examples/library/datacontract_update_status.py\nimport logging\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    DataContractStateClass,\n    DataContractStatusClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\ncontract_urn = "urn:li:dataContract:purchases-contract"\n\ncontract_status_aspect = DataContractStatusClass(state=DataContractStateClass.ACTIVE)\n\nevent = MetadataChangeProposalWrapper(\n    entityUrn=contract_urn,\n    aspect=contract_status_aspect,\n)\n\nrest_emitter = DatahubRestEmitter(gms_server="http://localhost:8080")\nrest_emitter.emit(event)\n\nlog.info(f"Updated status of data contract {contract_urn} to ACTIVE")\n\n'))),(0,n.yg)("h3",{id:"tags-and-glossary-terms"},"Tags and Glossary Terms"),(0,n.yg)("p",null,"Like other DataHub entities, Data Contracts can have tags and glossary terms attached to them. These help with:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Categorizing contracts by domain, criticality, or other dimensions"),(0,n.yg)("li",{parentName:"ul"},"Linking contracts to business glossary terms for better understanding"),(0,n.yg)("li",{parentName:"ul"},"Filtering and searching for contracts in the DataHub UI")),(0,n.yg)("p",null,"Tags and terms on Data Contracts follow the same patterns as other entities, using the ",(0,n.yg)("inlineCode",{parentName:"p"},"globalTags")," and ",(0,n.yg)("inlineCode",{parentName:"p"},"glossaryTerms")," aspects."),(0,n.yg)("h3",{id:"structured-properties"},"Structured Properties"),(0,n.yg)("p",null,"Data Contracts support structured properties, which allow you to attach custom, strongly-typed metadata to contracts. This is useful for:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Adding contract-specific metadata like SLA tier, enforcement level, or review status"),(0,n.yg)("li",{parentName:"ul"},"Integrating with external contract management systems"),(0,n.yg)("li",{parentName:"ul"},"Capturing business context and ownership information")),(0,n.yg)("p",null,"Structured properties are defined at the platform level and can be applied to any Data Contract entity."),(0,n.yg)("h2",{id:"integration-points"},"Integration Points"),(0,n.yg)("h3",{id:"relationship-to-assertions"},"Relationship to Assertions"),(0,n.yg)("p",null,"Data Contracts are built on top of the ",(0,n.yg)("a",{parentName:"p",href:"/docs/generated/metamodel/entities/assertion"},"assertion")," entity. Each contract contains references to assertion URNs that define the actual validation logic. This separation allows:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Reusing assertions across multiple contracts"),(0,n.yg)("li",{parentName:"ul"},"Managing assertion logic independently from contract definitions"),(0,n.yg)("li",{parentName:"ul"},"Evaluating assertions outside the context of a contract"),(0,n.yg)("li",{parentName:"ul"},"Tracking assertion results and history")),(0,n.yg)("p",null,"The relationship between contracts and assertions is established through the ",(0,n.yg)("inlineCode",{parentName:"p"},"ContractFor")," relationship (contract to entity) and ",(0,n.yg)("inlineCode",{parentName:"p"},"IncludesSchemaAssertion"),", ",(0,n.yg)("inlineCode",{parentName:"p"},"IncludesFreshnessAssertion"),", and ",(0,n.yg)("inlineCode",{parentName:"p"},"IncludesDataQualityAssertion")," relationships (contract to assertions)."),(0,n.yg)("h3",{id:"relationship-to-datasets"},"Relationship to Datasets"),(0,n.yg)("p",null,"Currently, Data Contracts are primarily associated with ",(0,n.yg)("a",{parentName:"p",href:"/docs/generated/metamodel/entities/dataset"},"dataset")," entities. The ",(0,n.yg)("inlineCode",{parentName:"p"},"dataContractProperties")," aspect includes an ",(0,n.yg)("inlineCode",{parentName:"p"},"entity")," field that references the dataset URN. This relationship is captured using the ",(0,n.yg)("inlineCode",{parentName:"p"},"ContractFor")," relationship type."),(0,n.yg)("p",null,"A dataset can have one active Data Contract at a time, though the contract can be updated or replaced. Consumers can query a dataset to retrieve its associated contract and understand the guarantees they can expect."),(0,n.yg)("h3",{id:"integration-with-data-quality-tools"},"Integration with Data Quality Tools"),(0,n.yg)("p",null,"Data Contracts integrate with external data quality and testing tools:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"dbt Tests"),": dbt test results can be ingested into DataHub as assertions, which can then be referenced in Data Contracts. This allows you to use dbt's testing framework while managing contracts in DataHub."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Great Expectations"),": Great Expectations checkpoints can publish assertion results to DataHub using the DataHubValidationAction, making expectation suites part of your Data Contracts."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Custom Tools"),": Any external system can publish assertion results to DataHub via API, allowing you to build Data Contracts on top of your existing data quality infrastructure.")),(0,n.yg)("h3",{id:"graphql-api"},"GraphQL API"),(0,n.yg)("p",null,"Data Contracts are accessible through DataHub's GraphQL API, which provides:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Upsert Operations"),": Create or update contracts using the ",(0,n.yg)("inlineCode",{parentName:"li"},"upsertDataContract")," mutation"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Query Operations"),": Retrieve contract details, including all associated assertions"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Contract Evaluation"),": Check contract status by evaluating all associated assertions"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Entity Resolution"),": Navigate from datasets to their contracts and vice versa")),(0,n.yg)("p",null,"The GraphQL API is particularly useful for integrating Data Contracts into CI/CD pipelines, custom UIs, or workflow orchestration systems."),(0,n.yg)("h3",{id:"rest-api"},"REST API"),(0,n.yg)("p",null,"Data Contracts can be created, read, updated, and deleted using DataHub's REST API. The standard entity CRUD operations apply:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"POST /entities")," - Create or update a Data Contract entity"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"GET /entities/urn:li:dataContract:<id>")," - Retrieve a Data Contract by URN"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"DELETE /entities/urn:li:dataContract:<id>")," - Remove a Data Contract")),(0,n.yg)("p",null,"Aspects can be individually updated using the aspect-specific endpoints, allowing fine-grained control over contract properties and status."),(0,n.yg)("h2",{id:"notable-exceptions"},"Notable Exceptions"),(0,n.yg)("h3",{id:"producer-vs-consumer-orientation"},"Producer vs Consumer Orientation"),(0,n.yg)("p",null,"DataHub Data Contracts are producer-oriented, meaning each physical data asset has one contract owned by the producer. This design choice keeps contracts manageable and ensures clear ownership."),(0,n.yg)("p",null,"However, this may not fit all use cases. Some organizations prefer consumer-oriented contracts where each consumer defines their own expectations for a shared data asset. While DataHub doesn't directly support consumer-oriented contracts, you can achieve similar functionality by:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Creating multiple assertions on the same dataset with different owners"),(0,n.yg)("li",{parentName:"ul"},"Using tags or structured properties to indicate which consumers care about which assertions"),(0,n.yg)("li",{parentName:"ul"},"Building custom workflows that evaluate subsets of assertions for different consumers")),(0,n.yg)("h3",{id:"contract-enforcement"},"Contract Enforcement"),(0,n.yg)("p",null,"Data Contracts in DataHub define expectations but do not automatically enforce them. Enforcement depends on:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Setting up assertion evaluation (either using DataHub's built-in capabilities or external tools)"),(0,n.yg)("li",{parentName:"ul"},"Configuring alerts and notifications when contracts are violated"),(0,n.yg)("li",{parentName:"ul"},"Integrating contract checks into data pipelines and CI/CD workflows")),(0,n.yg)("p",null,"DataHub provides the framework for defining and tracking contracts, but actual enforcement requires additional integration work specific to your data infrastructure."),(0,n.yg)("h3",{id:"assertion-lifecycle"},"Assertion Lifecycle"),(0,n.yg)("p",null,"When you delete a Data Contract, the associated assertions are not automatically deleted. This is by design - assertions can exist independently and may be used by other contracts or monitored separately."),(0,n.yg)("p",null,"If you want to remove both a contract and its assertions, you must delete them separately. This ensures that assertion definitions and their historical results are preserved even when contracts change."),(0,n.yg)("h3",{id:"yaml-based-contract-definitions"},"YAML-Based Contract Definitions"),(0,n.yg)("p",null,"DataHub supports defining Data Contracts in YAML files using the ",(0,n.yg)("inlineCode",{parentName:"p"},"DataContract")," Python model. This provides a simpler, declarative way to define contracts that can be version-controlled and reviewed like code."),(0,n.yg)("p",null,"The YAML format is particularly useful for:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Defining contracts as part of infrastructure-as-code workflows"),(0,n.yg)("li",{parentName:"ul"},"Storing contract definitions alongside dbt models or other data pipeline code"),(0,n.yg)("li",{parentName:"ul"},"Reviewing contract changes through standard code review processes")),(0,n.yg)("p",null,"However, YAML-based contracts are converted to the underlying MCP (Metadata Change Proposal) format when ingested, so all operations ultimately use the same underlying entity and aspect structure."),(0,n.yg)("h2",{id:"technical-reference-guide"},"Technical Reference Guide"),(0,n.yg)("p",null,"The sections above provide an overview of how to use this entity. The following sections provide detailed technical information about how metadata is stored and represented in DataHub."),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Aspects")," are the individual pieces of metadata that can be attached to an entity. Each aspect contains specific information (like ownership, tags, or properties) and is stored as a separate record, allowing for flexible and incremental metadata updates."),(0,n.yg)("p",null,(0,n.yg)("strong",{parentName:"p"},"Relationships")," show how this entity connects to other entities in the metadata graph. These connections are derived from the fields within each aspect and form the foundation of DataHub's knowledge graph."),(0,n.yg)("h3",{id:"reading-the-field-tables"},"Reading the Field Tables"),(0,n.yg)("p",null,"Each aspect's field table includes an ",(0,n.yg)("strong",{parentName:"p"},"Annotations")," column that provides additional metadata about how fields are used:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"\u26a0\ufe0f Deprecated"),": This field is deprecated and may be removed in a future version. Check the description for the recommended alternative"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Searchable"),": This field is indexed and can be searched in DataHub's search interface"),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"Searchable (fieldname)"),": When the field name in parentheses is shown, it indicates the field is indexed under a different name in the search index. For example, ",(0,n.yg)("inlineCode",{parentName:"li"},"dashboardTool")," is indexed as ",(0,n.yg)("inlineCode",{parentName:"li"},"tool")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"\u2192 RelationshipName"),": This field creates a relationship to another entity. The arrow indicates this field contains a reference (URN) to another entity, and the name indicates the type of relationship (e.g., ",(0,n.yg)("inlineCode",{parentName:"li"},"\u2192 Contains"),", ",(0,n.yg)("inlineCode",{parentName:"li"},"\u2192 OwnedBy"),")")),(0,n.yg)("p",null,"Fields with complex types (like ",(0,n.yg)("inlineCode",{parentName:"p"},"Edge"),", ",(0,n.yg)("inlineCode",{parentName:"p"},"AuditStamp"),") link to their definitions in the ",(0,n.yg)("a",{parentName:"p",href:"#common-types"},"Common Types")," section below."),(0,n.yg)("h3",{id:"aspects"},"Aspects"),(0,n.yg)("h4",{id:"datacontractproperties"},"dataContractProperties"),(0,n.yg)("p",null,"Information about a data contract"),(0,n.yg)(r.A,{mdxType:"Tabs"},(0,n.yg)(s.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Field"),(0,n.yg)("th",{parentName:"tr",align:null},"Type"),(0,n.yg)("th",{parentName:"tr",align:null},"Required"),(0,n.yg)("th",{parentName:"tr",align:null},"Description"),(0,n.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"entity"),(0,n.yg)("td",{parentName:"tr",align:null},"string"),(0,n.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,n.yg)("td",{parentName:"tr",align:null},"The entity that this contract is associated with. Currently, we only support Dataset contracts, b..."),(0,n.yg)("td",{parentName:"tr",align:null},"\u2192 ContractFor")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"schema"),(0,n.yg)("td",{parentName:"tr",align:null},"SchemaContract[]"),(0,n.yg)("td",{parentName:"tr",align:null}),(0,n.yg)("td",{parentName:"tr",align:null},"An optional set of schema contracts. If this is a dataset contract, there will only be one."),(0,n.yg)("td",{parentName:"tr",align:null},"\u2192 IncludesSchemaAssertion")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"freshness"),(0,n.yg)("td",{parentName:"tr",align:null},"FreshnessContract[]"),(0,n.yg)("td",{parentName:"tr",align:null}),(0,n.yg)("td",{parentName:"tr",align:null},"An optional set of FRESHNESS contracts. If this is a dataset contract, there will only be one."),(0,n.yg)("td",{parentName:"tr",align:null},"\u2192 IncludesFreshnessAssertion")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"dataQuality"),(0,n.yg)("td",{parentName:"tr",align:null},"DataQualityContract[]"),(0,n.yg)("td",{parentName:"tr",align:null}),(0,n.yg)("td",{parentName:"tr",align:null},"An optional set of Data Quality contracts, e.g. table and column level contract constraints."),(0,n.yg)("td",{parentName:"tr",align:null},"\u2192 IncludesDataQualityAssertion")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"rawContract"),(0,n.yg)("td",{parentName:"tr",align:null},"string"),(0,n.yg)("td",{parentName:"tr",align:null}),(0,n.yg)("td",{parentName:"tr",align:null},"YAML-formatted contract definition"),(0,n.yg)("td",{parentName:"tr",align:null}))))),(0,n.yg)(s.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "dataContractProperties"\n  },\n  "name": "DataContractProperties",\n  "namespace": "com.linkedin.datacontract",\n  "fields": [\n    {\n      "Relationship": {\n        "entityTypes": [\n          "dataset"\n        ],\n        "name": "ContractFor"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "entity",\n      "doc": "The entity that this contract is associated with. Currently, we only support Dataset contracts, but\\nin the future we may also support Data Product level contracts."\n    },\n    {\n      "Relationship": {\n        "/*/assertion": {\n          "entityTypes": [\n            "assertion"\n          ],\n          "name": "IncludesSchemaAssertion"\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "SchemaContract",\n            "namespace": "com.linkedin.datacontract",\n            "fields": [\n              {\n                "Relationship": {\n                  "entityTypes": [\n                    "assertion"\n                  ],\n                  "name": "IncludesSchemaAssertion"\n                },\n                "java": {\n                  "class": "com.linkedin.common.urn.Urn"\n                },\n                "type": "string",\n                "name": "assertion",\n                "doc": "The assertion representing the schema contract."\n              }\n            ],\n            "doc": "Expectations for a logical schema"\n          }\n        }\n      ],\n      "name": "schema",\n      "default": null,\n      "doc": "An optional set of schema contracts. If this is a dataset contract, there will only be one."\n    },\n    {\n      "Relationship": {\n        "/*/assertion": {\n          "entityTypes": [\n            "assertion"\n          ],\n          "name": "IncludesFreshnessAssertion"\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "FreshnessContract",\n            "namespace": "com.linkedin.datacontract",\n            "fields": [\n              {\n                "java": {\n                  "class": "com.linkedin.common.urn.Urn"\n                },\n                "type": "string",\n                "name": "assertion",\n                "doc": "The assertion representing the SLA contract."\n              }\n            ],\n            "doc": "A contract pertaining to the operational SLAs of a physical data asset"\n          }\n        }\n      ],\n      "name": "freshness",\n      "default": null,\n      "doc": "An optional set of FRESHNESS contracts. If this is a dataset contract, there will only be one."\n    },\n    {\n      "Relationship": {\n        "/*/assertion": {\n          "entityTypes": [\n            "assertion"\n          ],\n          "name": "IncludesDataQualityAssertion"\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "DataQualityContract",\n            "namespace": "com.linkedin.datacontract",\n            "fields": [\n              {\n                "Relationship": {\n                  "entityTypes": [\n                    "assertion"\n                  ],\n                  "name": "IncludesDataQualityAssertion"\n                },\n                "java": {\n                  "class": "com.linkedin.common.urn.Urn"\n                },\n                "type": "string",\n                "name": "assertion",\n                "doc": "The assertion representing the Data Quality contract.\\nE.g. a table or column-level assertion."\n              }\n            ],\n            "doc": "A data quality contract pertaining to a physical data asset\\nData Quality contracts are used to make assertions about data quality metrics for a physical data asset"\n          }\n        }\n      ],\n      "name": "dataQuality",\n      "default": null,\n      "doc": "An optional set of Data Quality contracts, e.g. table and column level contract constraints."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "rawContract",\n      "default": null,\n      "doc": "YAML-formatted contract definition"\n    }\n  ],\n  "doc": "Information about a data contract"\n}\n')))),(0,n.yg)("h4",{id:"datacontractstatus"},"dataContractStatus"),(0,n.yg)("p",null,"Information about the status of a data contract"),(0,n.yg)(r.A,{mdxType:"Tabs"},(0,n.yg)(s.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Field"),(0,n.yg)("th",{parentName:"tr",align:null},"Type"),(0,n.yg)("th",{parentName:"tr",align:null},"Required"),(0,n.yg)("th",{parentName:"tr",align:null},"Description"),(0,n.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"customProperties"),(0,n.yg)("td",{parentName:"tr",align:null},"map"),(0,n.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,n.yg)("td",{parentName:"tr",align:null},"Custom property bag."),(0,n.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"state"),(0,n.yg)("td",{parentName:"tr",align:null},"DataContractState"),(0,n.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,n.yg)("td",{parentName:"tr",align:null},"The latest state of the data contract"),(0,n.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,n.yg)(s.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "dataContractStatus"\n  },\n  "name": "DataContractStatus",\n  "namespace": "com.linkedin.datacontract",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "fieldType": "TEXT",\n          "queryByDefault": true\n        }\n      },\n      "type": {\n        "type": "map",\n        "values": "string"\n      },\n      "name": "customProperties",\n      "default": {},\n      "doc": "Custom property bag."\n    },\n    {\n      "Searchable": {},\n      "type": {\n        "type": "enum",\n        "symbolDocs": {\n          "ACTIVE": "The data contract is active.",\n          "PENDING": "The data contract is pending implementation."\n        },\n        "name": "DataContractState",\n        "namespace": "com.linkedin.datacontract",\n        "symbols": [\n          "ACTIVE",\n          "PENDING"\n        ]\n      },\n      "name": "state",\n      "doc": "The latest state of the data contract"\n    }\n  ],\n  "doc": "Information about the status of a data contract"\n}\n')))),(0,n.yg)("h4",{id:"status"},"status"),(0,n.yg)("p",null,"The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\nThis aspect is used to represent soft deletes conventionally."),(0,n.yg)(r.A,{mdxType:"Tabs"},(0,n.yg)(s.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Field"),(0,n.yg)("th",{parentName:"tr",align:null},"Type"),(0,n.yg)("th",{parentName:"tr",align:null},"Required"),(0,n.yg)("th",{parentName:"tr",align:null},"Description"),(0,n.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"removed"),(0,n.yg)("td",{parentName:"tr",align:null},"boolean"),(0,n.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,n.yg)("td",{parentName:"tr",align:null},"Whether the entity has been removed (soft-deleted)."),(0,n.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,n.yg)(s.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "status"\n  },\n  "name": "Status",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN"\n      },\n      "type": "boolean",\n      "name": "removed",\n      "default": false,\n      "doc": "Whether the entity has been removed (soft-deleted)."\n    }\n  ],\n  "doc": "The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\\nThis aspect is used to represent soft deletes conventionally."\n}\n')))),(0,n.yg)("h4",{id:"structuredproperties"},"structuredProperties"),(0,n.yg)("p",null,"Properties about an entity governed by StructuredPropertyDefinition"),(0,n.yg)(r.A,{mdxType:"Tabs"},(0,n.yg)(s.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Field"),(0,n.yg)("th",{parentName:"tr",align:null},"Type"),(0,n.yg)("th",{parentName:"tr",align:null},"Required"),(0,n.yg)("th",{parentName:"tr",align:null},"Description"),(0,n.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"properties"),(0,n.yg)("td",{parentName:"tr",align:null},"StructuredPropertyValueAssignment[]"),(0,n.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,n.yg)("td",{parentName:"tr",align:null},"Custom property bag."),(0,n.yg)("td",{parentName:"tr",align:null}))))),(0,n.yg)(s.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "structuredProperties"\n  },\n  "name": "StructuredProperties",\n  "namespace": "com.linkedin.structured",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "StructuredPropertyValueAssignment",\n          "namespace": "com.linkedin.structured",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "propertyUrn",\n              "doc": "The property that is being assigned a value."\n            },\n            {\n              "type": {\n                "type": "array",\n                "items": [\n                  "string",\n                  "double"\n                ]\n              },\n              "name": "values",\n              "doc": "The value assigned to the property."\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "AuditStamp",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "impersonator",\n                      "default": null,\n                      "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "message",\n                      "default": null,\n                      "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                    }\n                  ],\n                  "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n                }\n              ],\n              "name": "created",\n              "default": null,\n              "doc": "Audit stamp containing who created this relationship edge and when"\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "lastModified",\n              "default": null,\n              "doc": "Audit stamp containing who last modified this relationship edge and when"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "structuredPropertyAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "structuredPropertyAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "structuredPropertyAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ]\n        }\n      },\n      "name": "properties",\n      "doc": "Custom property bag."\n    }\n  ],\n  "doc": "Properties about an entity governed by StructuredPropertyDefinition"\n}\n')))),(0,n.yg)("h3",{id:"relationships"},"Relationships"),(0,n.yg)("h4",{id:"outgoing"},"Outgoing"),(0,n.yg)("p",null,"These are the relationships stored in this entity's aspects"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"ContractFor"),(0,n.yg)("ul",{parentName:"li"},(0,n.yg)("li",{parentName:"ul"},"Dataset via ",(0,n.yg)("inlineCode",{parentName:"li"},"dataContractProperties.entity")))),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"IncludesSchemaAssertion"),(0,n.yg)("ul",{parentName:"li"},(0,n.yg)("li",{parentName:"ul"},"Assertion via ",(0,n.yg)("inlineCode",{parentName:"li"},"dataContractProperties.schema")),(0,n.yg)("li",{parentName:"ul"},"Assertion via ",(0,n.yg)("inlineCode",{parentName:"li"},"dataContractProperties.schema.assertion")))),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"IncludesFreshnessAssertion"),(0,n.yg)("ul",{parentName:"li"},(0,n.yg)("li",{parentName:"ul"},"Assertion via ",(0,n.yg)("inlineCode",{parentName:"li"},"dataContractProperties.freshness")))),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"IncludesDataQualityAssertion"),(0,n.yg)("ul",{parentName:"li"},(0,n.yg)("li",{parentName:"ul"},"Assertion via ",(0,n.yg)("inlineCode",{parentName:"li"},"dataContractProperties.dataQuality")),(0,n.yg)("li",{parentName:"ul"},"Assertion via ",(0,n.yg)("inlineCode",{parentName:"li"},"dataContractProperties.dataQuality.assertion"))))),(0,n.yg)("h3",{id:"global-metadata-model"},(0,n.yg)("a",{parentName:"h3",href:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png"},"Global Metadata Model")),(0,n.yg)("p",null,(0,n.yg)("img",{parentName:"p",src:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png",alt:"Global Graph"})))}h.isMDXComponent=!0}}]);