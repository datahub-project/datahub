"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[32585],{15680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>m});var a=n(96540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(n),d=i,m=c["".concat(s,".").concat(d)]||c[d]||g[d]||r;return n?a.createElement(m,l(l({ref:t},p),{},{components:n})):a.createElement(m,l({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var u=2;u<r;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},72887:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>u,toc:()=>c});n(96540);var a=n(15680);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}const o={title:"SQL Parsing",sidebar_label:"SQL Parsing",slug:"/lineage/sql_parsing",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/lineage/sql_parsing.md"},s="The DataHub SQL Parser",u={unversionedId:"docs/lineage/sql_parsing",id:"version-1.1.0/docs/lineage/sql_parsing",title:"SQL Parsing",description:"Many data platforms are built on top of SQL, which means deeply understanding SQL queries is critical for understanding column-level lineage, usage, and more.",source:"@site/versioned_docs/version-1.1.0/docs/lineage/sql_parsing.md",sourceDirName:"docs/lineage",slug:"/lineage/sql_parsing",permalink:"/docs/1.1.0/lineage/sql_parsing",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/lineage/sql_parsing.md",tags:[],version:"1.1.0",frontMatter:{title:"SQL Parsing",sidebar_label:"SQL Parsing",slug:"/lineage/sql_parsing",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/lineage/sql_parsing.md"},sidebar:"overviewSidebar",previous:{title:"Working With Platform Instances",permalink:"/docs/1.1.0/platform-instances"},next:{title:"Stateful Ingestion",permalink:"/docs/1.1.0/metadata-ingestion/docs/dev_guides/stateful"}},p={},c=[{value:"Built-in SQL Parsing Support",id:"built-in-sql-parsing-support",level:2},{value:"SDK Support",id:"sdk-support",level:2},{value:"Capabilities",id:"capabilities",level:2},{value:"Supported",id:"supported",level:3},{value:"Not supported",id:"not-supported",level:3},{value:"Limitations",id:"limitations",level:3}],g={toc:c},d="wrapper";function m(e){var{components:t}=e,n=l(e,["components"]);return(0,a.yg)(d,r(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){i(e,t,n[t])}))}return e}({},g,n),{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"the-datahub-sql-parser"},"The DataHub SQL Parser"),(0,a.yg)("p",null,"Many data platforms are built on top of SQL, which means deeply understanding SQL queries is critical for understanding column-level lineage, usage, and more."),(0,a.yg)("p",null,"DataHub's SQL parser is built on top of ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/tobymao/sqlglot"},"sqlglot")," and adds a number of additional features to improve the accuracy of SQL parsing."),(0,a.yg)("p",null,"In our benchmarks, the DataHub SQL parser generates lineage with 97-99% accuracy and outperforms other SQL parsers by a wide margin."),(0,a.yg)("p",null,"We've published a blog post on some of the technical details of the parser: ",(0,a.yg)("a",{parentName:"p",href:"https://medium.com/datahub-project/extracting-column-level-lineage-from-sql-779b8ce17567"},"Extracting Column Lineage from SQL Queries"),"."),(0,a.yg)("h2",{id:"built-in-sql-parsing-support"},"Built-in SQL Parsing Support"),(0,a.yg)("p",null,"If you're using a tool that DataHub already ",(0,a.yg)("a",{parentName:"p",href:"/integrations"},"integrates with"),", check the documentation for that specific integration.\nMost of our integrations, including Snowflake, BigQuery, Redshift, dbt, Looker, PowerBI, Airflow, etc, use the SQL parser to generate column-level lineage and usage statistics."),(0,a.yg)("p",null,"If you\u2019re using a different database system for which we don\u2019t support column-level lineage out of the box, but you do have a database query log available, the ",(0,a.yg)("a",{parentName:"p",href:"/docs/1.1.0/generated/ingestion/sources/sql-queries"},"SQL queries")," connector can generate column-level lineage and table/column usage statistics from the query log."),(0,a.yg)("h2",{id:"sdk-support"},"SDK Support"),(0,a.yg)("p",null,"Our SDK provides a ",(0,a.yg)("a",{parentName:"p",href:"/docs/1.1.0/python-sdk/clients#datahub.ingestion.graph.client.DataHubGraph.parse_sql_lineage"},(0,a.yg)("inlineCode",{parentName:"a"},"DataHubGraph.parse_sql_lineage()"))," method for programmatically parsing SQL queries."),(0,a.yg)("p",null,"The resulting object contains a ",(0,a.yg)("inlineCode",{parentName:"p"},"sql_parsing_result.debug_info.confidence_score")," field, which is a 0-1 value indicating the confidence of the parser."),(0,a.yg)("p",null,"There are also a number of utilities in the ",(0,a.yg)("inlineCode",{parentName:"p"},"datahub.sql_parsing")," module. The ",(0,a.yg)("inlineCode",{parentName:"p"},"SqlParsingAggregator")," is particularly useful, as it can also resolve lineage across temp tables and table renames/swaps.\nNote that these utilities are not officially part of the DataHub SDK and hence do not have the same level of stability and support as the rest of the SDK."),(0,a.yg)("h2",{id:"capabilities"},"Capabilities"),(0,a.yg)("h3",{id:"supported"},"Supported"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Table-level lineage for ",(0,a.yg)("inlineCode",{parentName:"li"},"SELECT"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"CREATE"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"INSERT"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"UPDATE"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"DELETE"),", and ",(0,a.yg)("inlineCode",{parentName:"li"},"MERGE")," statements"),(0,a.yg)("li",{parentName:"ul"},"Column-level lineage for ",(0,a.yg)("inlineCode",{parentName:"li"},"SELECT")," (including ",(0,a.yg)("inlineCode",{parentName:"li"},"SELECT INTO"),"), ",(0,a.yg)("inlineCode",{parentName:"li"},"CREATE VIEW"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"CREATE TABLE AS SELECT")," (CTAS), ",(0,a.yg)("inlineCode",{parentName:"li"},"INSERT"),", and ",(0,a.yg)("inlineCode",{parentName:"li"},"UPDATE")," statements"),(0,a.yg)("li",{parentName:"ul"},"Subqueries"),(0,a.yg)("li",{parentName:"ul"},"CTEs"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"UNION ALL")," constructs - will merge lineage across the clauses of the ",(0,a.yg)("inlineCode",{parentName:"li"},"UNION")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"SELECT *")," and similar expressions will automatically be expanded with the table schemas registered in DataHub. This includes support for platform instances."),(0,a.yg)("li",{parentName:"ul"},"Automatic handling for systems where table and column names are case insensitive. Generally requires that ",(0,a.yg)("inlineCode",{parentName:"li"},"convert_urns_to_lowercase")," is enabled when the corresponding table schemas were ingested into DataHub.",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Specifically, we'll do fuzzy matching against the table names and schemas to resolve the correct URNs. We do not support having multiple tables/columns that only differ in casing."))),(0,a.yg)("li",{parentName:"ul"},"For BigQuery, sharded table suffixes will automatically be normalized. For example, ",(0,a.yg)("inlineCode",{parentName:"li"},"proj.dataset.table_20230616")," will be normalized to ",(0,a.yg)("inlineCode",{parentName:"li"},"proj.dataset.table_yyyymmdd"),". This matches the behavior of our BigQuery ingestion connector, and hence will result in lineage linking up correctly.")),(0,a.yg)("h3",{id:"not-supported"},"Not supported"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Scalar ",(0,a.yg)("inlineCode",{parentName:"li"},"UDFs")," - We will generate lineage pointing at the columns that are inputs to the UDF, but will not be able to understand the UDF itself."),(0,a.yg)("li",{parentName:"ul"},"Table-valued functions, including tabular ",(0,a.yg)("inlineCode",{parentName:"li"},"UDFs")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"json_extract")," and similar functions"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"UNNEST")," - We will do a best-effort job, but cannot reliably generate column-level lineage in the presence of ",(0,a.yg)("inlineCode",{parentName:"li"},"UNNEST")," constructs."),(0,a.yg)("li",{parentName:"ul"},"Structs - We will do a best-effort attempt to resolve struct subfields, but it is not guaranteed. This will only impact column-level lineage.",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"This extends to things like dynamic table unpacking e.g. ",(0,a.yg)("inlineCode",{parentName:"li"},"SELECT IF (main.id is not null, main, extras).* FROM my_schema.main_users main FULL JOIN my_schema.external_users extras USING (id)")," in BigQuery."))),(0,a.yg)("li",{parentName:"ul"},"Snowflake's multi-table inserts"),(0,a.yg)("li",{parentName:"ul"},"Multi-statement SQL / SQL scripting")),(0,a.yg)("h3",{id:"limitations"},"Limitations"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"We only support the 20+ SQL dialects supported by the underlying ",(0,a.yg)("a",{parentName:"li",href:"https://github.com/tobymao/sqlglot"},"sqlglot")," library."),(0,a.yg)("li",{parentName:"ul"},"There's a few SQL syntaxes that we don't support yet, but intend to support in the future.",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"INSERT INTO (col1_new, col2_new) SELECT col1_old, col2_old FROM ..."),". We only support ",(0,a.yg)("inlineCode",{parentName:"li"},"INSERT INTO")," statements that either (1) don't specify a column list, or (2) specify a column list that matches the columns in the ",(0,a.yg)("inlineCode",{parentName:"li"},"SELECT")," clause."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"MERGE INTO")," statements - We don't generate column-level lineage for these."))),(0,a.yg)("li",{parentName:"ul"},"In cases where the table schema information in DataHub is outdated or otherwise incorrect, we may not be able to generate accurate column-level lineage."),(0,a.yg)("li",{parentName:"ul"},"We sometimes trip over BigQuery queries that use the ",(0,a.yg)("inlineCode",{parentName:"li"},"_partitiontime")," and ",(0,a.yg)("inlineCode",{parentName:"li"},"_partitiondate")," pseudo-columns with a table name prefix e.g. ",(0,a.yg)("inlineCode",{parentName:"li"},"my_table._partitiontime")," fails. However, unqualified references like ",(0,a.yg)("inlineCode",{parentName:"li"},"_partitiontime")," and ",(0,a.yg)("inlineCode",{parentName:"li"},"_partitiondate")," will be fine."),(0,a.yg)("li",{parentName:"ul"},"We do not consider columns referenced in filtering or organizational clauses such as ",(0,a.yg)("inlineCode",{parentName:"li"},"WHERE"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"GROUP BY"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"ORDER BY"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"JOIN"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"HAVING"),", or ",(0,a.yg)("inlineCode",{parentName:"li"},"PARTITION BY")," to be part of lineage. For example, ",(0,a.yg)("inlineCode",{parentName:"li"},"SELECT col1, col2 FROM upstream_table WHERE col3 = 3")," will not generate any lineage related to ",(0,a.yg)("inlineCode",{parentName:"li"},"col3"),"."),(0,a.yg)("li",{parentName:"ul"},"We generally only analyze static table references. For example, this Snowflake query will not generate any lineage: ",(0,a.yg)("inlineCode",{parentName:"li"},"SELECT * FROM identifier('my_db.my_schema.my_table')"),", since the ",(0,a.yg)("inlineCode",{parentName:"li"},"identifier")," function is resolved at SQL runtime.")))}m.isMDXComponent=!0}}]);