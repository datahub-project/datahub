"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[10098],{15680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>y});var a=n(96540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(n),g=i,y=h["".concat(l,".").concat(g)]||h[g]||p[g]||r;return n?a.createElement(y,o(o({ref:t},u),{},{components:n})):a.createElement(y,o({ref:t},u))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},20858:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>y,frontMatter:()=>s,metadata:()=>c,toc:()=>h});n(96540);var a=n(15680);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}const s={title:"Concepts & Key Components",slug:"/authentication/concepts",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/authentication/concepts.md"},l="Concepts & Key Components",c={unversionedId:"docs/authentication/concepts",id:"docs/authentication/concepts",title:"Concepts & Key Components",description:"We introduced a few important concepts to the Metadata Service to make authentication work:",source:"@site/genDocs/docs/authentication/concepts.md",sourceDirName:"docs/authentication",slug:"/authentication/concepts",permalink:"/docs/authentication/concepts",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/authentication/concepts.md",tags:[],version:"current",frontMatter:{title:"Concepts & Key Components",slug:"/authentication/concepts",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/authentication/concepts.md"},sidebar:"overviewSidebar",previous:{title:"DataHub Authentication Overview",permalink:"/docs/authentication"},next:{title:"Changing the default user credentials",permalink:"/docs/authentication/changing-default-credentials"}},u={},h=[{value:"What is an Actor?",id:"what-is-an-actor",level:2},{value:"What is an Authenticator?",id:"what-is-an-authenticator",level:2},{value:"What is an AuthenticatorChain?",id:"what-is-an-authenticatorchain",level:2},{value:"What is the Two-Tier Authentication System?",id:"what-is-the-two-tier-authentication-system",level:2},{value:"Tier 1: Authentication Extraction",id:"tier-1-authentication-extraction",level:3},{value:"Tier 2: Authentication Enforcement",id:"tier-2-authentication-enforcement",level:3},{value:"AuthenticationEnforcementFilter",id:"authenticationenforcementfilter",level:4},{value:"Additional Enforcement Options",id:"additional-enforcement-options",level:4},{value:"Benefits of Two-Tier Architecture",id:"benefits-of-two-tier-architecture",level:3},{value:"What is AuthenticationContext?",id:"what-is-authenticationcontext",level:2},{value:"What is a DataHub Token Service? What are Access Tokens?",id:"what-is-a-datahub-token-service-what-are-access-tokens",level:2},{value:"How do I enable Guest Authentication",id:"how-do-i-enable-guest-authentication",level:2}],p={toc:h},g="wrapper";function y(e){var{components:t}=e,n=o(e,["components"]);return(0,a.yg)(g,r(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){i(e,t,n[t])}))}return e}({},p,n),{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"concepts--key-components"},"Concepts & Key Components"),(0,a.yg)("p",null,"We introduced a few important concepts to the Metadata Service to make authentication work:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Actor"),(0,a.yg)("li",{parentName:"ol"},"Authenticator"),(0,a.yg)("li",{parentName:"ol"},"AuthenticatorChain"),(0,a.yg)("li",{parentName:"ol"},"Two-Tier Authentication System"),(0,a.yg)("li",{parentName:"ol"},"AuthenticationContext"),(0,a.yg)("li",{parentName:"ol"},"DataHub Access Token"),(0,a.yg)("li",{parentName:"ol"},"DataHub Token Service")),(0,a.yg)("p",null,"In following sections, we'll take a closer look at each individually."),(0,a.yg)("p",{align:"center"},(0,a.yg)("img",{width:"70%",src:"https://raw.githubusercontent.com/datahub-project/static-assets/main/imgs/metadata-service-auth.png"})),(0,a.yg)("p",null,(0,a.yg)("em",{parentName:"p"},"High level overview of Metadata Service Authentication")),(0,a.yg)("h2",{id:"what-is-an-actor"},"What is an Actor?"),(0,a.yg)("p",null,"An ",(0,a.yg)("strong",{parentName:"p"},"Actor")," is a concept within the new Authentication subsystem to represent a unique identity / principal that is initiating actions (e.g. read & write requests)\non the platform."),(0,a.yg)("p",null,"An actor can be characterized by 2 attributes:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Type"),': The "type" of the actor making a request. The purpose is to for example distinguish between a "user" & "service" actor. Currently, the "user" actor type is the only one\nformally supported.'),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Id"),': A unique identifier for the actor within DataHub. This is commonly known as a "principal" in other systems. In the case of users, this\nrepresents a unique "username". This username is in turn used when converting from the "Actor" concept into a Metadata Entity Urn (e.g. CorpUserUrn).')),(0,a.yg)("p",null,'For example, the root "datahub" super user would have the following attributes:'),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'{\n   "type": "USER",\n   "id": "datahub"\n}\n')),(0,a.yg)("p",null,"Which is mapped to the CorpUser urn:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"urn:li:corpuser:datahub\n")),(0,a.yg)("p",null,"for Metadata retrieval."),(0,a.yg)("h2",{id:"what-is-an-authenticator"},"What is an Authenticator?"),(0,a.yg)("p",null,"An ",(0,a.yg)("strong",{parentName:"p"},"Authenticator")," is a pluggable component inside the Metadata Service that is responsible for authenticating an inbound request provided context about the request (currently, the request headers).\nAuthentication boils down to successfully resolving an ",(0,a.yg)("strong",{parentName:"p"},"Actor")," to associate with the inbound request."),(0,a.yg)("p",null,"There can be many types of Authenticator. For example, there can be Authenticators that"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Verify the authenticity of access tokens (ie. issued by either DataHub itself or a 3rd-party IdP)"),(0,a.yg)("li",{parentName:"ul"},"Authenticate username / password credentials against a remote database (ie. LDAP)")),(0,a.yg)("p",null,"and more! A key goal of the abstraction is ",(0,a.yg)("em",{parentName:"p"},"extensibility"),": a custom Authenticator can be developed to authenticate requests\nbased on an organization's unique needs."),(0,a.yg)("p",null,"DataHub ships with 3 Authenticators by default:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"DataHubSystemAuthenticator"),": Verifies that inbound requests have originated from inside DataHub itself using a shared system identifier\nand secret. This authenticator is always present.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"DataHubTokenAuthenticator"),": Verifies that inbound requests contain a DataHub-issued Access Token (discussed further in the \"DataHub Access Token\" section below) in their\n'Authorization' header. This authenticator is required if Metadata Service Authentication is enabled.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"DataHubGuestAuthenticator"),": Verifies if guest authentication is enabled with a guest user configured and allows unauthenticated users to perform operations as the designated\nguest user. By default, this Authenticator is disabled. If this is required, it needs to be explicitly enabled and requires a restart of the datahub GMS service.")),(0,a.yg)("li",{parentName:"ul"})),(0,a.yg)("h2",{id:"what-is-an-authenticatorchain"},"What is an AuthenticatorChain?"),(0,a.yg)("p",null,"An ",(0,a.yg)("strong",{parentName:"p"},"AuthenticatorChain")," is a series of ",(0,a.yg)("strong",{parentName:"p"},"Authenticators")," that are configured to run one-after-another. This allows\nfor configuring multiple ways to authenticate a given request, for example via LDAP OR via local key file."),(0,a.yg)("p",null,"Only if each Authenticator within the chain fails to authenticate a request will it be rejected."),(0,a.yg)("p",null,"The Authenticator Chain can be configured in the ",(0,a.yg)("inlineCode",{parentName:"p"},"application.yaml")," file under ",(0,a.yg)("inlineCode",{parentName:"p"},"authentication.authenticators"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"authentication:\n  ....\n  authenticators:\n    # Configure the Authenticators in the chain\n    - type: com.datahub.authentication.Authenticator1\n      ...\n    - type: com.datahub.authentication.Authenticator2\n    ....\n")),(0,a.yg)("h2",{id:"what-is-the-two-tier-authentication-system"},"What is the Two-Tier Authentication System?"),(0,a.yg)("p",null,"DataHub uses a ",(0,a.yg)("strong",{parentName:"p"},"two-tier authentication system")," that decouples authentication extraction from enforcement:"),(0,a.yg)("h3",{id:"tier-1-authentication-extraction"},"Tier 1: Authentication Extraction"),(0,a.yg)("p",null,"The ",(0,a.yg)("strong",{parentName:"p"},"AuthenticationExtractionFilter")," is the foundation ",(0,a.yg)("a",{parentName:"p",href:"http://tutorials.jenkov.com/java-servlets/servlet-filters.html"},"servlet filter")," that runs for ",(0,a.yg)("strong",{parentName:"p"},"every request")," to the Metadata Service. Its single responsibility:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Extract Authentication Information"),": Constructs and invokes an ",(0,a.yg)("strong",{parentName:"li"},"AuthenticatorChain")," to process credentials"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Set Universal Context"),": Always establishes an ",(0,a.yg)("strong",{parentName:"li"},"AuthenticationContext")," (see below) for every request"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Never Enforce"),": Never blocks requests - if authentication fails, it sets an anonymous context and continues")),(0,a.yg)("h3",{id:"tier-2-authentication-enforcement"},"Tier 2: Authentication Enforcement"),(0,a.yg)("p",null,"The second tier consists of ",(0,a.yg)("strong",{parentName:"p"},"enforcement mechanisms")," that can be implemented in multiple ways:"),(0,a.yg)("h4",{id:"authenticationenforcementfilter"},"AuthenticationEnforcementFilter"),(0,a.yg)("p",null,"The default enforcement filter that:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Selective Processing"),": Only processes endpoints requiring authentication (excludes paths like ",(0,a.yg)("inlineCode",{parentName:"li"},"/health"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"/config"),")"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Context-Based Decisions"),": Reads the ",(0,a.yg)("strong",{parentName:"li"},"AuthenticationContext")," set by the extraction tier"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Request Blocking"),": Returns 401 unauthorized when authentication is required but not present")),(0,a.yg)("h4",{id:"additional-enforcement-options"},"Additional Enforcement Options"),(0,a.yg)("p",null,"The decoupled design enables flexible enforcement strategies:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Multiple Enforcement Filters"),": Different areas can have specialized filters (e.g., admin area filter with additional privilege checks)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Controller-Level Enforcement"),": Individual controllers can examine the ",(0,a.yg)("strong",{parentName:"li"},"AuthenticationContext")," and enforce their own rules"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Custom Authorization Logic"),": Business logic can make authentication decisions based on the established context")),(0,a.yg)("h3",{id:"benefits-of-two-tier-architecture"},"Benefits of Two-Tier Architecture"),(0,a.yg)("p",null,"This separation of concerns provides several advantages:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Decoupled Responsibilities"),": Authentication extraction is separate from enforcement decisions"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Performance"),": Authentication processing happens once per request, regardless of enforcement complexity"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Flexibility"),": Multiple enforcement strategies can coexist (filters, controllers, custom logic)"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Extensibility"),": New enforcement mechanisms can be added without changing authentication extraction"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Consistency"),": All parts of the system have access to the same authentication context"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Progressive Disclosure"),": As a side benefit, endpoints can provide different responses based on user authentication status")),(0,a.yg)("h2",{id:"what-is-authenticationcontext"},"What is AuthenticationContext?"),(0,a.yg)("p",null,"The ",(0,a.yg)("strong",{parentName:"p"},"AuthenticationContext")," is a thread-local storage mechanism that bridges the extraction and enforcement tiers. It serves as the ",(0,a.yg)("strong",{parentName:"p"},"universal authentication state")," for the entire request lifecycle:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Authentication Object"),": Contains the result of the authentication extraction process (Actor + credentials)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Anonymous Support"),": Set to anonymous actor when authentication extraction yields no valid credentials"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Request Lifecycle"),": Automatically established by the extraction tier and cleaned up after each request"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Universal Access"),": Available to all enforcement mechanisms - filters, controllers, or custom business logic")),(0,a.yg)("p",null,"This context enables ",(0,a.yg)("strong",{parentName:"p"},"consistent authentication decisions")," across all parts of the system. Whether enforcement happens in a servlet filter, a controller method, or custom business logic, they all work with the same authentication information established during the extraction phase."),(0,a.yg)("h2",{id:"what-is-a-datahub-token-service-what-are-access-tokens"},"What is a DataHub Token Service? What are Access Tokens?"),(0,a.yg)("p",null,"Along with Metadata Service Authentication comes an important new component called the ",(0,a.yg)("strong",{parentName:"p"},"DataHub Token Service"),". The purpose of this\ncomponent is twofold:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Generate Access Tokens that grant access to the Metadata Service"),(0,a.yg)("li",{parentName:"ol"},"Verify the validity of Access Tokens presented to the Metadata Service")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Access Tokens")," granted by the Token Service take the form of ",(0,a.yg)("a",{parentName:"p",href:"https://jwt.io/introduction"},"Json Web Tokens"),", a type of stateless token which\nhas a finite lifespan & is verified using a unique signature. JWTs can also contain a set of claims embedded within them. Tokens issued by the Token\nService contain the following claims:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"exp: the expiration time of the token"),(0,a.yg)("li",{parentName:"ul"},"version: version of the DataHub Access Token for purposes of evolvability (currently 1)"),(0,a.yg)("li",{parentName:"ul"},"type: The type of token, currently SESSION (used for UI-based sessions) or PERSONAL (used for personal access tokens)"),(0,a.yg)("li",{parentName:"ul"},"actorType: The type of the ",(0,a.yg)("strong",{parentName:"li"},"Actor")," associated with the token. Currently, USER is the only type supported."),(0,a.yg)("li",{parentName:"ul"},"actorId: The id of the ",(0,a.yg)("strong",{parentName:"li"},"Actor")," associated with the token.")),(0,a.yg)("p",null,"Today, Access Tokens are granted by the Token Service under two scenarios:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"UI Login"),": When a user logs into the DataHub UI, for example via ",(0,a.yg)("a",{parentName:"li",href:"/docs/authentication/guides/jaas"},"JaaS")," or\n",(0,a.yg)("a",{parentName:"li",href:"/docs/authentication/guides/sso/configure-oidc-react"},"OIDC"),", the ",(0,a.yg)("inlineCode",{parentName:"li"},"datahub-frontend")," service issues an\nrequest to the Metadata Service to generate a SESSION token ",(0,a.yg)("em",{parentName:"li"},"on behalf of")," of the user logging in. (","*","Only the frontend service is authorized to perform this action)."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Generating Personal Access Tokens"),": When a user requests to generate a Personal Access Token (described below) from the UI.")),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"At present, the Token Service supports the symmetric signing method ",(0,a.yg)("inlineCode",{parentName:"p"},"HS256")," to generate and verify tokens.")),(0,a.yg)("p",null,"Now that we're familiar with the concepts, we will talk concretely about what new capabilities have been built on top\nof Metadata Service Authentication."),(0,a.yg)("h2",{id:"how-do-i-enable-guest-authentication"},"How do I enable Guest Authentication"),(0,a.yg)("p",null,"The Guest Authentication configuration is present in two configuration files - the ",(0,a.yg)("inlineCode",{parentName:"p"},"application.conf")," for DataHub frontend, and\n",(0,a.yg)("inlineCode",{parentName:"p"},"application.yaml")," for GMS. To enable Guest Authentication, set the environment variable ",(0,a.yg)("inlineCode",{parentName:"p"},"GUEST_AUTHENTICATION_ENABLED")," to ",(0,a.yg)("inlineCode",{parentName:"p"},"true"),"\nfor both the GMS and the frontend service and restart those services.\nIf enabled, the default user designated as guest is called ",(0,a.yg)("inlineCode",{parentName:"p"},"guest"),". This user must be explicitly created and privileges assigned\nto control the guest user privileges."),(0,a.yg)("p",null,"A recommended approach to operationalize guest access is, first, create a designated guest user account with login credentials,\nbut keep guest access disabled. This allows you to configure and test the exact permissions this user should have. Once you've\nconfirmed the privileges are set correctly, you can then enable guest access, which removes the need for login/credentials\nwhile maintaining the verified permission settings."),(0,a.yg)("p",null,"The name of the designated guest user can be changed by defining the env var ",(0,a.yg)("inlineCode",{parentName:"p"},"GUEST_AUTHENTICATION_USER"),".\nThe entry URL to authenticate as the guest user is ",(0,a.yg)("inlineCode",{parentName:"p"},"/public")," and can be changed via the env var ",(0,a.yg)("inlineCode",{parentName:"p"},"GUEST_AUTHENTICATION_PATH")),(0,a.yg)("p",null,"Here are the relevant portions of the two configs"),(0,a.yg)("p",null,"For the Frontend"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-yaml"},"#application.conf\n...\nauth.guest.enabled = ${?GUEST_AUTHENTICATION_ENABLED}\n# The name of the guest user id\nauth.guest.user = ${?GUEST_AUTHENTICATION_USER}\n# The path to bypass login page and get logged in as guest\nauth.guest.path = ${?GUEST_AUTHENTICATION_PATH}\n...\n")),(0,a.yg)("p",null,"and for GMS"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-yaml"},"#application.yaml\n# Required if enabled is true! A configurable chain of Authenticators\n...\nauthenticators:\n  ...\n  - type: com.datahub.authentication.authenticator.DataHubGuestAuthenticator\n    configs:\n      guestUser: ${GUEST_AUTHENTICATION_USER:guest}\n      enabled: ${GUEST_AUTHENTICATION_ENABLED:false}\n...\n")))}y.isMDXComponent=!0}}]);