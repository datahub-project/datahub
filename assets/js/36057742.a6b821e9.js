"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[43237],{68307:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>p,default:()=>y,frontMatter:()=>d,metadata:()=>m,toc:()=>u});t(96540);var a=t(15680),i=t(53720),r=t(5400);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})),e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}const d={sidebar_position:30,title:"ER Model Relationship",slug:"/generated/metamodel/entities/ermodelrelationship",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/erModelRelationship.md"},p="ER Model Relationship",m={unversionedId:"docs/generated/metamodel/entities/erModelRelationship",id:"docs/generated/metamodel/entities/erModelRelationship",title:"ER Model Relationship",description:"Entity-Relationship (ER) Model Relationships represent the connections between entities in an entity-relationship diagram, specifically modeling how dataset fields relate to each other through foreign key constraints, joins, and other referential relationships. In DataHub, these relationships capture the semantic connections between tables, enabling users to understand data structure, enforce referential integrity, and trace data lineage at the field level.",source:"@site/genDocs/docs/generated/metamodel/entities/erModelRelationship.md",sourceDirName:"docs/generated/metamodel/entities",slug:"/generated/metamodel/entities/ermodelrelationship",permalink:"/docs/generated/metamodel/entities/ermodelrelationship",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/erModelRelationship.md",tags:[],version:"current",sidebarPosition:30,frontMatter:{sidebar_position:30,title:"ER Model Relationship",slug:"/generated/metamodel/entities/ermodelrelationship",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/metamodel/entities/erModelRelationship.md"},sidebar:"overviewSidebar",previous:{title:"DataHubView",permalink:"/docs/generated/metamodel/entities/datahubview"},next:{title:"Query",permalink:"/docs/generated/metamodel/entities/query"}},c={},u=[{value:"Identity",id:"identity",level:2},{value:"Example URNs",id:"example-urns",level:3},{value:"ID Generation",id:"id-generation",level:3},{value:"Important Capabilities",id:"important-capabilities",level:2},{value:"Relationship Properties",id:"relationship-properties",level:3},{value:"Core Attributes",id:"core-attributes",level:4},{value:"Cardinality Types",id:"cardinality-types",level:4},{value:"Field Mappings",id:"field-mappings",level:4},{value:"Custom Properties",id:"custom-properties",level:4},{value:"Timestamps",id:"timestamps",level:4},{value:"Creating an ER Model Relationship",id:"creating-an-er-model-relationship",level:3},{value:"Editable Properties",id:"editable-properties",level:3},{value:"Updating Editable Properties",id:"updating-editable-properties",level:4},{value:"Tags and Glossary Terms",id:"tags-and-glossary-terms",level:3},{value:"Adding Tags",id:"adding-tags",level:4},{value:"Adding Glossary Terms",id:"adding-glossary-terms",level:4},{value:"Ownership",id:"ownership",level:3},{value:"Complex Relationships",id:"complex-relationships",level:3},{value:"Querying Relationships",id:"querying-relationships",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"Dataset Integration",id:"dataset-integration",level:3},{value:"Schema Field Integration",id:"schema-field-integration",level:3},{value:"Data Lineage",id:"data-lineage",level:3},{value:"GraphQL API",id:"graphql-api",level:3},{value:"Authorization",id:"authorization",level:3},{value:"Notable Exceptions",id:"notable-exceptions",level:2},{value:"Non-directional Relationships",id:"non-directional-relationships",level:3},{value:"Relationship Lifecycle",id:"relationship-lifecycle",level:3},{value:"Schema Evolution",id:"schema-evolution",level:3},{value:"Platform Support",id:"platform-support",level:3},{value:"Future Considerations",id:"future-considerations",level:3},{value:"Technical Reference Guide",id:"technical-reference-guide",level:2},{value:"Reading the Field Tables",id:"reading-the-field-tables",level:3},{value:"Aspects",id:"aspects",level:3},{value:"erModelRelationshipProperties",id:"ermodelrelationshipproperties",level:4},{value:"editableERModelRelationshipProperties",id:"editableermodelrelationshipproperties",level:4},{value:"institutionalMemory",id:"institutionalmemory",level:4},{value:"ownership",id:"ownership-1",level:4},{value:"status",id:"status",level:4},{value:"globalTags",id:"globaltags",level:4},{value:"glossaryTerms",id:"glossaryterms",level:4},{value:"Common Types",id:"common-types",level:3},{value:"AuditStamp",id:"auditstamp",level:4},{value:"Relationships",id:"relationships",level:3},{value:"Outgoing",id:"outgoing",level:4},{value:"Global Metadata Model",id:"global-metadata-model",level:3}],h={toc:u},g="wrapper";function y(e){var{components:n}=e,t=o(e,["components"]);return(0,a.yg)(g,s(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},a=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})))),a.forEach((function(n){l(e,n,t[n])}))}return e}({},h,t),{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"er-model-relationship"},"ER Model Relationship"),(0,a.yg)("p",null,"Entity-Relationship (ER) Model Relationships represent the connections between entities in an entity-relationship diagram, specifically modeling how dataset fields relate to each other through foreign key constraints, joins, and other referential relationships. In DataHub, these relationships capture the semantic connections between tables, enabling users to understand data structure, enforce referential integrity, and trace data lineage at the field level."),(0,a.yg)("p",null,"ER Model Relationships are particularly valuable for documenting database schemas, data warehouse models, and any structured data system where understanding table relationships is critical for data governance, impact analysis, and query optimization."),(0,a.yg)("h2",{id:"identity"},"Identity"),(0,a.yg)("p",null,"ER Model Relationships are uniquely identified by a single identifier:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"id"),": A unique string identifier for the relationship. When created programmatically, this is typically generated as an MD5 hash based on the relationship name and the two datasets involved (sorted alphabetically to ensure consistency).")),(0,a.yg)("p",null,"The URN structure follows the pattern:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"urn:li:erModelRelationship:<id>\n")),(0,a.yg)("h3",{id:"example-urns"},"Example URNs"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"urn:li:erModelRelationship:employee_to_company\nurn:li:erModelRelationship:a1b2c3d4e5f6g7h8i9j0\n")),(0,a.yg)("h3",{id:"id-generation"},"ID Generation"),(0,a.yg)("p",null,"When creating relationships through the UI or API, the ID is often generated deterministically using a hash function to ensure consistency:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Create a JSON string with keys in alphabetical order: ",(0,a.yg)("inlineCode",{parentName:"li"},"Destination"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"ERModelRelationName"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"Source")),(0,a.yg)("li",{parentName:"ol"},'Use the lower lexicographic dataset URN as "Destination" and the higher as "Source"'),(0,a.yg)("li",{parentName:"ol"},"Generate an MD5 hash of this JSON string")),(0,a.yg)("p",null,"This ensures that the same relationship between two datasets always gets the same ID, regardless of creation order."),(0,a.yg)("h2",{id:"important-capabilities"},"Important Capabilities"),(0,a.yg)("h3",{id:"relationship-properties"},"Relationship Properties"),(0,a.yg)("p",null,"ER Model Relationships capture essential metadata about how datasets connect to each other through the ",(0,a.yg)("inlineCode",{parentName:"p"},"erModelRelationshipProperties")," aspect. This core aspect contains:"),(0,a.yg)("h4",{id:"core-attributes"},"Core Attributes"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"name"),': A human-readable name for the relationship (e.g., "Employee to Company Relationship")'),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"source"),": The URN of the source dataset (first entity in the relationship)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"destination"),": The URN of the destination dataset (second entity in the relationship)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"cardinality"),": Defines the relationship type between datasets")),(0,a.yg)("h4",{id:"cardinality-types"},"Cardinality Types"),(0,a.yg)("p",null,"DataHub supports four cardinality types that describe how records in one dataset relate to records in another:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"ONE_ONE"),": One-to-one relationship. Each record in the source dataset corresponds to exactly one record in the destination dataset."),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Example: Employee \u2192 EmployeeDetails (one employee has one detail record)"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"ONE_N"),": One-to-many relationship. Each record in the source dataset can correspond to multiple records in the destination dataset."),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Example: Department \u2192 Employee (one department has many employees)"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"N_ONE"),": Many-to-one relationship. Multiple records in the source dataset can correspond to one record in the destination dataset."),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Example: Employee \u2192 Company (many employees belong to one company)"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"N_N"),": Many-to-many relationship. Records in both datasets can have multiple corresponding records in the other dataset."),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Example: Student \u2192 Course (students take many courses, courses have many students)")))),(0,a.yg)("h4",{id:"field-mappings"},"Field Mappings"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"relationshipFieldMappings")," array defines which specific fields connect the two datasets. Each mapping contains:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"sourceField"),': The field path in the source dataset (e.g., "company_id")'),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"destinationField"),': The field path in the destination dataset (e.g., "id")')),(0,a.yg)("p",null,"Multiple field mappings can be specified for composite keys where the relationship depends on multiple fields."),(0,a.yg)("h4",{id:"custom-properties"},"Custom Properties"),(0,a.yg)("p",null,"Like other DataHub entities, ER Model Relationships support custom properties for storing additional metadata such as:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},'Constraint types (e.g., "Foreign Key", "Referential Integrity")'),(0,a.yg)("li",{parentName:"ul"},"Index information"),(0,a.yg)("li",{parentName:"ul"},"Database-specific metadata"),(0,a.yg)("li",{parentName:"ul"},"Business rules or validation logic")),(0,a.yg)("h4",{id:"timestamps"},"Timestamps"),(0,a.yg)("p",null,"Relationships include optional timestamp information to track when they were created and last modified in the source system:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"created"),": AuditStamp with creation time and actor"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"lastModified"),": AuditStamp with last modification time and actor")),(0,a.yg)("h3",{id:"creating-an-er-model-relationship"},"Creating an ER Model Relationship"),(0,a.yg)("p",null,"Here's a complete example showing how to create two datasets and establish a many-to-one relationship between them:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Create an ER Model Relationship"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/ermodelrelationship_create_basic.py\n# metadata-ingestion/examples/library/ermodelrelationship_create_basic.py\nimport os\nimport time\n\nfrom datahub.emitter.mce_builder import make_data_platform_urn, make_dataset_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    ERModelRelationshipCardinalityClass,\n    ERModelRelationshipKeyClass,\n    ERModelRelationshipPropertiesClass,\n    NumberTypeClass,\n    OtherSchemaClass,\n    RelationshipFieldMappingClass,\n    SchemaFieldClass,\n    SchemaFieldDataTypeClass,\n    SchemaMetadataClass,\n    StringTypeClass,\n)\n\nGMS_ENDPOINT = os.getenv("DATAHUB_GMS_URL", "http://localhost:8080")\nGMS_TOKEN = os.getenv("DATAHUB_GMS_TOKEN")\nPLATFORM = "mysql"\nENV = "PROD"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, token=GMS_TOKEN)\n\n\ndef create_dataset_with_schema(\n    dataset_name: str, fields: list[SchemaFieldClass]\n) -> str:\n    """Helper function to create a dataset with schema."""\n    dataset_urn = make_dataset_urn(PLATFORM, dataset_name, ENV)\n\n    schema_metadata = SchemaMetadataClass(\n        schemaName=dataset_name,\n        platform=make_data_platform_urn(PLATFORM),\n        fields=fields,\n        version=0,\n        hash="",\n        platformSchema=OtherSchemaClass(rawSchema=""),\n    )\n\n    emitter.emit_mcp(\n        MetadataChangeProposalWrapper(\n            entityUrn=dataset_urn,\n            aspect=schema_metadata,\n        )\n    )\n\n    return dataset_urn\n\n\ndef create_schema_field(\n    field_path: str, native_type: str, data_type: SchemaFieldDataTypeClass\n) -> SchemaFieldClass:\n    """Helper function to create a schema field."""\n    return SchemaFieldClass(\n        fieldPath=field_path,\n        type=data_type,\n        nativeDataType=native_type,\n        description=f"Field: {field_path}",\n        lastModified=AuditStampClass(\n            time=int(time.time() * 1000),\n            actor="urn:li:corpuser:datahub",\n        ),\n    )\n\n\n# Create Employee table\nemployee_fields = [\n    create_schema_field("id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())),\n    create_schema_field(\n        "name", "varchar(100)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "email", "varchar(255)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "company_id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())\n    ),\n]\nemployee_urn = create_dataset_with_schema("Employee", employee_fields)\nprint(f"Created Employee dataset: {employee_urn}")\n\n# Create Company table\ncompany_fields = [\n    create_schema_field("id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())),\n    create_schema_field(\n        "name", "varchar(200)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "industry", "varchar(100)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n]\ncompany_urn = create_dataset_with_schema("Company", company_fields)\nprint(f"Created Company dataset: {company_urn}")\n\n# Create ER Model Relationship\nrelationship_id = "employee_to_company"\nrelationship_urn = f"urn:li:erModelRelationship:{relationship_id}"\n\n# Emit the key aspect\nrelationship_key = ERModelRelationshipKeyClass(id=relationship_id)\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=relationship_urn,\n        aspect=relationship_key,\n    )\n)\n\n# Emit the properties aspect\nrelationship_properties = ERModelRelationshipPropertiesClass(\n    name="Employee to Company Relationship",\n    source=employee_urn,\n    destination=company_urn,\n    relationshipFieldMappings=[\n        RelationshipFieldMappingClass(\n            sourceField="company_id",\n            destinationField="id",\n        )\n    ],\n    cardinality=ERModelRelationshipCardinalityClass.N_ONE,\n    customProperties={\n        "constraint_type": "FOREIGN_KEY",\n        "on_delete": "CASCADE",\n        "on_update": "CASCADE",\n    },\n    created=AuditStampClass(\n        time=int(time.time() * 1000),\n        actor="urn:li:corpuser:datahub",\n    ),\n)\n\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=relationship_urn,\n        aspect=relationship_properties,\n    )\n)\n\nprint(f"Created ER Model Relationship: {relationship_urn}")\nprint(\n    "This N:1 relationship connects Employee.company_id to Company.id, "\n    "representing that many employees belong to one company."\n)\n\n'))),(0,a.yg)("h3",{id:"editable-properties"},"Editable Properties"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"editableERModelRelationshipProperties")," aspect allows users to add or modify relationship metadata through the DataHub UI without overwriting information ingested from source systems. This separation follows the same pattern used across DataHub entities."),(0,a.yg)("p",null,"Editable properties include:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"description"),": Documentation explaining the relationship's purpose, constraints, or business logic"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"name"),": An alternative display name that overrides the source system name")),(0,a.yg)("h4",{id:"updating-editable-properties"},"Updating Editable Properties"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Update editable relationship properties"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/ermodelrelationship_update_properties.py\n# metadata-ingestion/examples/library/ermodelrelationship_update_properties.py\nimport time\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    EditableERModelRelationshipPropertiesClass,\n)\n\nGMS_ENDPOINT = "http://localhost:8080"\nrelationship_urn = "urn:li:erModelRelationship:employee_to_company"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, extra_headers={})\n\n# Create or update editable properties\naudit_stamp = AuditStampClass(\n    time=int(time.time() * 1000), actor="urn:li:corpuser:datahub"\n)\n\neditable_properties = EditableERModelRelationshipPropertiesClass(\n    name="Employee-Company Foreign Key",\n    description=(\n        "This relationship establishes referential integrity between the Employee "\n        "and Company tables. Each employee record must reference a valid company. "\n        "The relationship enforces CASCADE on both UPDATE and DELETE operations, "\n        "meaning changes to company IDs will propagate to employee records, and "\n        "deleting a company will delete all associated employees."\n    ),\n    created=audit_stamp,\n)\n\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=relationship_urn,\n        aspect=editable_properties,\n    )\n)\n\nprint(f"Updated editable properties for ER Model Relationship {relationship_urn}")\nprint(f"Name: {editable_properties.name}")\nprint(f"Description: {editable_properties.description}")\n\n'))),(0,a.yg)("h3",{id:"tags-and-glossary-terms"},"Tags and Glossary Terms"),(0,a.yg)("p",null,"ER Model Relationships support tagging and glossary term attachment just like other DataHub entities. This allows you to categorize relationships, mark them with data classification tags, or link them to business concepts."),(0,a.yg)("h4",{id:"adding-tags"},"Adding Tags"),(0,a.yg)("p",null,"Tags can be used to classify relationships by type, importance, or data domain:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add a tag to an ER Model Relationship"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/ermodelrelationship_add_tag.py\n# metadata-ingestion/examples/library/ermodelrelationship_add_tag.py\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    GlobalTagsClass,\n    TagAssociationClass,\n)\n\nGMS_ENDPOINT = "http://localhost:8080"\nrelationship_urn = "urn:li:erModelRelationship:employee_to_company"\ntag_urn = "urn:li:tag:ForeignKey"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, extra_headers={})\n\n# Read current tags\n# FIXME: emitter.get not available\n# gms_response = emitter.get(relationship_urn, aspects=["globalTags"])\ncurrent_tags: dict[\n    str, object\n] = {}  # gms_response.get("globalTags", {}) if gms_response else {}\n\n# Build new tags list\nexisting_tags = []\nif isinstance(current_tags, dict) and "tags" in current_tags:\n    tags_list = current_tags["tags"]\n    if isinstance(tags_list, list):\n        existing_tags = [tag["tag"] for tag in tags_list]\n\n# Add new tag if not already present\nif tag_urn not in existing_tags:\n    tag_associations = [\n        TagAssociationClass(tag=existing_tag) for existing_tag in existing_tags\n    ]\n    tag_associations.append(TagAssociationClass(tag=tag_urn))\n\n    global_tags = GlobalTagsClass(tags=tag_associations)\n\n    emitter.emit_mcp(\n        MetadataChangeProposalWrapper(\n            entityUrn=relationship_urn,\n            aspect=global_tags,\n        )\n    )\n\n    print(f"Added tag {tag_urn} to ER Model Relationship {relationship_urn}")\nelse:\n    print(f"Tag {tag_urn} already exists on {relationship_urn}")\n\n'))),(0,a.yg)("h4",{id:"adding-glossary-terms"},"Adding Glossary Terms"),(0,a.yg)("p",null,"Glossary terms connect relationships to business concepts and terminology:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add a glossary term to an ER Model Relationship"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/ermodelrelationship_add_term.py\n# metadata-ingestion/examples/library/ermodelrelationship_add_term.py\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    GlossaryTermAssociationClass,\n    GlossaryTermsClass,\n)\n\nGMS_ENDPOINT = "http://localhost:8080"\nrelationship_urn = "urn:li:erModelRelationship:employee_to_company"\nterm_urn = "urn:li:glossaryTerm:ReferentialIntegrity"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, extra_headers={})\n\n# Read current glossary terms\n# FIXME: emitter.get not available\n# gms_response = emitter.get(relationship_urn, aspects=["glossaryTerms"])\ncurrent_terms: dict[\n    str, object\n] = {}  # gms_response.get("glossaryTerms", {}) if gms_response else {}\n\n# Build new terms list\nexisting_terms = []\nif isinstance(current_terms, dict) and "terms" in current_terms:\n    terms_list = current_terms["terms"]\n    if isinstance(terms_list, list):\n        existing_terms = [term["urn"] for term in terms_list]\n\n# Add new term if not already present\nif term_urn not in existing_terms:\n    term_associations = [\n        GlossaryTermAssociationClass(urn=existing_term)\n        for existing_term in existing_terms\n    ]\n    term_associations.append(GlossaryTermAssociationClass(urn=term_urn))\n\n    glossary_terms = GlossaryTermsClass(\n        terms=term_associations,\n        auditStamp=AuditStampClass(time=0, actor="urn:li:corpuser:datahub"),\n    )\n\n    emitter.emit_mcp(\n        MetadataChangeProposalWrapper(\n            entityUrn=relationship_urn,\n            aspect=glossary_terms,\n        )\n    )\n\n    print(f"Added glossary term {term_urn} to ER Model Relationship {relationship_urn}")\nelse:\n    print(f"Glossary term {term_urn} already exists on {relationship_urn}")\n\n'))),(0,a.yg)("h3",{id:"ownership"},"Ownership"),(0,a.yg)("p",null,"Ownership can be assigned to ER Model Relationships to indicate who is responsible for maintaining the relationship definition or who should be consulted about changes to the connected datasets."),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Add an owner to an ER Model Relationship"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/ermodelrelationship_add_owner.py\n# metadata-ingestion/examples/library/ermodelrelationship_add_owner.py\nimport time\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    OwnerClass,\n    OwnershipClass,\n    OwnershipTypeClass,\n)\n\nGMS_ENDPOINT = "http://localhost:8080"\nrelationship_urn = "urn:li:erModelRelationship:employee_to_company"\nowner_urn = "urn:li:corpuser:jdoe"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, extra_headers={})\n\n# Read current ownership\n# FIXME: emitter.get not available\n# gms_response = emitter.get(relationship_urn, aspects=["ownership"])\ncurrent_ownership: dict[\n    str, object\n] = {}  # gms_response.get("ownership", {}) if gms_response else {}\n\n# Build new owners list\nexisting_owners = []\nif isinstance(current_ownership, dict) and "owners" in current_ownership:\n    owners_list = current_ownership["owners"]\n    if isinstance(owners_list, list):\n        existing_owners = [owner["owner"] for owner in owners_list]\n\n# Add new owner if not already present\nif owner_urn not in existing_owners:\n    owner_list = [\n        OwnerClass(owner=existing_owner, type=OwnershipTypeClass.DATAOWNER)\n        for existing_owner in existing_owners\n    ]\n    owner_list.append(\n        OwnerClass(\n            owner=owner_urn,\n            type=OwnershipTypeClass.DATAOWNER,\n        )\n    )\n\n    ownership = OwnershipClass(\n        owners=owner_list,\n        lastModified=AuditStampClass(\n            time=int(time.time() * 1000),\n            actor="urn:li:corpuser:datahub",\n        ),\n    )\n\n    emitter.emit_mcp(\n        MetadataChangeProposalWrapper(\n            entityUrn=relationship_urn,\n            aspect=ownership,\n        )\n    )\n\n    print(f"Added owner {owner_urn} to ER Model Relationship {relationship_urn}")\nelse:\n    print(f"Owner {owner_urn} already exists on {relationship_urn}")\n\n'))),(0,a.yg)("h3",{id:"complex-relationships"},"Complex Relationships"),(0,a.yg)("p",null,"ER Model Relationships can model sophisticated data structures including composite keys and many-to-many relationships through junction tables:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Python SDK: Create a many-to-many relationship with composite keys"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'# Inlined from /metadata-ingestion/examples/library/ermodelrelationship_complex_many_to_many.py\n# metadata-ingestion/examples/library/ermodelrelationship_complex_many_to_many.py\nimport time\n\nfrom datahub.emitter.mce_builder import make_data_platform_urn, make_dataset_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    ERModelRelationshipCardinalityClass,\n    ERModelRelationshipKeyClass,\n    ERModelRelationshipPropertiesClass,\n    NumberTypeClass,\n    OtherSchemaClass,\n    RelationshipFieldMappingClass,\n    SchemaFieldClass,\n    SchemaFieldDataTypeClass,\n    SchemaMetadataClass,\n    StringTypeClass,\n)\n\nGMS_ENDPOINT = "http://localhost:8080"\nPLATFORM = "postgres"\nENV = "PROD"\n\nemitter = DatahubRestEmitter(gms_server=GMS_ENDPOINT, extra_headers={})\n\n\ndef create_dataset_with_schema(\n    dataset_name: str, fields: list[SchemaFieldClass]\n) -> str:\n    """Helper function to create a dataset with schema."""\n    dataset_urn = make_dataset_urn(PLATFORM, dataset_name, ENV)\n\n    schema_metadata = SchemaMetadataClass(\n        schemaName=dataset_name,\n        platform=make_data_platform_urn(PLATFORM),\n        fields=fields,\n        version=0,\n        hash="",\n        platformSchema=OtherSchemaClass(rawSchema=""),\n    )\n\n    emitter.emit_mcp(\n        MetadataChangeProposalWrapper(\n            entityUrn=dataset_urn,\n            aspect=schema_metadata,\n        )\n    )\n\n    return dataset_urn\n\n\ndef create_schema_field(\n    field_path: str, native_type: str, data_type: SchemaFieldDataTypeClass\n) -> SchemaFieldClass:\n    """Helper function to create a schema field."""\n    return SchemaFieldClass(\n        fieldPath=field_path,\n        type=data_type,\n        nativeDataType=native_type,\n        description=f"Field: {field_path}",\n        lastModified=AuditStampClass(\n            time=int(time.time() * 1000),\n            actor="urn:li:corpuser:datahub",\n        ),\n    )\n\n\n# Create Student table\nstudent_fields = [\n    create_schema_field("id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())),\n    create_schema_field(\n        "name", "varchar(100)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "email", "varchar(255)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n]\nstudent_urn = create_dataset_with_schema("Student", student_fields)\nprint(f"Created Student dataset: {student_urn}")\n\n# Create Course table\ncourse_fields = [\n    create_schema_field("id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())),\n    create_schema_field(\n        "code", "varchar(20)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "title", "varchar(200)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n]\ncourse_urn = create_dataset_with_schema("Course", course_fields)\nprint(f"Created Course dataset: {course_urn}")\n\n# Create StudentCourse junction table with composite key\nstudent_course_fields = [\n    create_schema_field(\n        "student_id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())\n    ),\n    create_schema_field(\n        "course_id", "int", SchemaFieldDataTypeClass(type=NumberTypeClass())\n    ),\n    create_schema_field(\n        "enrollment_date", "date", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n    create_schema_field(\n        "grade", "varchar(2)", SchemaFieldDataTypeClass(type=StringTypeClass())\n    ),\n]\nstudent_course_urn = create_dataset_with_schema("StudentCourse", student_course_fields)\nprint(f"Created StudentCourse junction table: {student_course_urn}")\n\n# Create relationship: StudentCourse -> Student (many-to-one)\nstudent_relationship_id = "student_course_to_student"\nstudent_relationship_urn = f"urn:li:erModelRelationship:{student_relationship_id}"\n\nstudent_relationship_key = ERModelRelationshipKeyClass(id=student_relationship_id)\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=student_relationship_urn,\n        aspect=student_relationship_key,\n    )\n)\n\nstudent_relationship_properties = ERModelRelationshipPropertiesClass(\n    name="StudentCourse to Student Relationship",\n    source=student_course_urn,\n    destination=student_urn,\n    relationshipFieldMappings=[\n        RelationshipFieldMappingClass(\n            sourceField="student_id",\n            destinationField="id",\n        )\n    ],\n    cardinality=ERModelRelationshipCardinalityClass.N_ONE,\n    customProperties={\n        "constraint_type": "FOREIGN_KEY",\n        "part_of_composite_key": "true",\n    },\n    created=AuditStampClass(\n        time=int(time.time() * 1000),\n        actor="urn:li:corpuser:datahub",\n    ),\n)\n\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=student_relationship_urn,\n        aspect=student_relationship_properties,\n    )\n)\n\nprint(f"Created relationship: {student_relationship_urn}")\n\n# Create relationship: StudentCourse -> Course (many-to-one)\ncourse_relationship_id = "student_course_to_course"\ncourse_relationship_urn = f"urn:li:erModelRelationship:{course_relationship_id}"\n\ncourse_relationship_key = ERModelRelationshipKeyClass(id=course_relationship_id)\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=course_relationship_urn,\n        aspect=course_relationship_key,\n    )\n)\n\ncourse_relationship_properties = ERModelRelationshipPropertiesClass(\n    name="StudentCourse to Course Relationship",\n    source=student_course_urn,\n    destination=course_urn,\n    relationshipFieldMappings=[\n        RelationshipFieldMappingClass(\n            sourceField="course_id",\n            destinationField="id",\n        )\n    ],\n    cardinality=ERModelRelationshipCardinalityClass.N_ONE,\n    customProperties={\n        "constraint_type": "FOREIGN_KEY",\n        "part_of_composite_key": "true",\n    },\n    created=AuditStampClass(\n        time=int(time.time() * 1000),\n        actor="urn:li:corpuser:datahub",\n    ),\n)\n\nemitter.emit_mcp(\n    MetadataChangeProposalWrapper(\n        entityUrn=course_relationship_urn,\n        aspect=course_relationship_properties,\n    )\n)\n\nprint(f"Created relationship: {course_relationship_urn}")\n\nprint("\\nMany-to-many relationship established through junction table:")\nprint("- Student N:N Course (via StudentCourse junction table)")\nprint("- StudentCourse has composite primary key (student_id, course_id)")\nprint("- Each component of the composite key is a foreign key to its respective table")\n\n'))),(0,a.yg)("h3",{id:"querying-relationships"},"Querying Relationships"),(0,a.yg)("p",null,"ER Model Relationships can be queried using the standard DataHub REST API:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Fetch an ER Model Relationship"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"curl 'http://localhost:8080/entities/urn%3Ali%3AerModelRelationship%3Aemployee_to_company'\n")),(0,a.yg)("p",null,"The response includes all aspects of the relationship:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "urn": "urn:li:erModelRelationship:employee_to_company",\n  "aspects": {\n    "erModelRelationshipKey": {\n      "id": "employee_to_company"\n    },\n    "erModelRelationshipProperties": {\n      "name": "Employee to Company Relationship",\n      "source": "urn:li:dataset:(urn:li:dataPlatform:mysql,Employee,PROD)",\n      "destination": "urn:li:dataset:(urn:li:dataPlatform:mysql,Company,PROD)",\n      "relationshipFieldMappings": [\n        {\n          "sourceField": "company_id",\n          "destinationField": "id"\n        }\n      ],\n      "cardinality": "N_ONE",\n      "customProperties": {\n        "constraint": "Foreign Key"\n      }\n    }\n  }\n}\n'))),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Find all relationships for a dataset"),(0,a.yg)("p",null,"You can discover relationships connected to a specific dataset by querying the relationships API:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"# Find relationships where the dataset is the source\ncurl 'http://localhost:8080/relationships?direction=OUTGOING&urn=urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Amysql,Employee,PROD)&types=ermodelrelationA'\n\n# Find relationships where the dataset is the destination\ncurl 'http://localhost:8080/relationships?direction=INCOMING&urn=urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Amysql,Company,PROD)&types=ermodelrelationB'\n"))),(0,a.yg)("h2",{id:"integration-points"},"Integration Points"),(0,a.yg)("p",null,"ER Model Relationships integrate with several other DataHub entities and features:"),(0,a.yg)("h3",{id:"dataset-integration"},"Dataset Integration"),(0,a.yg)("p",null,"ER Model Relationships are fundamentally connected to ",(0,a.yg)("a",{parentName:"p",href:"/docs/generated/metamodel/entities/dataset"},"Dataset")," entities. Each relationship must reference exactly two datasets:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Relationships are discoverable from dataset pages in the UI"),(0,a.yg)("li",{parentName:"ul"},"The GraphQL API automatically resolves source and destination dataset details"),(0,a.yg)("li",{parentName:"ul"},"Relationship information enriches dataset schema views")),(0,a.yg)("h3",{id:"schema-field-integration"},"Schema Field Integration"),(0,a.yg)("p",null,"While the entity stores field paths as strings, these correspond to ",(0,a.yg)("a",{parentName:"p",href:"/docs/generated/metamodel/entities/schemafield"},"SchemaField")," entities within the referenced datasets. This enables:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Visual representation of foreign key relationships in the UI"),(0,a.yg)("li",{parentName:"ul"},"Field-level lineage analysis"),(0,a.yg)("li",{parentName:"ul"},"Impact analysis when schema changes occur")),(0,a.yg)("h3",{id:"data-lineage"},"Data Lineage"),(0,a.yg)("p",null,"ER Model Relationships complement but are distinct from DataHub's lineage features:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"ER Model Relationships"),": Model the static structure and referential constraints between datasets"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Upstream/Downstream Lineage"),": Captures how data flows through transformations and pipelines")),(0,a.yg)("p",null,"Together, these features provide a complete picture of both data structure and data flow."),(0,a.yg)("h3",{id:"graphql-api"},"GraphQL API"),(0,a.yg)("p",null,"The DataHub GraphQL API provides rich querying capabilities for ER Model Relationships:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"erModelRelationship(urn: String!)"),": Fetch a specific relationship"),(0,a.yg)("li",{parentName:"ul"},"Create and update relationships through mutations"),(0,a.yg)("li",{parentName:"ul"},"Traverse from datasets to their relationships"),(0,a.yg)("li",{parentName:"ul"},"Bulk query capabilities for building ER diagrams")),(0,a.yg)("h3",{id:"authorization"},"Authorization"),(0,a.yg)("p",null,"Creating and modifying ER Model Relationships requires appropriate permissions in DataHub's policy framework. Users must have edit permissions on both the source and destination datasets to create a relationship between them."),(0,a.yg)("h2",{id:"notable-exceptions"},"Notable Exceptions"),(0,a.yg)("h3",{id:"non-directional-relationships"},"Non-directional Relationships"),(0,a.yg)("p",null,'While ER Model Relationships have "source" and "destination" fields, these do not necessarily imply directionality in the traditional sense of foreign keys:'),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"The source/destination ordering is primarily for internal consistency"),(0,a.yg)("li",{parentName:"ul"},"When generating IDs, datasets are ordered alphabetically to ensure the same relationship always produces the same ID"),(0,a.yg)("li",{parentName:"ul"},"Cardinality types (ONE_N vs N_ONE) explicitly capture the actual relationship direction")),(0,a.yg)("h3",{id:"relationship-lifecycle"},"Relationship Lifecycle"),(0,a.yg)("p",null,"ER Model Relationships are currently separate from the datasets they connect:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Deleting a dataset does not automatically delete its relationships"),(0,a.yg)("li",{parentName:"ul"},"Orphaned relationships (pointing to non-existent datasets) may exist after dataset deletion"),(0,a.yg)("li",{parentName:"ul"},"Applications should handle cases where relationship endpoints may not exist")),(0,a.yg)("h3",{id:"schema-evolution"},"Schema Evolution"),(0,a.yg)("p",null,"ER Model Relationships reference field paths as strings, not versioned schema references:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"If field names change in a dataset schema, the relationship may reference outdated field names"),(0,a.yg)("li",{parentName:"ul"},"No automatic validation ensures that referenced fields exist in current schemas"),(0,a.yg)("li",{parentName:"ul"},"Applications should implement field validation when creating relationships")),(0,a.yg)("h3",{id:"platform-support"},"Platform Support"),(0,a.yg)("p",null,"Not all data platforms have first-class support for ER Model Relationships:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Relational databases (MySQL, PostgreSQL, Oracle) naturally map to this model"),(0,a.yg)("li",{parentName:"ul"},"NoSQL databases and data lakes may not have explicit relationship metadata"),(0,a.yg)("li",{parentName:"ul"},"Some ingestion connectors automatically extract foreign key relationships, others do not")),(0,a.yg)("h3",{id:"future-considerations"},"Future Considerations"),(0,a.yg)("p",null,"The ER Model Relationship entity may evolve to include:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Additional relationship types beyond cardinality (inheritance, composition)"),(0,a.yg)("li",{parentName:"ul"},"Versioning to track relationship changes over time"),(0,a.yg)("li",{parentName:"ul"},"Bidirectional field mappings for complex transformation logic"),(0,a.yg)("li",{parentName:"ul"},"Integration with data quality rules and constraint validation")),(0,a.yg)("h2",{id:"technical-reference-guide"},"Technical Reference Guide"),(0,a.yg)("p",null,"The sections above provide an overview of how to use this entity. The following sections provide detailed technical information about how metadata is stored and represented in DataHub."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Aspects")," are the individual pieces of metadata that can be attached to an entity. Each aspect contains specific information (like ownership, tags, or properties) and is stored as a separate record, allowing for flexible and incremental metadata updates."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Relationships")," show how this entity connects to other entities in the metadata graph. These connections are derived from the fields within each aspect and form the foundation of DataHub's knowledge graph."),(0,a.yg)("h3",{id:"reading-the-field-tables"},"Reading the Field Tables"),(0,a.yg)("p",null,"Each aspect's field table includes an ",(0,a.yg)("strong",{parentName:"p"},"Annotations")," column that provides additional metadata about how fields are used:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"\u26a0\ufe0f Deprecated"),": This field is deprecated and may be removed in a future version. Check the description for the recommended alternative"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Searchable"),": This field is indexed and can be searched in DataHub's search interface"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Searchable (fieldname)"),": When the field name in parentheses is shown, it indicates the field is indexed under a different name in the search index. For example, ",(0,a.yg)("inlineCode",{parentName:"li"},"dashboardTool")," is indexed as ",(0,a.yg)("inlineCode",{parentName:"li"},"tool")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"\u2192 RelationshipName"),": This field creates a relationship to another entity. The arrow indicates this field contains a reference (URN) to another entity, and the name indicates the type of relationship (e.g., ",(0,a.yg)("inlineCode",{parentName:"li"},"\u2192 Contains"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"\u2192 OwnedBy"),")")),(0,a.yg)("p",null,"Fields with complex types (like ",(0,a.yg)("inlineCode",{parentName:"p"},"Edge"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"AuditStamp"),") link to their definitions in the ",(0,a.yg)("a",{parentName:"p",href:"#common-types"},"Common Types")," section below."),(0,a.yg)("h3",{id:"aspects"},"Aspects"),(0,a.yg)("h4",{id:"ermodelrelationshipproperties"},"erModelRelationshipProperties"),(0,a.yg)("p",null,"Properties associated with a ERModelRelationship"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(r.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"customProperties"),(0,a.yg)("td",{parentName:"tr",align:null},"map"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Custom property bag."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"name"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Name of the ERModelRelation"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"source"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"First dataset in the erModelRelationship (no directionality)"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable, \u2192 ermodelrelationA")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"destination"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Second dataset in the erModelRelationship (no directionality)"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable, \u2192 ermodelrelationB")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"relationshipFieldMappings"),(0,a.yg)("td",{parentName:"tr",align:null},"RelationshipFieldMapping[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"ERModelRelationFieldMapping (in future we can make it an array)"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"created"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"A timestamp documenting when the asset was created in the source Data Platform (not on DataHub)"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"lastModified"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"A timestamp documenting when the asset was last modified in the source Data Platform (not on Data..."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"cardinality"),(0,a.yg)("td",{parentName:"tr",align:null},"ERModelRelationshipCardinality"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Cardinality of the relationship"),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(r.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "erModelRelationshipProperties"\n  },\n  "name": "ERModelRelationshipProperties",\n  "namespace": "com.linkedin.ermodelrelation",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "fieldType": "TEXT",\n          "queryByDefault": true\n        }\n      },\n      "type": {\n        "type": "map",\n        "values": "string"\n      },\n      "name": "customProperties",\n      "default": {},\n      "doc": "Custom property bag."\n    },\n    {\n      "Searchable": {\n        "boostScore": 10.0,\n        "enableAutocomplete": true,\n        "fieldType": "TEXT_PARTIAL"\n      },\n      "type": "string",\n      "name": "name",\n      "doc": "Name of the ERModelRelation"\n    },\n    {\n      "Relationship": {\n        "entityTypes": [\n          "dataset"\n        ],\n        "name": "ermodelrelationA"\n      },\n      "Searchable": {\n        "boostScore": 10.0,\n        "enableAutocomplete": true,\n        "fieldType": "TEXT_PARTIAL"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "source",\n      "doc": "First dataset in the erModelRelationship (no directionality)"\n    },\n    {\n      "Relationship": {\n        "entityTypes": [\n          "dataset"\n        ],\n        "name": "ermodelrelationB"\n      },\n      "Searchable": {\n        "boostScore": 10.0,\n        "enableAutocomplete": true,\n        "fieldType": "TEXT_PARTIAL"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "destination",\n      "doc": "Second dataset in the erModelRelationship (no directionality)"\n    },\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "RelationshipFieldMapping",\n          "namespace": "com.linkedin.ermodelrelation",\n          "fields": [\n            {\n              "type": "string",\n              "name": "sourceField",\n              "doc": "All fields from dataset A that are required for the join, maps to bFields 1:1"\n            },\n            {\n              "type": "string",\n              "name": "destinationField",\n              "doc": "All fields from dataset B that are required for the join, maps to aFields 1:1"\n            }\n          ],\n          "doc": "Individual Field Mapping of a relationship- one of several"\n        }\n      },\n      "name": "relationshipFieldMappings",\n      "doc": "ERModelRelationFieldMapping (in future we can make it an array)"\n    },\n    {\n      "Searchable": {\n        "/time": {\n          "fieldName": "createdAt",\n          "fieldType": "DATETIME"\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "AuditStamp",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "type": "long",\n              "name": "time",\n              "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "actor",\n              "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "impersonator",\n              "default": null,\n              "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "message",\n              "default": null,\n              "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n            }\n          ],\n          "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n        }\n      ],\n      "name": "created",\n      "default": null,\n      "doc": "A timestamp documenting when the asset was created in the source Data Platform (not on DataHub)"\n    },\n    {\n      "Searchable": {\n        "/time": {\n          "fieldName": "lastModifiedAt",\n          "fieldType": "DATETIME"\n        }\n      },\n      "type": [\n        "null",\n        "com.linkedin.common.AuditStamp"\n      ],\n      "name": "lastModified",\n      "default": null,\n      "doc": "A timestamp documenting when the asset was last modified in the source Data Platform (not on DataHub)"\n    },\n    {\n      "type": {\n        "type": "enum",\n        "name": "ERModelRelationshipCardinality",\n        "namespace": "com.linkedin.ermodelrelation",\n        "symbols": [\n          "ONE_ONE",\n          "ONE_N",\n          "N_ONE",\n          "N_N"\n        ]\n      },\n      "name": "cardinality",\n      "default": "N_N",\n      "doc": "Cardinality of the relationship"\n    }\n  ],\n  "doc": "Properties associated with a ERModelRelationship"\n}\n')))),(0,a.yg)("h4",{id:"editableermodelrelationshipproperties"},"editableERModelRelationshipProperties"),(0,a.yg)("p",null,"EditableERModelRelationProperties stores editable changes made to erModelRelationship properties. This separates changes made from\ningestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(r.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"created"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of..."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"lastModified"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"An AuditStamp corresponding to the last modification of this resource/association/sub-resource. I..."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"deleted"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically,..."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"description"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Documentation of the erModelRelationship"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable (editedDescription)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"name"),(0,a.yg)("td",{parentName:"tr",align:null},"string"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Display name of the ERModelRelation"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable (editedName)"))))),(0,a.yg)(r.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "editableERModelRelationshipProperties"\n  },\n  "name": "EditableERModelRelationshipProperties",\n  "namespace": "com.linkedin.ermodelrelation",\n  "fields": [\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          },\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "message",\n            "default": null,\n            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "created",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0,\n        "message": null\n      },\n      "doc": "An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": "com.linkedin.common.AuditStamp",\n      "name": "lastModified",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0,\n        "message": null\n      },\n      "doc": "An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": [\n        "null",\n        "com.linkedin.common.AuditStamp"\n      ],\n      "name": "deleted",\n      "default": null,\n      "doc": "An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."\n    },\n    {\n      "Searchable": {\n        "fieldName": "editedDescription",\n        "fieldType": "TEXT"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "description",\n      "default": null,\n      "doc": "Documentation of the erModelRelationship"\n    },\n    {\n      "Searchable": {\n        "fieldName": "editedName",\n        "fieldType": "TEXT_PARTIAL"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "name",\n      "default": null,\n      "doc": "Display name of the ERModelRelation"\n    }\n  ],\n  "doc": "EditableERModelRelationProperties stores editable changes made to erModelRelationship properties. This separates changes made from\\ningestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"\n}\n')))),(0,a.yg)("h4",{id:"institutionalmemory"},"institutionalMemory"),(0,a.yg)("p",null,"Institutional memory of an entity. This is a way to link to relevant documentation and provide description of the documentation. Institutional or tribal knowledge is very important for users to leverage the entity."),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(r.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"elements"),(0,a.yg)("td",{parentName:"tr",align:null},"InstitutionalMemoryMetadata[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"List of records that represent institutional memory of an entity. Each record consists of a link,..."),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(r.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "institutionalMemory"\n  },\n  "name": "InstitutionalMemory",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "InstitutionalMemoryMetadata",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.url.Url",\n                "coercerClass": "com.linkedin.common.url.UrlCoercer"\n              },\n              "type": "string",\n              "name": "url",\n              "doc": "Link to an engineering design document or a wiki page."\n            },\n            {\n              "type": "string",\n              "name": "description",\n              "doc": "Description of the link."\n            },\n            {\n              "type": {\n                "type": "record",\n                "name": "AuditStamp",\n                "namespace": "com.linkedin.common",\n                "fields": [\n                  {\n                    "type": "long",\n                    "name": "time",\n                    "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": "string",\n                    "name": "actor",\n                    "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "impersonator",\n                    "default": null,\n                    "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                  },\n                  {\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "message",\n                    "default": null,\n                    "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n                  }\n                ],\n                "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n              },\n              "name": "createStamp",\n              "doc": "Audit stamp associated with creation of this record"\n            },\n            {\n              "type": [\n                "null",\n                "com.linkedin.common.AuditStamp"\n              ],\n              "name": "updateStamp",\n              "default": null,\n              "doc": "Audit stamp associated with updation of this record"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "InstitutionalMemoryMetadataSettings",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "boolean",\n                      "name": "showInAssetPreview",\n                      "default": false,\n                      "doc": "Show record in asset preview like on entity header and search previews"\n                    }\n                  ],\n                  "doc": "Settings related to a record of InstitutionalMemoryMetadata"\n                }\n              ],\n              "name": "settings",\n              "default": null,\n              "doc": "Settings for this record"\n            }\n          ],\n          "doc": "Metadata corresponding to a record of institutional memory."\n        }\n      },\n      "name": "elements",\n      "doc": "List of records that represent institutional memory of an entity. Each record consists of a link, description, creator and timestamps associated with that record."\n    }\n  ],\n  "doc": "Institutional memory of an entity. This is a way to link to relevant documentation and provide description of the documentation. Institutional or tribal knowledge is very important for users to leverage the entity."\n}\n')))),(0,a.yg)("h4",{id:"ownership-1"},"ownership"),(0,a.yg)("p",null,"Ownership information of an entity."),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(r.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"owners"),(0,a.yg)("td",{parentName:"tr",align:null},"Owner[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"List of owners of the entity."),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"ownerTypes"),(0,a.yg)("td",{parentName:"tr",align:null},"map"),(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null},"Ownership type to Owners map, populated via mutation hook."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"lastModified"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Audit stamp containing who last modified the record and when. A value of 0 in the time field indi..."),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(r.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "ownership"\n  },\n  "name": "Ownership",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "Owner",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "corpuser",\n                  "corpGroup"\n                ],\n                "name": "OwnedBy"\n              },\n              "Searchable": {\n                "addToFilters": true,\n                "fieldName": "owners",\n                "fieldType": "URN",\n                "filterNameOverride": "Owned By",\n                "hasValuesFieldName": "hasOwners",\n                "queryByDefault": false\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "owner",\n              "doc": "Owner URN, e.g. urn:li:corpuser:ldap, urn:li:corpGroup:group_name, and urn:li:multiProduct:mp_name\\n(Caveat: only corpuser is currently supported in the frontend.)"\n            },\n            {\n              "deprecated": true,\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "BUSINESS_OWNER": "A person or group who is responsible for logical, or business related, aspects of the asset.",\n                  "CONSUMER": "A person, group, or service that consumes the data\\nDeprecated! Use TECHNICAL_OWNER or BUSINESS_OWNER instead.",\n                  "CUSTOM": "Set when ownership type is unknown or a when new one is specified as an ownership type entity for which we have no\\nenum value for. This is used for backwards compatibility",\n                  "DATAOWNER": "A person or group that is owning the data\\nDeprecated! Use TECHNICAL_OWNER instead.",\n                  "DATA_STEWARD": "A steward, expert, or delegate responsible for the asset.",\n                  "DELEGATE": "A person or a group that overseas the operation, e.g. a DBA or SRE.\\nDeprecated! Use TECHNICAL_OWNER instead.",\n                  "DEVELOPER": "A person or group that is in charge of developing the code\\nDeprecated! Use TECHNICAL_OWNER instead.",\n                  "NONE": "No specific type associated to the owner.",\n                  "PRODUCER": "A person, group, or service that produces/generates the data\\nDeprecated! Use TECHNICAL_OWNER instead.",\n                  "STAKEHOLDER": "A person or a group that has direct business interest\\nDeprecated! Use TECHNICAL_OWNER, BUSINESS_OWNER, or STEWARD instead.",\n                  "TECHNICAL_OWNER": "person or group who is responsible for technical aspects of the asset."\n                },\n                "deprecatedSymbols": {\n                  "CONSUMER": true,\n                  "DATAOWNER": true,\n                  "DELEGATE": true,\n                  "DEVELOPER": true,\n                  "PRODUCER": true,\n                  "STAKEHOLDER": true\n                },\n                "name": "OwnershipType",\n                "namespace": "com.linkedin.common",\n                "symbols": [\n                  "CUSTOM",\n                  "TECHNICAL_OWNER",\n                  "BUSINESS_OWNER",\n                  "DATA_STEWARD",\n                  "NONE",\n                  "DEVELOPER",\n                  "DATAOWNER",\n                  "DELEGATE",\n                  "PRODUCER",\n                  "CONSUMER",\n                  "STAKEHOLDER"\n                ],\n                "doc": "Asset owner types"\n              },\n              "name": "type",\n              "doc": "The type of the ownership"\n            },\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "ownershipType"\n                ],\n                "name": "ownershipType"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "typeUrn",\n              "default": null,\n              "doc": "The type of the ownership\\nUrn of type O"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "OwnershipSource",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "enum",\n                        "symbolDocs": {\n                          "AUDIT": "Auditing system or audit logs",\n                          "DATABASE": "Database, e.g. GRANTS table",\n                          "FILE_SYSTEM": "File system, e.g. file/directory owner",\n                          "ISSUE_TRACKING_SYSTEM": "Issue tracking system, e.g. Jira",\n                          "MANUAL": "Manually provided by a user",\n                          "OTHER": "Other sources",\n                          "SERVICE": "Other ownership-like service, e.g. Nuage, ACL service etc",\n                          "SOURCE_CONTROL": "SCM system, e.g. GIT, SVN"\n                        },\n                        "name": "OwnershipSourceType",\n                        "namespace": "com.linkedin.common",\n                        "symbols": [\n                          "AUDIT",\n                          "DATABASE",\n                          "FILE_SYSTEM",\n                          "ISSUE_TRACKING_SYSTEM",\n                          "MANUAL",\n                          "SERVICE",\n                          "SOURCE_CONTROL",\n                          "OTHER"\n                        ]\n                      },\n                      "name": "type",\n                      "doc": "The type of the source"\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "url",\n                      "default": null,\n                      "doc": "A reference URL for the source"\n                    }\n                  ],\n                  "doc": "Source/provider of the ownership information"\n                }\n              ],\n              "name": "source",\n              "default": null,\n              "doc": "Source information for the ownership"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "ownerAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "ownerAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "ownerAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ],\n          "doc": "Ownership information"\n        }\n      },\n      "name": "owners",\n      "doc": "List of owners of the entity."\n    },\n    {\n      "Searchable": {\n        "/*": {\n          "fieldType": "MAP_ARRAY",\n          "queryByDefault": false\n        }\n      },\n      "type": [\n        {\n          "type": "map",\n          "values": {\n            "type": "array",\n            "items": "string"\n          }\n        },\n        "null"\n      ],\n      "name": "ownerTypes",\n      "default": {},\n      "doc": "Ownership type to Owners map, populated via mutation hook."\n    },\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          },\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "message",\n            "default": null,\n            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "lastModified",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0,\n        "message": null\n      },\n      "doc": "Audit stamp containing who last modified the record and when. A value of 0 in the time field indicates missing data."\n    }\n  ],\n  "doc": "Ownership information of an entity."\n}\n')))),(0,a.yg)("h4",{id:"status"},"status"),(0,a.yg)("p",null,"The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\nThis aspect is used to represent soft deletes conventionally."),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(r.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"removed"),(0,a.yg)("td",{parentName:"tr",align:null},"boolean"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Whether the entity has been removed (soft-deleted)."),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable"))))),(0,a.yg)(r.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "status"\n  },\n  "name": "Status",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN"\n      },\n      "type": "boolean",\n      "name": "removed",\n      "default": false,\n      "doc": "Whether the entity has been removed (soft-deleted)."\n    }\n  ],\n  "doc": "The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\\nThis aspect is used to represent soft deletes conventionally."\n}\n')))),(0,a.yg)("h4",{id:"globaltags"},"globalTags"),(0,a.yg)("p",null,"Tag aspect used for applying tags to an entity"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(r.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"tags"),(0,a.yg)("td",{parentName:"tr",align:null},"TagAssociation[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Tags associated with a given entity"),(0,a.yg)("td",{parentName:"tr",align:null},"Searchable, \u2192 TaggedWith"))))),(0,a.yg)(r.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "globalTags"\n  },\n  "name": "GlobalTags",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Relationship": {\n        "/*/tag": {\n          "entityTypes": [\n            "tag"\n          ],\n          "name": "TaggedWith"\n        }\n      },\n      "Searchable": {\n        "/*/tag": {\n          "addToFilters": true,\n          "boostScore": 0.5,\n          "fieldName": "tags",\n          "fieldType": "URN",\n          "filterNameOverride": "Tag",\n          "hasValuesFieldName": "hasTags",\n          "queryByDefault": true\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "TagAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.TagUrn"\n              },\n              "type": "string",\n              "name": "tag",\n              "doc": "Urn of the applied tag"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "context",\n              "default": null,\n              "doc": "Additional context about the association"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "tagAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "tagAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "tagAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ],\n          "doc": "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\\npropagation parameters."\n        }\n      },\n      "name": "tags",\n      "doc": "Tags associated with a given entity"\n    }\n  ],\n  "doc": "Tag aspect used for applying tags to an entity"\n}\n')))),(0,a.yg)("h4",{id:"glossaryterms"},"glossaryTerms"),(0,a.yg)("p",null,"Related business terms information"),(0,a.yg)(i.A,{mdxType:"Tabs"},(0,a.yg)(r.A,{value:"fields",label:"Fields",default:!0,mdxType:"TabItem"},(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Required"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"),(0,a.yg)("th",{parentName:"tr",align:null},"Annotations"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"terms"),(0,a.yg)("td",{parentName:"tr",align:null},"GlossaryTermAssociation[]"),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"The related business terms"),(0,a.yg)("td",{parentName:"tr",align:null})),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"auditStamp"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("a",{parentName:"td",href:"#auditstamp"},"AuditStamp")),(0,a.yg)("td",{parentName:"tr",align:null},"\u2713"),(0,a.yg)("td",{parentName:"tr",align:null},"Audit stamp containing who reported the related business term"),(0,a.yg)("td",{parentName:"tr",align:null}))))),(0,a.yg)(r.A,{value:"raw",label:"Raw Schema",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "glossaryTerms"\n  },\n  "name": "GlossaryTerms",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "GlossaryTermAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "glossaryTerm"\n                ],\n                "name": "TermedWith"\n              },\n              "Searchable": {\n                "addToFilters": true,\n                "fieldName": "glossaryTerms",\n                "fieldType": "URN",\n                "filterNameOverride": "Glossary Term",\n                "hasValuesFieldName": "hasGlossaryTerms",\n                "includeSystemModifiedAt": true,\n                "systemModifiedAtFieldName": "termsModifiedAt"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.GlossaryTermUrn"\n              },\n              "type": "string",\n              "name": "urn",\n              "doc": "Urn of the applied glossary term"\n            },\n            {\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "actor",\n              "default": null,\n              "doc": "The user URN which will be credited for adding associating this term to the entity"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "context",\n              "default": null,\n              "doc": "Additional context about the association"\n            },\n            {\n              "Searchable": {\n                "/actor": {\n                  "fieldName": "termAttributionActors",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/source": {\n                  "fieldName": "termAttributionSources",\n                  "fieldType": "URN",\n                  "queryByDefault": false\n                },\n                "/time": {\n                  "fieldName": "termAttributionDates",\n                  "fieldType": "DATETIME",\n                  "queryByDefault": false\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "MetadataAttribution",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "time",\n                      "doc": "When this metadata was updated."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": "string",\n                      "name": "actor",\n                      "doc": "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\\neither be a user (in case of UI edits) or the datahub system for automation."\n                    },\n                    {\n                      "java": {\n                        "class": "com.linkedin.common.urn.Urn"\n                      },\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "source",\n                      "default": null,\n                      "doc": "The DataHub source responsible for applying the associated metadata. This will only be filled out\\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."\n                    },\n                    {\n                      "type": {\n                        "type": "map",\n                        "values": "string"\n                      },\n                      "name": "sourceDetail",\n                      "default": {},\n                      "doc": "The details associated with why this metadata was applied. For example, this could include\\nthe actual regex rule, sql statement, ingestion pipeline ID, etc."\n                    }\n                  ],\n                  "doc": "Information about who, why, and how this metadata was applied"\n                }\n              ],\n              "name": "attribution",\n              "default": null,\n              "doc": "Information about who, why, and how this metadata was applied"\n            }\n          ],\n          "doc": "Properties of an applied glossary term."\n        }\n      },\n      "name": "terms",\n      "doc": "The related business terms"\n    },\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          },\n          {\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "message",\n            "default": null,\n            "doc": "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "auditStamp",\n      "doc": "Audit stamp containing who reported the related business term"\n    }\n  ],\n  "doc": "Related business terms information"\n}\n')))),(0,a.yg)("h3",{id:"common-types"},"Common Types"),(0,a.yg)("p",null,"These types are used across multiple aspects in this entity."),(0,a.yg)("h4",{id:"auditstamp"},"AuditStamp"),(0,a.yg)("p",null,"Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Fields:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"time")," (long): When did the resource/association/sub-resource move into the specific lifecyc..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"actor")," (string): The entity (e.g. a member URN) which will be credited for moving the resource..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"impersonator")," (string?): The entity (e.g. a service URN) which performs the change on behalf of the Ac..."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"message")," (string?): Additional context around how DataHub was informed of the particular change. ...")),(0,a.yg)("h3",{id:"relationships"},"Relationships"),(0,a.yg)("h4",{id:"outgoing"},"Outgoing"),(0,a.yg)("p",null,"These are the relationships stored in this entity's aspects"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"ermodelrelationA"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"erModelRelationshipProperties.source")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"ermodelrelationB"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Dataset via ",(0,a.yg)("inlineCode",{parentName:"li"},"erModelRelationshipProperties.destination")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"OwnedBy"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Corpuser via ",(0,a.yg)("inlineCode",{parentName:"li"},"ownership.owners.owner")),(0,a.yg)("li",{parentName:"ul"},"CorpGroup via ",(0,a.yg)("inlineCode",{parentName:"li"},"ownership.owners.owner")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"ownershipType"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"OwnershipType via ",(0,a.yg)("inlineCode",{parentName:"li"},"ownership.owners.typeUrn")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"TaggedWith"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Tag via ",(0,a.yg)("inlineCode",{parentName:"li"},"globalTags.tags")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"TermedWith"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"GlossaryTerm via ",(0,a.yg)("inlineCode",{parentName:"li"},"glossaryTerms.terms.urn"))))),(0,a.yg)("h3",{id:"global-metadata-model"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png"},"Global Metadata Model")),(0,a.yg)("p",null,(0,a.yg)("img",{parentName:"p",src:"https://github.com/datahub-project/static-assets/raw/main/imgs/datahub-metadata-model.png",alt:"Global Graph"})))}y.isMDXComponent=!0}}]);