name: Create Linear Ticket for Ingestion PR Review

on:
  pull_request_target:
    types: [opened, reopened, ready_for_review, closed]
    paths:
      - "metadata-ingestion/**"

jobs:
  create-linear-ticket:
    runs-on: ubuntu-latest
    continue-on-error: true
    timeout-minutes: 5
    steps:
      - name: Mark Linear ticket as Done if PR closed
        if: github.event.action == 'closed'
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
          LINEAR_API_KEY: ${{ secrets.INGESTION_LINEAR_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          # Find the Linear ticket ID from PR comments with proper error handling
          if ! COMMENTS_JSON=$(gh pr view "$PR_NUMBER" --json comments 2>/dev/null); then
            echo "‚ö†Ô∏è  Failed to fetch PR comments for PR #$PR_NUMBER"
            exit 0
          fi

          COMMENTS=$(echo "$COMMENTS_JSON" | jq -r '.comments[].body' 2>/dev/null || echo "")

          # Extract Linear ticket ID (format: Linear: ING-1234)
          TICKET_ID=$(echo "$COMMENTS" | grep -oP 'Linear: \K(ING-\d+)' 2>/dev/null | head -n1 || echo "")

          if [ -z "$TICKET_ID" ]; then
            echo "‚ö†Ô∏è  No Linear ticket found for PR #$PR_NUMBER"
            exit 0
          fi

          echo "Found Linear ticket: $TICKET_ID"

          # Query Linear to get the ticket's internal ID
          TICKET_QUERY=$(cat <<EOF
          {
            "query": "query { issue(id: \"$TICKET_ID\") { id state { name } } }"
          }
          EOF
          )

          TICKET_RESPONSE=$(curl -s -X POST https://api.linear.app/graphql \
            -H "Authorization: $LINEAR_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$TICKET_QUERY")

          if [ -z "$TICKET_RESPONSE" ]; then
            echo "‚ùå Empty response from Linear API when fetching ticket"
            exit 0
          fi

          TICKET_UUID=$(echo "$TICKET_RESPONSE" | jq -r '.data.issue.id' 2>/dev/null || echo "")
          CURRENT_STATE=$(echo "$TICKET_RESPONSE" | jq -r '.data.issue.state.name' 2>/dev/null || echo "unknown")

          if [ -z "$TICKET_UUID" ] || [ "$TICKET_UUID" = "null" ]; then
            echo "‚ùå Could not find Linear ticket $TICKET_ID"
            exit 0
          fi

          echo "Current ticket state: $CURRENT_STATE"

          # Get the "Done" state ID for the ING team
          STATE_QUERY=$(cat <<'EOF'
          {
            "query": "query { workflowStates(filter: { team: { key: { eq: \"ING\" } }, name: { eq: \"Done\" } }) { nodes { id name } } }"
          }
          EOF
          )

          STATE_RESPONSE=$(curl -s -X POST https://api.linear.app/graphql \
            -H "Authorization: $LINEAR_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$STATE_QUERY")

          if [ -z "$STATE_RESPONSE" ]; then
            echo "‚ùå Empty response from Linear API when fetching workflow states"
            exit 0
          fi

          DONE_STATE_ID=$(echo "$STATE_RESPONSE" | jq -r '.data.workflowStates.nodes[0].id' 2>/dev/null || echo "")

          if [ -z "$DONE_STATE_ID" ] || [ "$DONE_STATE_ID" = "null" ]; then
            echo "‚ùå Could not find 'Done' state for ING team"
            echo "Response: $STATE_RESPONSE" | jq . 2>/dev/null || echo "$STATE_RESPONSE"
            exit 0
          fi

          # Update the ticket to Done state
          UPDATE_MUTATION=$(cat <<EOF
          {
            "query": "mutation { issueUpdate(id: \"$TICKET_UUID\", input: { stateId: \"$DONE_STATE_ID\" }) { success issue { identifier state { name } } } }"
          }
          EOF
          )

          UPDATE_RESPONSE=$(curl -s -X POST https://api.linear.app/graphql \
            -H "Authorization: $LINEAR_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$UPDATE_MUTATION")

          if [ -z "$UPDATE_RESPONSE" ]; then
            echo "‚ùå Empty response from Linear API when updating ticket"
            exit 0
          fi

          SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.data.issueUpdate.success' 2>/dev/null || echo "false")

          if [ "$SUCCESS" = "true" ]; then
            echo "‚úÖ Marked Linear ticket $TICKET_ID as Done"
          else
            echo "‚ùå Failed to mark Linear ticket as Done"
            echo "$UPDATE_RESPONSE" | jq . 2>/dev/null || echo "$UPDATE_RESPONSE"
            exit 0
          fi

      - name: Check author status
        if: github.event.action != 'closed'
        id: check-author
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
          PR_DRAFT: ${{ github.event.pull_request.draft }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
        run: |
          # Skip draft PRs
          if [ "$PR_DRAFT" = "true" ]; then
            echo "should_skip=true" >> "$GITHUB_OUTPUT"
            echo "‚è≠Ô∏è  Skipping - PR is in draft"
            exit 0
          fi

          AUTHOR="$PR_AUTHOR"
          echo "should_skip=false" >> "$GITHUB_OUTPUT"

          # Check if author is DataHub org member (for info only)
          if gh api "orgs/datahub-project/members/$AUTHOR" --silent 2>/dev/null; then
            ORG_CHECK="Internal"
          else
            ORG_CHECK="External"
          fi
          echo "contributor_type=$ORG_CHECK" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Author: $AUTHOR ($ORG_CHECK)"

      - name: Create Linear Ticket
        if: steps.check-author.outputs.should_skip == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
          LINEAR_API_KEY: ${{ secrets.INGESTION_LINEAR_KEY }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_BODY: ${{ github.event.pull_request.body }}
          FILES_CHANGED: ${{ github.event.pull_request.changed_files }}
          ADDITIONS: ${{ github.event.pull_request.additions }}
          DELETIONS: ${{ github.event.pull_request.deletions }}
          CONTRIBUTOR_TYPE: ${{ steps.check-author.outputs.contributor_type }}
        run: |
          # Skip if a Linear ticket already exists for this PR (deduplication guard)
          if COMMENTS_JSON=$(gh pr view "$PR_NUMBER" --json comments 2>/dev/null); then
            EXISTING=$(echo "$COMMENTS_JSON" | jq -r '.comments[].body' 2>/dev/null | grep -oP 'Linear: ING-\d+' | head -n1 || echo "")
            if [ -n "$EXISTING" ]; then
              echo "‚è≠Ô∏è  Linear ticket already exists for PR #$PR_NUMBER ($EXISTING), skipping creation"
              exit 0
            fi
          fi

          # Use PR body from context, sanitize it
          if [ -z "$PR_BODY" ]; then
            PR_BODY="No description provided"
          fi

          # For file list, we need gh to get the actual paths
          # Use proper error handling - if this fails, use a fallback
          if FILES_JSON=$(gh pr view "$PR_NUMBER" --json files 2>/dev/null); then
            FILES_LIST=$(echo "$FILES_JSON" | jq -r '.files[:20] | map("- `" + .path + "`") | join("\n")' 2>/dev/null || echo "- Unable to fetch file list")
            if [ "$FILES_CHANGED" -gt 20 ]; then
              FILES_LIST="${FILES_LIST}\n- ... and $((FILES_CHANGED - 20)) more files"
            fi
          else
            FILES_LIST="- Unable to fetch file list"
          fi

          # Get requested reviewers from gh with proper error handling
          if REVIEWERS_JSON=$(gh pr view "$PR_NUMBER" --json reviewRequests 2>/dev/null); then
            REVIEWERS=$(echo "$REVIEWERS_JSON" | jq -r '.reviewRequests | map("@" + .login) | join(", ")' 2>/dev/null || echo "None")
            if [ -z "$REVIEWERS" ] || [ "$REVIEWERS" = "" ]; then
              REVIEWERS="None"
            fi
          else
            REVIEWERS="Unable to fetch"
          fi

          # Hardcoded IDs
          TEAM_ID="b1c9a278-522e-47cb-81af-8b860ead0c76"  # ING team
          USER_ID="bb4daa2b-1748-4830-af1f-60198ebd9a63"  # gabe

          # Build detailed description safely without printf format interpretation
          # Use cat with heredoc to avoid issues with special characters
          DESCRIPTION=$(cat <<DESCRIPTION_EOF
          Review PR #${PR_NUMBER} from @${PR_AUTHOR} (${CONTRIBUTOR_TYPE})

          ${PR_URL}

          ## Description
          ${PR_BODY}

          ## Changes
          - **Files changed**: ${FILES_CHANGED}
          - **Lines**: +${ADDITIONS} / -${DELETIONS}
          - **Requested reviewers**: ${REVIEWERS}

          ## Files Changed
          ${FILES_LIST}
          DESCRIPTION_EOF
          )

          TITLE="[PR Review] $PR_TITLE"

          # Pre-validate that we can JSON-encode the strings
          if ! TITLE_JSON=$(echo "$TITLE" | jq -Rs . 2>/dev/null) || [ -z "$TITLE_JSON" ]; then
            echo "‚ùå Failed to JSON-encode title"
            exit 0
          fi

          if ! DESCRIPTION_JSON=$(echo "$DESCRIPTION" | jq -Rs . 2>/dev/null) || [ -z "$DESCRIPTION_JSON" ]; then
            echo "‚ùå Failed to JSON-encode description"
            exit 0
          fi

          # Build mutation with pre-validated JSON strings
          MUTATION=$(cat <<EOF
          {
            "query": "mutation CreateIssue(\$input: IssueCreateInput!) { issueCreate(input: \$input) { success issue { id identifier title url } } }",
            "variables": {
              "input": {
                "teamId": "$TEAM_ID",
                "title": $TITLE_JSON,
                "description": $DESCRIPTION_JSON,
                "assigneeId": "$USER_ID"
              }
            }
          }
          EOF
          )

          RESPONSE=$(curl -s -X POST https://api.linear.app/graphql \
            -H "Authorization: $LINEAR_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$MUTATION")

          if [ -z "$RESPONSE" ]; then
            echo "‚ùå Empty response from Linear API"
            exit 0
          fi

          SUCCESS=$(echo "$RESPONSE" | jq -r '.data.issueCreate.success' 2>/dev/null)
          if [ "$SUCCESS" = "true" ]; then
            ISSUE_ID=$(echo "$RESPONSE" | jq -r '.data.issueCreate.issue.identifier')
            ISSUE_URL=$(echo "$RESPONSE" | jq -r '.data.issueCreate.issue.url')
            echo "‚úÖ Created Linear ticket: $ISSUE_ID"
            echo "üìé $ISSUE_URL"

            # Comment on the PR with minimal format
            if ! gh pr comment "$PR_NUMBER" --body "Linear: $ISSUE_ID" 2>/dev/null; then
              echo "‚ö†Ô∏è  Created ticket but failed to comment on PR"
            fi
          else
            echo "‚ùå Failed to create Linear ticket"
            echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"
            exit 0
          fi

      - name: Log skip reason
        if: steps.check-author.outputs.should_skip == 'true'
        run: |
          echo "‚è≠Ô∏è  Skipping Linear ticket creation - PR is in draft"
