import groovy.json.JsonSlurper
import org.apache.commons.io.output.TeeOutputStream


def _getDockerImages(String fullImageTag) {
  def stdOut = new ByteArrayOutputStream()
  exec {
    commandLine "docker", "images", "-q", "${fullImageTag}"
    standardOutput = stdOut
  }
  return stdOut.toString().trim().split("\\R").findAll { !it.empty }.unique() as List
}

def _getDockerContainers(String fullImageTag) {
  def stdOut = new ByteArrayOutputStream()
  exec {
    commandLine "docker", "container", "ls", "-q", "--filter",
        "ancestor=${fullImageTag}"
    standardOutput = stdOut
  }
  return stdOut.toString().trim().split("\\R").findAll { !it.empty }.unique() as List
}

def _cleanLocalDockerImages(String fullImageTag) {
  println("Docker image string: ${fullImageTag}")
  def containers = _getDockerContainers(fullImageTag)
  if (!containers.isEmpty()) {
    println "Stopping containers: $containers"
    exec {
      commandLine = ["docker", "container", "stop"] + containers
    }
    exec {
      commandLine = ["docker", "container", "rm"] + containers
    }
  }
  def images = _getDockerImages(fullImageTag)
  if (!images.isEmpty()) {
    println "Removing images: $images"
    exec {
      ignoreExitValue true // may not work if used by downstream image
      commandLine = ["docker", "rmi", "-f"] + images
    }
  }
}

// Create extension object
class DockerPluginExtension {
  Project project
  Property<File> dockerfile
  CopySpec copySpec
  MapProperty<String, String> buildArgs
  MapProperty<String, String> tags
  ListProperty<String> platforms
  ListProperty<Object> dependencies // May contain tasks or task  names

  DockerPluginExtension(Project project) {
    this.project = project
    dockerfile = project.objects.property(File)
    buildArgs = project.objects.mapProperty(String, String)
    copySpec = project.copySpec()
    tags = project.objects.mapProperty(String, String)
    platforms = project.objects.listProperty(String)
    dependencies = project.objects.listProperty(Object)
  }

  def files(Object... files) {
    copySpec.from(files)
  }

  def name(String value) {
    additionalTag("", value)
  }

  def dockerfile(File value) {
    dockerfile.set(value)
  }

  def buildArgs(Map<String, String> values) {
    buildArgs.putAll(values)
  }

  def platform(String... platforms) {
    this.platforms.addAll(platforms)
  }

  def additionalTag(String name, String tag) {
    tags.put(name, tag)
  }

  def dependsOn(Object... tasks) {
    dependencies.addAll(tasks)
  }
}

def extension = project.extensions.create("docker", DockerPluginExtension)

project.afterEvaluate {
  tasks.register("dockerPrepare", Sync) {
    group "docker"
    with extension.copySpec
    from extension.dockerfile
    into "${buildDir}/docker"
    dependsOn extension.dependencies.get()
  }

  project.tasks.register("docker", Exec) {
    group "docker"
    description "Builds the docker image and applies all tags defined"
    dependsOn dockerPrepare

    def buildContext = "${buildDir}/docker"

    def marker = "${buildDir}/imageCreated-${name}.json"

    inputs.file(extension.dockerfile)
    inputs.dir(buildContext)
    inputs.property("tags", extension.tags)
    inputs.property("buildArgs", extension.buildArgs)
    outputs.file(marker)

    def dockerCmd = []

    dockerCmd += ["docker", "buildx", "build", "--load"]
    if (extension.platforms.get()) {
      dockerCmd << "--platform=${extension.platforms.get().join(',')}"
    }

    // Generate image metadata (we really just want the sha256 hash of the image)
    dockerCmd += ["--metadata-file", marker]

    extension.buildArgs.get().each { k, v -> dockerCmd += ["--build-arg", "${k}=${v}"]
    }

    extension.tags.get().each { taskName, tag ->
      dockerCmd += ["-t", tag]
    }

    dockerCmd << "${buildDir}/docker"

    // Some projects use a Dockerfile with the non-default name.
    dockerCmd += ["--file", extension.dockerfile.get().toPath()]

    println(dockerCmd.join(" "))
    commandLine dockerCmd

    outputs.upToDateWhen {
      try {
        /* The docker task is up-to-date if
         * 1. the last build generated a marker file
         * 2. An image with the same tag exists in local docker images
         * 3. that existing image sha256 matches what is written in the generated marker file
         */
        def jsonContent = new File(marker).text
        def jsonData = new JsonSlurper().parseText(jsonContent)
        def imageIdFromMarker = jsonData['containerimage.digest']
        if (imageIdFromMarker != null && imageIdFromMarker.startsWith("sha256:")) {
          imageIdFromMarker = imageIdFromMarker.substring(7); // "sha256:".length() == 7
        }
        for(String tag : extension.tags.get().values()) {
          def actualImage = _getDockerImages(tag)
          if (actualImage == null || actualImage.size() == 0 && imageIdFromMarker == null ||
              !imageIdFromMarker.startsWith(actualImage.get(0))) {
            return false
          }
        }
        return true
      } catch (Exception e) {
        // any exceptions also implicitly mean not-up-to-date
        return false
      }
    }
  }
  extension.tags.get().each { taskName, tag ->
    // For backward compatibility, can be removed if we dont really have a need post migration
    // TODO: Choice of task names is to retain current names so that downstream dependencies in quickstart still work
    //  without changes. Can be changed post full migration.
    project.tasks.register("dockerTag${taskName}") {
      dependsOn project.tasks.named("docker")
    }
  }

  task dockerClean {
    group "docker"
    doLast {
      extension.tags.get().each { _, tag -> _cleanLocalDockerImages(tag)
      }
    }
  }
}
