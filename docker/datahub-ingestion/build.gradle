plugins {
    id 'java' // required for versioning
}

apply from: "../../gradle/versioning/versioning.gradle"
apply from: "../../gradle/docker/docker.gradle"

ext {
    docker_registry = rootProject.ext.docker_registry == 'linkedin' ? 'acryldata' : docker_registry
    docker_repo = 'datahub-ingestion'
    docker_dir = 'datahub-ingestion'
    docker_target = project.getProperties().getOrDefault("dockerTarget", "slim")
    docker_version = "${versionTag}"  // Variants will add suffix to this tag
    python_docker_version = project.getProperties().getOrDefault("pythonDockerVersion", "1!0.0.0+docker.${version}")
    // Set to true to include Alpine variants in the build (e.g., -PincludeAlpineVariants=true)
    include_alpine_variants = project.getProperties().getOrDefault("includeAlpineVariants", "false").toBoolean()

    revision = 12 // increment to trigger rebuild
}

dependencies {
    project(':metadata-ingestion')
}

docker {
    dependsOn 'build', ':metadata-ingestion:codegen'
    name "${docker_registry}/${docker_repo}:${docker_version}"
    dockerfile file("${rootProject.projectDir}/docker/${docker_dir}/Dockerfile")
    files fileTree(rootProject.projectDir) {
        include '.dockerignore'
        include "docker/${docker_dir}/*"
        include "docker/snippets/*"
        include "metadata-ingestion/**"
        include "metadata-ingestion-modules/**"
        include "python-build/**"
    }.exclude {
        i -> (!i.file.name.endsWith(".dockerignore") && i.file.isHidden())
    }

    version "${docker_version}"

    defaultVariant = "full"

    // Base variants (Ubuntu-based)
    def baseVariants = [
        "full": [suffix: "", target: "final-full", args: [RELEASE_VERSION: python_docker_version, APP_ENV: "full"]],
        "slim": [suffix: "-slim", target: "final-slim", args: [RELEASE_VERSION: python_docker_version, APP_ENV: "slim"]],
        "locked": [suffix: "-locked", target: "final-locked", args: [RELEASE_VERSION: python_docker_version, APP_ENV: "locked"]]
    ]

    // Alpine variants (only included when -PincludeAlpineVariants=true)
    def alpineVariants = [
        "slim-alpine": [suffix: "-slim-alpine", target: "final-slim-alpine", args: [RELEASE_VERSION: python_docker_version, APP_ENV: "slim-alpine"]],
        "locked-alpine": [suffix: "-locked-alpine", target: "final-locked-alpine", args: [RELEASE_VERSION: python_docker_version, APP_ENV: "locked-alpine"]]
    ]

    variants = include_alpine_variants ? baseVariants + alpineVariants : baseVariants
    // This task is intended to build the full image by default
    // Use dockerTarget property to select which variant to build
    def targetVariant = docker_target ?: defaultVariant.get()
    def variantArgs = variants.get()[targetVariant]?.args ?: variants.get()[defaultVariant.get()].args
    def dockerBuildArgs = new HashMap(variantArgs)

    // Add build args if they are defined (needed for some CI or enterprise environments)
    if (project.hasProperty('pipMirrorUrl')) {
        dockerBuildArgs.PIP_MIRROR_URL = project.getProperty('pipMirrorUrl')
    }
    if (project.hasProperty('pipExtraIndexUrl')) {
        dockerBuildArgs.PIP_EXTRA_INDEX_URL = project.getProperty('pipExtraIndexUrl')
    }
    if (project.hasProperty('debianAptRepositoryUrl')) {
        dockerBuildArgs.DEBIAN_REPO_URL = project.getProperty('debianAptRepositoryUrl')
    }

    buildArgs(dockerBuildArgs)
}
