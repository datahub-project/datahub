# DataHub Semantic Search

This directory contains documentation and tools for DataHub's semantic search capability, which enables natural language search across metadata entities using vector embeddings.

## Overview

Traditional keyword search requires exact term matches, limiting discoverability. Semantic search uses AI-generated embeddings to understand the _meaning_ of queries and documents, returning relevant results even when exact keywords don't match.

**Example:**

- Query: "how to request data access permissions"
- Keyword search: ❌ No results (no exact match)
- Semantic search: ✅ Returns "Data Access Request Process" document

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           DataHub Semantic Search                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────────────────┐ │
│  │  Ingestion   │────▶│     GMS      │────▶│      OpenSearch          │ │
│  │  Connector   │     │  (Dual-Write)│     │                          │ │
│  │  + Embeddings│     └──────────────┘     │  ┌────────────────────┐  │ │
│  └──────────────┘                          │  │ entityindex_v2     │  │ │
│         │                                  │  │ (keyword search)   │  │ │
│         │ embeddings                       │  └────────────────────┘  │ │
│         │ generated                        │                          │ │
│         │ at ingestion                     │  ┌────────────────────┐  │ │
│         └─────────────────────────────────▶│  │ entityindex_v2_    │  │ │
│                                            │  │ semantic           │  │ │
│                                            │  │ (vector search)    │  │ │
│                                            │  └────────────────────┘  │ │
│                                            └──────────────────────────┘ │
│                                                          │              │
│  ┌──────────────┐                                        │              │
│  │   GraphQL    │◀───────────────────────────────────────┘              │
│  │   Client     │  semanticSearchAcrossEntities()                       │
│  └──────────────┘                                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## How It Works

### 1. Data Ingestion

Documents and other entities are ingested into DataHub using standard ingestion connectors. When semantic search is enabled, GMS performs a **dual-write**:

- **Primary Index** (`entityindex_v2`): Standard keyword-searchable index
- **Semantic Index** (`entityindex_v2_semantic`): Vector-enabled index for semantic search

> **Note:** The dual-index approach is transitional. The plan is to eventually retire `v2` indices and use `_semantic` indices exclusively for both keyword and semantic search. See [Architecture](./ARCHITECTURE.md) for details.

### 2. Embedding Generation

Embeddings are generated at two points:

**Document Embeddings** (at ingestion time):

- Generated by the ingestion connector, not GMS
- Included with the document when sent to DataHub
- Stored in the semantic index alongside document content

**Query Embeddings** (at search time):

- Generated by GMS using the configured embedding provider
- Used to find similar documents via k-NN search

### 3. Query Processing

When a user performs a semantic search:

1. The query text is converted to an embedding vector using the same model
2. OpenSearch performs k-NN (k-nearest neighbors) vector similarity search
3. Results are ranked by cosine similarity to the query embedding
4. Top matches are returned through the GraphQL API

## Quick Start

### Prerequisites

- DataHub running with semantic search enabled
- AWS credentials (for Bedrock) or API key (for Cohere/OpenAI)
- Python 3.11+ with `uv` package manager

### 1. Enable Semantic Search

Set in your environment (e.g., `docker/profiles/empty2.env`):

```bash
ELASTICSEARCH_SEMANTIC_SEARCH_ENABLED=true
ELASTICSEARCH_SEMANTIC_SEARCH_ENTITIES=document
```

### 2. Ingest Sample Documents with Embeddings

```bash
cd semantic-search-docs
AWS_PROFILE=your-profile uv run python ingest_sample_documents.py --count 10 --embed-first
```

The `--embed-first` flag generates embeddings at ingestion time, simulating what a production ingestion connector would do.

### 3. Verify Semantic Search

```bash
AWS_PROFILE=your-profile uv run python demo_document_semantic_search.py
```

## GraphQL API

### Semantic Search Query

```graphql
query SemanticSearch($input: SearchAcrossEntitiesInput!) {
  semanticSearchAcrossEntities(input: $input) {
    total
    searchResults {
      entity {
        urn
        type
        ... on Document {
          info {
            title
            contents {
              text
            }
          }
        }
      }
    }
  }
}
```

**Variables:**

```json
{
  "input": {
    "query": "how to request data access",
    "types": ["DOCUMENT"],
    "start": 0,
    "count": 10
  }
}
```

## Files in This Directory

### Documentation

| File               | Description                                   |
| ------------------ | --------------------------------------------- |
| `README.md`        | This documentation - overview and quick start |
| `ARCHITECTURE.md`  | Detailed architecture and design decisions    |
| `CONFIGURATION.md` | Configuration options and embedding models    |

### Main Scripts

These are the scripts you can run directly:

| File                               | Description                                           |
| ---------------------------------- | ----------------------------------------------------- |
| `ingest_sample_documents.py`       | Ingest sample documents (with `--embed-first` option) |
| `demo_document_semantic_search.py` | End-to-end semantic search test suite                 |

### Supporting Files

| File                    | Description                      |
| ----------------------- | -------------------------------- |
| `sample_documents.json` | Sample document data for testing |
| `pyproject.toml`        | Python project configuration     |
| `requirements.txt`      | Python dependencies              |

### Internal Modules (prefixed with `_`)

These are internal helper modules, not meant to be run directly:

| File                     | Description                              |
| ------------------------ | ---------------------------------------- |
| `_embedding_utils.py`    | Embedding provider factory and utilities |
| `_embedding_cache.py`    | Local file cache for embeddings          |
| `_embeddings_base.py`    | Base interface for embedding providers   |
| `_litellm_embeddings.py` | LiteLLM-based embedding implementation   |

## Further Reading

- [Architecture Details](./ARCHITECTURE.md) - Deep dive into the design
- [Configuration Guide](./CONFIGURATION.md) - Embedding models and settings
