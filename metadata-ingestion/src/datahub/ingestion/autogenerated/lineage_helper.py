import json
import logging
from functools import lru_cache
from pathlib import Path
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)

# Global cache for lineage data to avoid repeated file reads
_lineage_data: Optional[Dict] = None


def _load_lineage_data() -> Dict:
    """
    This is experimental internal API subject to breaking changes without prior notice.

    Load lineage data from the autogenerated lineage.json file.

    Returns:
        Dict containing the lineage information, or empty dict if file doesn't exist

    Raises:
        json.JSONDecodeError: If lineage.json is malformed
    """
    global _lineage_data

    if _lineage_data is not None:
        return _lineage_data

    # Get the path to lineage.json relative to this file
    current_file = Path(__file__)
    lineage_file = current_file.parent / "lineage.json"

    if not lineage_file.exists():
        logger.warning(
            f"Lineage file not found: {lineage_file}. "
            "This may indicate a packaging issue. Lineage detection will be disabled."
        )
        _lineage_data = {}
        return _lineage_data

    try:
        with open(lineage_file, "r") as f:
            _lineage_data = json.load(f)
        return _lineage_data
    except json.JSONDecodeError as e:
        logger.error(
            f"Failed to parse lineage.json: {e}. Lineage detection will be disabled."
        )
        _lineage_data = {}
        return _lineage_data


def _get_fields(entity_type: str, aspect_name: str) -> List[Dict]:
    """
    This is experimental internal API subject to breaking changes without prior notice.
    """
    return (
        _load_lineage_data()
        .get("entities", {})
        .get(entity_type, {})
        .get(aspect_name, {})
        .get("fields", [])
    )


def _get_lineage_fields(entity_type: str, aspect_name: str) -> List[Dict]:
    """
    This is experimental internal API subject to breaking changes without prior notice.
    """
    return [
        field
        for field in _get_fields(entity_type, aspect_name)
        if field.get("isLineage", False)
    ]


@lru_cache(maxsize=128)
def is_lineage_aspect(entity_type: str, aspect_name: str) -> bool:
    """
    This is experimental internal API subject to breaking changes without prior notice.
    """
    return len(_get_lineage_fields(entity_type, aspect_name)) > 0


def clear_cache() -> None:
    """
    This is experimental internal API subject to breaking changes without prior notice.

    Clear the internal cache of lineage data.

    This is useful for testing or when the lineage.json file has been updated.
    """
    global _lineage_data
    _lineage_data = None
